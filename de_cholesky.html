<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>de_cholesky</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="de_cholesky_files/libs/clipboard/clipboard.min.js"></script>
<script src="de_cholesky_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="de_cholesky_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="de_cholesky_files/libs/quarto-html/popper.min.js"></script>
<script src="de_cholesky_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="de_cholesky_files/libs/quarto-html/anchor.min.js"></script>
<link href="de_cholesky_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="de_cholesky_files/libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="de_cholesky_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="de_cholesky_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="de_cholesky_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<p>Gerne, hier ist ein Studienführer zur Cholesky-Zerlegung, der als Lernhilfe für Studenten des dritten Semesters konzipiert ist.</p>
<hr>
<section id="studienführer-die-cholesky-zerlegung" class="level1">
<h1>Studienführer: Die Cholesky-Zerlegung</h1>
<section id="einführung" class="level2">
<h2 class="anchored" data-anchor-id="einführung">1. Einführung</h2>
<p>Die Cholesky-Zerlegung ist ein grundlegendes Werkzeug in der numerischen linearen Algebra, das speziell für symmetrische, positiv definite Matrizen entwickelt wurde. Sie zerlegt eine solche Matrix in das Produkt einer unteren Dreiecksmatrix und ihrer Transponierten. Diese Zerlegung ist nicht nur rechnerisch effizient, sondern auch numerisch stabil, was sie zu einer bevorzugten Methode in vielen angewandten Bereichen macht, insbesondere im wissenschaftlichen Rechnen und bei der Modellierung von Systemen, die durch teure Computersimulationen beschrieben werden.</p>
<p>Im Kontext von Ersatzmodellen (<em>surrogate models</em>) und Gauß-Prozessen (Kriging) spielt die Cholesky-Zerlegung eine zentrale Rolle bei der effizienten Lösung linearer Gleichungssysteme und der Berechnung von Determinanten, die für die Modellanpassung und Vorhersage erforderlich sind.</p>
</section>
<section id="definition-und-eigenschaften" class="level2">
<h2 class="anchored" data-anchor-id="definition-und-eigenschaften">2. Definition und Eigenschaften</h2>
<section id="symmetrische-positiv-definite-matrizen" class="level3">
<h3 class="anchored" data-anchor-id="symmetrische-positiv-definite-matrizen">2.1 Symmetrische, positiv definite Matrizen</h3>
<p>Die Cholesky-Zerlegung ist ausschließlich für <strong>symmetrische, positiv definite Matrizen</strong> definiert. * Eine Matrix <span class="math inline">\(A\)</span> ist <strong>symmetrisch</strong>, wenn sie gleich ihrer Transponierten ist, d.h., <span class="math inline">\(A = A^T\)</span>. * Eine symmetrische Matrix <span class="math inline">\(A\)</span> ist <strong>positiv definit</strong>, wenn alle ihre Eigenwerte positiv sind. Eine äquivalente Definition besagt, dass für jeden von Null verschiedenen Vektor <span class="math inline">\(\vec{x}\)</span> gilt: <span class="math inline">\(\vec{x}^T A \vec{x} &gt; 0\)</span>. Diese Eigenschaft ist entscheidend, da sie die Eindeutigkeit einer Lösung garantiert und numerische Stabilität gewährleistet. Wenn eine Matrix nicht positiv definit ist, kann die Cholesky-Zerlegung fehlschlagen und einen Fehler auslösen.</p>
</section>
<section id="die-zerlegung" class="level3">
<h3 class="anchored" data-anchor-id="die-zerlegung">2.2 Die Zerlegung</h3>
<p>Für eine symmetrische, positiv definite Matrix <span class="math inline">\(A\)</span> findet die Cholesky-Zerlegung eine untere Dreiecksmatrix <span class="math inline">\(L\)</span> (oder eine obere Dreiecksmatrix <span class="math inline">\(U\)</span>) derart, dass:</p>
<p><span class="math display">\[ A = L L^T \]</span></p>
<p>oder</p>
<p><span class="math display">\[ A = U^T U \]</span></p>
<p>Hierbei ist <span class="math inline">\(L^T\)</span> die Transponierte von <span class="math inline">\(L\)</span>. Wenn NumPy’s <code>cholesky</code>-Funktion verwendet wird, liefert sie standardmäßig den unteren Dreiecksfaktor <span class="math inline">\(L\)</span>; um den oberen Dreiecksfaktor <span class="math inline">\(U\)</span> zu erhalten, muss <span class="math inline">\(L\)</span> transponiert werden (<code>U = cholesky(Psi).T</code>).</p>
</section>
<section id="vorteile-der-cholesky-zerlegung" class="level3">
<h3 class="anchored" data-anchor-id="vorteile-der-cholesky-zerlegung">2.3 Vorteile der Cholesky-Zerlegung</h3>
<p>Die Cholesky-Zerlegung bietet erhebliche Vorteile gegenüber der direkten Matrixinversion: * <strong>Recheneffizienz</strong>: Sie reduziert die rechnerische Komplexität von <span class="math inline">\(O(n^3)\)</span> für die direkte Inversion auf etwa <span class="math inline">\(O(n^3/3)\)</span>. * <strong>Numerische Stabilität</strong>: Die Methode ist numerisch äußerst stabil und robust gegenüber Rundungsfehlern bei Gleitkomma-Berechnungen. Dies ist besonders wichtig bei schlecht konditionierten Matrizen, wo die Determinante nahe Null liegt, was zu Instabilität führen kann.</p>
</section>
</section>
<section id="berechnung-der-cholesky-zerlegung" class="level2">
<h2 class="anchored" data-anchor-id="berechnung-der-cholesky-zerlegung">3. Berechnung der Cholesky-Zerlegung</h2>
<p>Die Cholesky-Zerlegung kann algorithmisch durchgeführt werden. Für eine Matrix <span class="math inline">\(A = \begin{pmatrix} a_{11} &amp; a_{12} \\ a_{21} &amp; a_{22} \end{pmatrix}\)</span> und <span class="math inline">\(L = \begin{pmatrix} l_{11} &amp; 0 \\ l_{21} &amp; l_{22} \end{pmatrix}\)</span> gilt <span class="math inline">\(A = LL^T\)</span>. Dies führt zu den Gleichungen: <span class="math inline">\(a_{11} = l_{11}^2\)</span> <span class="math inline">\(a_{21} = l_{21}l_{11}\)</span> <span class="math inline">\(a_{22} = l_{21}^2 + l_{22}^2\)</span> Daraus kann man die Elemente von <span class="math inline">\(L\)</span> bestimmen: <span class="math inline">\(l_{11} = \sqrt{a_{11}}\)</span> <span class="math inline">\(l_{21} = a_{21}/l_{11}\)</span> <span class="math inline">\(l_{22} = \sqrt{a_{22} - l_{21}^2}\)</span></p>
<p>Dieses Prinzip lässt sich auf größere Matrizen erweitern.</p>
<section id="beispiel-mit-psi" class="level3">
<h3 class="anchored" data-anchor-id="beispiel-mit-psi">3.1 Beispiel mit <span class="math inline">\(\Psi\)</span></h3>
<p>Betrachten wir die Korrelationsmatrix <span class="math inline">\(\Psi\)</span> aus den Quellen: <span class="math display">\[ \Psi = \begin{pmatrix} 1 &amp; e^{-1}\ e^{-1} &amp; 1 \end{pmatrix} \]</span> Um die Cholesky-Zerlegung <span class="math inline">\(\Psi = LDL^T\)</span> (oder <span class="math inline">\(U^TDU\)</span>) zu berechnen, setzen wir: <span class="math display">\[ LDL^T= \begin{pmatrix} 1 &amp; 0 \ l_{21} &amp; 1 \end{pmatrix} \begin{pmatrix} d_{11} &amp; 0 \ 0 &amp; d_{22} \end{pmatrix} \begin{pmatrix} 1 &amp; l_{21} \ 0 &amp; 1 \end{pmatrix} \]</span> Multipliziert man dies aus, erhält man: <span class="math display">\[ \begin{pmatrix} d_{11} &amp; d_{11} l_{21} \ d_{11} l_{21} &amp; d_{11} l_{21}^2 + d_{22} \end{pmatrix} \]</span> Durch Koeffizientenvergleich mit <span class="math inline">\(\Psi\)</span>: 1. <span class="math inline">\(d_{11} = 1\)</span> 2. <span class="math inline">\(l_{21}d_{11} = e^{-1} \Rightarrow l_{21} = e^{-1}\)</span> 3. <span class="math inline">\(d_{11} l_{21}^2 + d_{22} = 1 \Rightarrow d_{22} = 1 - e^{-2}\)</span></p>
<p>Die Cholesky-Zerlegung von <span class="math inline">\(\Psi\)</span> ist somit: <span class="math display">\[ \Psi = \begin{pmatrix} 1 &amp; 0\ e^{-1} &amp; 1\ \end{pmatrix} \begin{pmatrix} 1 &amp; 0\ 0 &amp; 1 - e^{-2}\ \end{pmatrix} \begin{pmatrix} 1 &amp; e^{-1}\ 0 &amp; 1\ \end{pmatrix} = LDL^T \]</span> Alternativ, ohne die explizite Diagonalmatrix <span class="math inline">\(D\)</span>: <span class="math display">\[ \Psi = \begin{pmatrix} 1 &amp; 0\ e^{-1} &amp; \sqrt{1 - e^{-2}}\ \end{pmatrix} \begin{pmatrix} 1 &amp; e^{-1}\ 0 &amp; \sqrt{1 - e^{-2}}\ \end{pmatrix} = U^TU \]</span> .</p>
</section>
<section id="implementierung-in-python" class="level3">
<h3 class="anchored" data-anchor-id="implementierung-in-python">3.2 Implementierung in Python</h3>
<p>Python-Bibliotheken wie <code>numpy</code> bieten effiziente Funktionen zur Cholesky-Zerlegung, z.B. <code>np.linalg.cholesky(A)</code>. Wenn die Matrix nicht positiv definit ist, wird ein <code>LinAlgError</code> ausgelöst.</p>
</section>
</section>
<section id="anwendungen-der-cholesky-zerlegung" class="level2">
<h2 class="anchored" data-anchor-id="anwendungen-der-cholesky-zerlegung">4. Anwendungen der Cholesky-Zerlegung</h2>
<p>Die Cholesky-Zerlegung ist ein vielseitiges Werkzeug in der numerischen linearen Algebra:</p>
<section id="lösung-linearer-gleichungssysteme-axb" class="level3">
<h3 class="anchored" data-anchor-id="lösung-linearer-gleichungssysteme-axb">4.1 Lösung linearer Gleichungssysteme (<span class="math inline">\(Ax=b\)</span>)</h3>
<p>Anstatt die Inverse <span class="math inline">\(A^{-1}\)</span> explizit zu berechnen (was numerisch instabil und teuer ist), kann ein lineares System <span class="math inline">\(A\vec{x} = \vec{b}\)</span> mittels Cholesky-Zerlegung in zwei einfachere Dreieckssysteme zerlegt werden. 1. <strong>Vorwärtssubstitution</strong>: Löse <span class="math inline">\(L\vec{y} = \vec{b}\)</span> nach <span class="math inline">\(\vec{y}\)</span>. Da <span class="math inline">\(L\)</span> eine untere Dreiecksmatrix ist, lässt sich dies leicht rekursiv lösen. 2. <strong>Rückwärtssubstitution</strong>: Löse <span class="math inline">\(L^T\vec{x} = \vec{y}\)</span> nach <span class="math inline">\(\vec{x}\)</span>. Da <span class="math inline">\(L^T\)</span> (oder <span class="math inline">\(U\)</span>) eine obere Dreiecksmatrix ist, lässt sich dies ebenfalls leicht rekursiv lösen.</p>
<p>Dieser zweistufige Prozess ist viel schneller und numerisch stabiler als die direkte Inversion. Im Python-Code wird dies oft durch Funktionen wie <code>scipy.linalg.cho_solve</code> oder <code>numpy.linalg.solve</code> nach der Cholesky-Zerlegung (<code>L = cholesky(Psi, lower=True)</code>) erledigt.</p>
</section>
<section id="berechnung-von-determinanten" class="level3">
<h3 class="anchored" data-anchor-id="berechnung-von-determinanten">4.2 Berechnung von Determinanten</h3>
<p>Für die Berechnung des Logarithmus des Absolutwerts der Determinante einer symmetrischen, positiv definiten Matrix <span class="math inline">\(\Psi\)</span>, was in der Maximum-Likelihood-Schätzung oft vorkommt, ist die Cholesky-Zerlegung besonders nützlich. Es gilt: <span class="math display">\[ \ln(|\Psi|) = 2\sum_{i=1}^{n} \ln(L_{ii}) \]</span> wobei <span class="math inline">\(L_{ii}\)</span> die Diagonalelemente der Cholesky-Faktorisierung <span class="math inline">\(L\)</span> sind. Dieser Ansatz vermeidet die direkte Berechnung der Determinante, die bei schlecht konditionierten Matrizen sehr kleine Werte annehmen und zu numerischer Instabilität führen kann.</p>
</section>
<section id="kriging-und-gauß-prozess-regression-gpr" class="level3">
<h3 class="anchored" data-anchor-id="kriging-und-gauß-prozess-regression-gpr">4.3 Kriging und Gauß-Prozess-Regression (GPR)</h3>
<p>Im Bereich der Gauß-Prozess-Modellierung, auch bekannt als Kriging, ist die Cholesky-Zerlegung ein Kernbestandteil. * <strong>Modellanpassung (MLE)</strong>: Bei der Schätzung der Modellparameter über die Maximum-Likelihood-Methode erfordert die Berechnung der Likelihood-Funktion (oder der konzentrierten Log-Likelihood) mehrere Matrixinversionen. Die Cholesky-Zerlegung, gefolgt von Vorwärts- und Rückwärtssubstitution, ist der schnellste und stabilste Weg, dies zu tun. * <strong>Vorhersage (BLUP)</strong>: Die Vorhersage neuer Werte im Kriging-Modell, bekannt als Best Linear Unbiased Predictor (BLUP), beinhaltet ebenfalls die Lösung linearer Systeme mit der Korrelationsmatrix. Auch hier kommt die Cholesky-Zerlegung zum Einsatz, um die Vorhersage effizient und stabil zu berechnen. * <strong>Numerische Stabilität und Nugget-Effekt</strong>: Wenn Trainingspunkte sehr nahe beieinander liegen, kann die Korrelationsmatrix schlecht konditioniert oder nahezu singulär werden, was die Cholesky-Zerlegung zum Scheitern bringen kann. Um dies zu verhindern, wird ein kleiner positiver Wert, der so genannte <strong>Nugget-Effekt</strong> ($ I $ oder <code>eps</code>), zur Diagonale der Korrelationsmatrix addiert (<span class="math inline">\(\Psi_{new} = \Psi + \lambda I\)</span>). Dieser Nugget stellt sicher, dass die Matrix streng positiv definit und somit die Cholesky-Zerlegung erfolgreich ist. Der Nugget kann auch als statistischer Parameter interpretiert werden, der Rauschen im Modell berücksichtigt und das Modell von einem exakten Interpolator zu einem rauschfilternden Regressor ändert.</p>
</section>
<section id="generierung-von-stichproben-aus-multivariaten-normalverteilungen" class="level3">
<h3 class="anchored" data-anchor-id="generierung-von-stichproben-aus-multivariaten-normalverteilungen">4.4 Generierung von Stichproben aus multivariaten Normalverteilungen</h3>
<p>Die Cholesky-Zerlegung kann auch verwendet werden, um Zufallsstichproben aus einer multivariaten Normalverteilung zu generieren. Wenn <span class="math inline">\(\vec{u}\)</span> ein Vektor von unabhängigen standardnormalverteilten Zufallsvariablen ist und <span class="math inline">\(K = LL^T\)</span> die Cholesky-Zerlegung der Kovarianzmatrix <span class="math inline">\(K\)</span> ist, dann hat der Vektor <span class="math inline">\(\vec{x} = \vec{\mu} + L\vec{u}\)</span> die gewünschte multivariate Normalverteilung mit Mittelwert <span class="math inline">\(\vec{\mu}\)</span> und Kovarianzmatrix <span class="math inline">\(K\)</span>. Auch hier kann ein kleiner “Nugget”-Term zur Kovarianzmatrix hinzugefügt werden, um numerische Stabilität zu gewährleisten, da die Eigenwerte von Kovarianzmatrizen schnell abfallen können.</p>
</section>
<section id="anwendungen-in-optimierungsalgorithmen" class="level3">
<h3 class="anchored" data-anchor-id="anwendungen-in-optimierungsalgorithmen">4.5 Anwendungen in Optimierungsalgorithmen</h3>
<p>Obwohl die Cholesky-Zerlegung selbst kein Optimierungsalgorithmus ist (im Gegensatz zu Gradientenabstieg, Newton-Verfahren oder BFGS), ist sie ein entscheidendes Werkzeug zur Lösung der linearen Systeme, die in vielen fortgeschrittenen Optimierungsverfahren auftreten. Beispielsweise erfordert das Newton-Verfahren zur Minimierung einer Funktion die Lösung eines linearen Systems mit der Hesse-Matrix. Wenn diese Hesse-Matrix symmetrisch und positiv definit ist, kann die Cholesky-Zerlegung für die effiziente und stabile Lösung dieses Systems genutzt werden.</p>
</section>
</section>
<section id="fazit" class="level2">
<h2 class="anchored" data-anchor-id="fazit">5. Fazit</h2>
<p>Die Cholesky-Zerlegung ist ein unverzichtbares Werkzeug in der numerischen linearen Algebra für symmetrische, positiv definite Matrizen. Ihre Effizienz und Robustheit machen sie zur bevorzugten Methode für Aufgaben wie die Lösung linearer Gleichungssysteme, die Berechnung von Determinanten und insbesondere in den rechenintensiven Prozessen von Gauß-Prozessen und Ersatzmodellen. Das Verständnis ihrer Funktionsweise und ihrer Anwendungsbereiche ist für jeden Ingenieur und Naturwissenschaftler, der mit komplexen Berechnungen arbeitet, von grundlegender Bedeutung.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>