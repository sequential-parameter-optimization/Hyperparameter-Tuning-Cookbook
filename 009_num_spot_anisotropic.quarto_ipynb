{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "execute:\n",
        "  cache: false\n",
        "  eval: true\n",
        "  echo: true\n",
        "  warning: false\n",
        "  keep-ipynb: true\n",
        "---\n",
        "\n",
        "\n",
        "# Isotropic and Anisotropic Kriging {#sec-iso-aniso-kriging}\n",
        "\n",
        "This chapter illustrates the difference between isotropic and anisotropic Kriging models. The difference is illustrated with the help of the `spotpython` package. Isotropic Kriging models use the same `theta` value for every dimension. Anisotropic Kriging models use different `theta` values for each dimension.\n",
        "\n",
        "## Example: Isotropic `Spot` Surrogate and the 2-dim Sphere Function {#sec-spot-2d-sphere-iso}\n"
      ],
      "id": "9c37de28"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from math import inf\n",
        "from spotpython.fun.objectivefunctions import analytical\n",
        "from spotpython.spot import spot\n",
        "from spotpython.utils.init import fun_control_init, surrogate_control_init\n",
        "PREFIX=\"003\""
      ],
      "id": "ab2b767b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### The Objective Function: 2-dim Sphere\n",
        "\n",
        "The `spotpython` package provides several classes of objective functions. We will use an analytical objective function, i.e., a function that can be described by a (closed) formula:\n",
        "\n",
        "$$\n",
        "f(x, y) = x^2 + y^2\n",
        "$$\n",
        "The size of the `lower` bound vector determines the problem dimension. Here we will use `np.array([-1, -1])`, i.e., a two-dimensional function.\n"
      ],
      "id": "4c389738"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fun = analytical().fun_sphere\n",
        "fun_control = fun_control_init(PREFIX=PREFIX,\n",
        "                               lower = np.array([-1, -1]),\n",
        "                               upper = np.array([1, 1]))"
      ],
      "id": "b4428bcf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Although the default `spot` surrogate model is an isotropic Kriging model, we will explicitly set the `n_theta` parameter to a value of `1`, so that the same theta value is used for both dimensions.\n",
        "This is done to illustrate the difference between isotropic and anisotropic Kriging models.\n"
      ],
      "id": "4c8cc6a9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "surrogate_control=surrogate_control_init(n_theta=1)"
      ],
      "id": "b86061c0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2 = spot.Spot(fun=fun,\n",
        "                   fun_control=fun_control,\n",
        "                   surrogate_control=surrogate_control)\n",
        "\n",
        "spot_2.run()"
      ],
      "id": "03b715d7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Results\n"
      ],
      "id": "b2c7fb08"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2.print_results()"
      ],
      "id": "3b6a3082",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2.plot_progress(log_y=True)"
      ],
      "id": "0f1b0573",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Example With Anisotropic Kriging\n",
        "\n",
        "As described in @sec-spot-2d-sphere-iso, the default parameter setting of `spotpython`'s Kriging surrogate uses the same `theta` value for every dimension. This is referred to as \"using an isotropic kernel\".  If different `theta` values are used for each dimension, then an anisotropic kernel is used. To enable anisotropic models in `spotpython`, the number of `theta` values should be larger than one. We can use `surrogate_control=surrogate_control_init(n_theta=2)` to enable this behavior (`2` is the problem dimension).\n"
      ],
      "id": "d9a44b02"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "surrogate_control = surrogate_control_init(n_theta=2)\n",
        "spot_2_anisotropic = spot.Spot(fun=fun,\n",
        "                    fun_control=fun_control,\n",
        "                    surrogate_control=surrogate_control)\n",
        "spot_2_anisotropic.run()"
      ],
      "id": "1b052502",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The search progress of the optimization with the anisotropic model can be visualized:\n"
      ],
      "id": "81f3aa10"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2_anisotropic.plot_progress(log_y=True)"
      ],
      "id": "085f7941",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2_anisotropic.print_results()"
      ],
      "id": "9eb54746",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2_anisotropic.surrogate.plot()"
      ],
      "id": "5932d8ca",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Taking a Look at the `theta` Values\n",
        "\n",
        "#### `theta` Values from the `spot` Model\n",
        "\n",
        "We can check, whether one or several `theta` values were used. The `theta` values from the surrogate can be printed as follows:\n"
      ],
      "id": "1a461412"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2_anisotropic.surrogate.theta"
      ],
      "id": "9c20016f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "* Since the surrogate from the isotropic setting was stored as `spot_2`, we can also take a look at the `theta` value from this model:\n"
      ],
      "id": "867696ab"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2.surrogate.theta"
      ],
      "id": "ba6277ea",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### TensorBoard\n",
        "\n",
        "Now we can start TensorBoard in the background with the following command:\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "```{raw}\n",
        "tensorboard --logdir=\"./runs\"\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "We can access the TensorBoard web server with the following URL:\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "```{raw}\n",
        "http://localhost:6006/\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "The TensorBoard plot illustrates how `spotpython` can be used as a microscope for the internal mechanisms of the surrogate-based optimization process. Here, one important parameter, the learning rate $\\theta$ of the Kriging surrogate is plotted against the number of optimization steps.\n",
        "\n",
        "![TensorBoard visualization of the spotpython surrogate model.](figures_static/03_tensorboard_03.png){width=\"100%\"}\n",
        "\n",
        "\n",
        "\n",
        "## Exercises\n",
        "\n",
        "\n",
        "### 1. The Branin Function `fun_branin`\n",
        "\n",
        "* Describe the function.\n",
        "  * The input dimension is `2`. The search range is  $-5 \\leq x_1 \\leq 10$ and $0 \\leq x_2 \\leq 15$.\n",
        "* Compare the results from `spotpython` run a) with isotropic and b) anisotropic surrogate models.\n",
        "* Modify the termination criterion: instead of the number of evaluations (which is specified via `fun_evals`), the time should be used as the termination criterion. This can be done as follows (`max_time=1` specifies a run time of one minute):\n"
      ],
      "id": "1e0790af"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "from math import inf\n",
        "fun_control = fun_control_init(\n",
        "              fun_evals=inf,\n",
        "              max_time=1)"
      ],
      "id": "75690f55",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 2. The Two-dimensional Sin-Cos Function `fun_sin_cos`\n",
        "\n",
        "* Describe the function.\n",
        "  *  The input dimension is `2`. The search range is  $-2\\pi \\leq x_1 \\leq 2\\pi$ and $-2\\pi \\leq x_2 \\leq 2\\pi$.\n",
        "* Compare the results from `spotpython` run a) with isotropic and b) anisotropic surrogate models.\n",
        "* Modify the termination criterion (`max_time` instead of `fun_evals`) as described for `fun_branin`.\n",
        "\n",
        "### 3. The Two-dimensional Runge Function `fun_runge`\n",
        "\n",
        "* Describe the function.\n",
        "  *  The input dimension is `2`. The search range is  $-5 \\leq x_1 \\leq 5$ and $-5 \\leq x_2 \\leq 5$.\n",
        "* Compare the results from `spotpython` run a) with isotropic and b) anisotropic surrogate models.\n",
        "* Modify the termination criterion (`max_time` instead of `fun_evals`) as described for `fun_branin`.\n",
        "\n",
        "### 4. The Ten-dimensional Wing-Weight Function `fun_wingwt`\n",
        "\n",
        "* Describe the function.\n",
        "  *  The input dimension is `10`. The search ranges are between 0 and 1 (values are mapped internally to their natural bounds).\n",
        "* Compare the results from `spotpython` run a) with isotropic and b) anisotropic surrogate models.\n",
        "* Modify the termination criterion (`max_time` instead of `fun_evals`) as described for `fun_branin`.\n",
        "\n",
        "\n",
        "### 5. The Two-dimensional Rosenbrock Function `fun_rosen` {#sec-09-exercise-rosen}\n",
        "\n",
        "* Describe the function.\n",
        "  *  The input dimension is `2`. The search ranges are between -5 and 10.\n",
        "* Compare the results from `spotpython` run a) with isotropic and b) anisotropic surrogate models.\n",
        "* Modify the termination criterion (`max_time` instead of `fun_evals`) as described for `fun_branin`.\n",
        "\n",
        "\n",
        "## Selected Solutions\n",
        "\n",
        "### Solution to Exercise @sec-09-exercise-rosen: The Two-dimensional Rosenbrock Function `fun_rosen`\n",
        "\n",
        "#### The Two Dimensional `fun_rosen`: The Isotropic Case\n"
      ],
      "id": "ca12333b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from spotpython.fun.objectivefunctions import analytical\n",
        "from spotpython.utils.init import fun_control_init, surrogate_control_init\n",
        "from spotpython.spot import spot"
      ],
      "id": "8db35d88",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The `spotpython` package provides several classes of objective functions.\n",
        "We will use the `fun_rosen` in the `analytical` class [[SOURCE]](https://github.com/sequential-parameter-optimization/spotpython/blob/main/src/spotpython/fun/objectivefunctions.py).\n"
      ],
      "id": "56d4b0b1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fun_rosen = analytical().fun_rosen"
      ],
      "id": "86db4191",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here we will use problem dimension $k=2$, which can be specified by the `lower` bound arrays.\n",
        "The size of the `lower` bound array determines the problem dimension.\n",
        "\n",
        "The prefix is set to `\"ROSEN\"` to distinguish the results from the one-dimensional case.\n",
        "Again, TensorBoard can be used to monitor the progress of the optimization.\n"
      ],
      "id": "3717a38d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fun_control = fun_control_init(\n",
        "              PREFIX=\"ROSEN\",\n",
        "              lower = np.array([-5, -5]),\n",
        "              upper = np.array([10, 10]),\n",
        "              show_progress=True)\n",
        "surrogate_control = surrogate_control_init(n_theta=1)\n",
        "spot_rosen = spot.Spot(fun=fun_rosen,\n",
        "                  fun_control=fun_control,\n",
        "                  surrogate_control=surrogate_control)\n",
        "spot_rosen.run()"
      ],
      "id": "fc08470f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-note}\n",
        "Now we can start TensorBoard in the background with the following command:\n",
        "\n",
        "\n",
        "```{raw}\n",
        "tensorboard --logdir=\"./runs\"\n",
        "```\n",
        "\n",
        "and can access the TensorBoard web server with the following URL:\n",
        "\n",
        "\n",
        "```{raw}\n",
        "http://localhost:6006/\n",
        "```\n",
        "\n",
        "::: \n",
        "\n",
        "##### Results\n"
      ],
      "id": "c7edea9c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "_ = spot_rosen.print_results()"
      ],
      "id": "3663e5fc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_rosen.plot_progress()"
      ],
      "id": "9a6cc63b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### A Contour Plot\n",
        "\n",
        "We can select two dimensions, say $i=0$ and $j=1$, and generate a contour plot as follows.\n"
      ],
      "id": "f8ea58c7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "min_z = None\n",
        "max_z = None\n",
        "spot_rosen.plot_contour(i=0, j=1, min_z=min_z, max_z=max_z)"
      ],
      "id": "2fb2833d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "* The variable importance cannot be calculated, because only one `theta` value was used.\n",
        "\n",
        "\n",
        "##### TensorBoard\n",
        "\n",
        "TBD\n",
        "\n",
        "\n",
        "\n",
        "#### The Two Dimensional `fun_rosen`: The Anisotropic Case\n"
      ],
      "id": "e206549c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from spotpython.fun.objectivefunctions import analytical\n",
        "from spotpython.utils.init import fun_control_init, surrogate_control_init\n",
        "from spotpython.spot import spot"
      ],
      "id": "b05d5b0a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The `spotpython` package provides several classes of objective functions.\n",
        "We will use the `fun_rosen` in the `analytical` class [[SOURCE]](https://github.com/sequential-parameter-optimization/spotpython/blob/main/src/spotpython/fun/objectivefunctions.py).\n"
      ],
      "id": "d4bfcf1d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fun_rosen = analytical().fun_rosen"
      ],
      "id": "4b604a59",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here we will use problem dimension $k=2$, which can be specified by the `lower` bound arrays.\n",
        "The size of the `lower` bound array determines the problem dimension. \n",
        "\n",
        "We can also add interpreable labels to the dimensions, which will be used in the plots. "
      ],
      "id": "032f98b6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fun_control = fun_control_init(\n",
        "              PREFIX=\"ROSEN\",\n",
        "              lower = np.array([-5, -5]),\n",
        "              upper = np.array([10, 10]),\n",
        "              show_progress=True)\n",
        "surrogate_control = surrogate_control_init(n_theta=2)\n",
        "spot_rosen = spot.Spot(fun=fun_rosen,\n",
        "                  fun_control=fun_control,\n",
        "                  surrogate_control=surrogate_control)\n",
        "spot_rosen.run()"
      ],
      "id": "9c2c1ea6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-note}\n",
        "Now we can start TensorBoard in the background with the following command:\n",
        "\n",
        "\n",
        "```{raw}\n",
        "tensorboard --logdir=\"./runs\"\n",
        "```\n",
        "\n",
        "and can access the TensorBoard web server with the following URL:\n",
        "\n",
        "\n",
        "```{raw}\n",
        "http://localhost:6006/\n",
        "```\n",
        "\n",
        "::: \n",
        "\n",
        "##### Results\n"
      ],
      "id": "ed757274"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "_ = spot_rosen.print_results()"
      ],
      "id": "b4f106c2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_rosen.plot_progress()"
      ],
      "id": "d93d372c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### A Contour Plot\n",
        "\n",
        "We can select two dimensions, say $i=0$ and $j=1$, and generate a contour plot as follows.\n"
      ],
      "id": "df257eda"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "min_z = None\n",
        "max_z = None\n",
        "spot_rosen.plot_contour(i=0, j=1, min_z=min_z, max_z=max_z)"
      ],
      "id": "3d2ac090",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "* The variable importance can be calculated as follows:\n"
      ],
      "id": "caf959da"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "_ = spot_rosen.print_importance()"
      ],
      "id": "50c907e0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_rosen.plot_importance()"
      ],
      "id": "70e722d3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### TensorBoard\n",
        "\n",
        "TBD\n",
        "\n",
        "\n",
        "\n",
        "## Jupyter Notebook\n",
        "\n",
        ":::{.callout-note}\n",
        "\n",
        "* The Jupyter-Notebook of this lecture is available on GitHub in the [Hyperparameter-Tuning-Cookbook Repository](https://github.com/sequential-parameter-optimization/Hyperparameter-Tuning-Cookbook/blob/main/009_num_spot_anisotropic.ipynb)\n",
        "\n",
        ":::\n"
      ],
      "id": "2cbfa274"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/bartz/miniforge3/envs/spot312/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}