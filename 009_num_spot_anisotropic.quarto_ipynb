{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "execute:\n",
        "  cache: false\n",
        "  eval: true\n",
        "  echo: true\n",
        "  warning: false\n",
        "  keep-ipynb: true\n",
        "---\n",
        "\n",
        "\n",
        "# Isotropic and Anisotropic Kriging {#sec-iso-aniso-kriging}\n",
        "\n",
        "This chapter illustrates the difference between isotropic and anisotropic Kriging models. The difference is illustrated with the help of the `spotpython` package. Isotropic Kriging models use the same `theta` value for every dimension. Anisotropic Kriging models use different `theta` values for each dimension.\n",
        "\n",
        "## Example: Isotropic `Spot` Surrogate and the 2-dim Sphere Function {#sec-spot-2d-sphere-iso}\n"
      ],
      "id": "34e2d0d8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from math import inf\n",
        "from spotpython.fun.objectivefunctions import analytical\n",
        "from spotpython.spot import spot\n",
        "from spotpython.utils.init import fun_control_init, surrogate_control_init\n",
        "PREFIX=\"003\""
      ],
      "id": "3ca49155",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### The Objective Function: 2-dim Sphere\n",
        "\n",
        "The `spotpython` package provides several classes of objective functions. We will use an analytical objective function, i.e., a function that can be described by a (closed) formula:\n",
        "\n",
        "$$\n",
        "f(x, y) = x^2 + y^2\n",
        "$$\n",
        "The size of the `lower` bound vector determines the problem dimension. Here we will use `np.array([-1, -1])`, i.e., a two-dimensional function.\n"
      ],
      "id": "63e7d05f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fun = analytical().fun_sphere\n",
        "fun_control = fun_control_init(PREFIX=PREFIX,\n",
        "                               lower = np.array([-1, -1]),\n",
        "                               upper = np.array([1, 1]))"
      ],
      "id": "2de83ce2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Although the default `spot` surrogate model is an isotropic Kriging model, we will explicitly set the `n_theta` parameter to a value of `1`, so that the same theta value is used for both dimensions.\n",
        "This is done to illustrate the difference between isotropic and anisotropic Kriging models.\n"
      ],
      "id": "3a7be93e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "surrogate_control=surrogate_control_init(n_theta=1)"
      ],
      "id": "fa3d5ae4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2 = spot.Spot(fun=fun,\n",
        "                   fun_control=fun_control,\n",
        "                   surrogate_control=surrogate_control)\n",
        "\n",
        "spot_2.run()"
      ],
      "id": "b84cc032",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Results\n"
      ],
      "id": "f1360e9e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2.print_results()"
      ],
      "id": "5b8c6ddc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2.plot_progress(log_y=True)"
      ],
      "id": "7944257e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Example With Anisotropic Kriging\n",
        "\n",
        "As described in @sec-spot-2d-sphere-iso, the default parameter setting of `spotpython`'s Kriging surrogate uses the same `theta` value for every dimension. This is referred to as \"using an isotropic kernel\".  If different `theta` values are used for each dimension, then an anisotropic kernel is used. To enable anisotropic models in `spotpython`, the number of `theta` values should be larger than one. We can use `surrogate_control=surrogate_control_init(n_theta=2)` to enable this behavior (`2` is the problem dimension).\n"
      ],
      "id": "f26c9d32"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "surrogate_control = surrogate_control_init(n_theta=2)\n",
        "spot_2_anisotropic = spot.Spot(fun=fun,\n",
        "                    fun_control=fun_control,\n",
        "                    surrogate_control=surrogate_control)\n",
        "spot_2_anisotropic.run()"
      ],
      "id": "ad99b8ae",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The search progress of the optimization with the anisotropic model can be visualized:\n"
      ],
      "id": "e2ea37a7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2_anisotropic.plot_progress(log_y=True)"
      ],
      "id": "274329bd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2_anisotropic.print_results()"
      ],
      "id": "3c0871e7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2_anisotropic.surrogate.plot()"
      ],
      "id": "f00f6b13",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Taking a Look at the `theta` Values\n",
        "\n",
        "#### `theta` Values from the `spot` Model\n",
        "\n",
        "We can check, whether one or several `theta` values were used. The `theta` values from the surrogate can be printed as follows:\n"
      ],
      "id": "69d781b2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2_anisotropic.surrogate.theta"
      ],
      "id": "716d5b1b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "* Since the surrogate from the isotropic setting was stored as `spot_2`, we can also take a look at the `theta` value from this model:\n"
      ],
      "id": "4cf03ccb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_2.surrogate.theta"
      ],
      "id": "aaa061c2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### TensorBoard\n",
        "\n",
        "Now we can start TensorBoard in the background with the following command:\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "```{raw}\n",
        "tensorboard --logdir=\"./runs\"\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "We can access the TensorBoard web server with the following URL:\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "```{raw}\n",
        "http://localhost:6006/\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "The TensorBoard plot illustrates how `spotpython` can be used as a microscope for the internal mechanisms of the surrogate-based optimization process. Here, one important parameter, the learning rate $\\theta$ of the Kriging surrogate is plotted against the number of optimization steps.\n",
        "\n",
        "![TensorBoard visualization of the spotpython surrogate model.](figures_static/03_tensorboard_03.png){width=\"100%\"}\n",
        "\n",
        "\n",
        "\n",
        "## Exercises\n",
        "\n",
        "\n",
        "### 1. The Branin Function `fun_branin`\n",
        "\n",
        "* Describe the function.\n",
        "  * The input dimension is `2`. The search range is  $-5 \\leq x_1 \\leq 10$ and $0 \\leq x_2 \\leq 15$.\n",
        "* Compare the results from `spotpython` run a) with isotropic and b) anisotropic surrogate models.\n",
        "* Modify the termination criterion: instead of the number of evaluations (which is specified via `fun_evals`), the time should be used as the termination criterion. This can be done as follows (`max_time=1` specifies a run time of one minute):\n"
      ],
      "id": "1ebb9398"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "from math import inf\n",
        "fun_control = fun_control_init(\n",
        "              fun_evals=inf,\n",
        "              max_time=1)"
      ],
      "id": "6800409e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 2. The Two-dimensional Sin-Cos Function `fun_sin_cos`\n",
        "\n",
        "* Describe the function.\n",
        "  *  The input dimension is `2`. The search range is  $-2\\pi \\leq x_1 \\leq 2\\pi$ and $-2\\pi \\leq x_2 \\leq 2\\pi$.\n",
        "* Compare the results from `spotpython` run a) with isotropic and b) anisotropic surrogate models.\n",
        "* Modify the termination criterion (`max_time` instead of `fun_evals`) as described for `fun_branin`.\n",
        "\n",
        "### 3. The Two-dimensional Runge Function `fun_runge`\n",
        "\n",
        "* Describe the function.\n",
        "  *  The input dimension is `2`. The search range is  $-5 \\leq x_1 \\leq 5$ and $-5 \\leq x_2 \\leq 5$.\n",
        "* Compare the results from `spotpython` run a) with isotropic and b) anisotropic surrogate models.\n",
        "* Modify the termination criterion (`max_time` instead of `fun_evals`) as described for `fun_branin`.\n",
        "\n",
        "### 4. The Ten-dimensional Wing-Weight Function `fun_wingwt`\n",
        "\n",
        "* Describe the function.\n",
        "  *  The input dimension is `10`. The search ranges are between 0 and 1 (values are mapped internally to their natural bounds).\n",
        "* Compare the results from `spotpython` run a) with isotropic and b) anisotropic surrogate models.\n",
        "* Modify the termination criterion (`max_time` instead of `fun_evals`) as described for `fun_branin`.\n",
        "\n",
        "\n",
        "### 5. The Two-dimensional Rosenbrock Function `fun_rosen` {#sec-09-exercise-rosen}\n",
        "\n",
        "* Describe the function.\n",
        "  *  The input dimension is `2`. The search ranges are between -5 and 10.\n",
        "* Compare the results from `spotpython` run a) with isotropic and b) anisotropic surrogate models.\n",
        "* Modify the termination criterion (`max_time` instead of `fun_evals`) as described for `fun_branin`.\n",
        "\n",
        "\n",
        "## Selected Solutions\n",
        "\n",
        "### Solution to Exercise @sec-09-exercise-rosen: The Two-dimensional Rosenbrock Function `fun_rosen`\n",
        "\n",
        "#### The Two Dimensional `fun_rosen`: The Isotropic Case\n"
      ],
      "id": "d04e56b8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from spotpython.fun.objectivefunctions import analytical\n",
        "from spotpython.utils.init import fun_control_init, surrogate_control_init\n",
        "from spotpython.spot import spot"
      ],
      "id": "d85a76db",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The `spotpython` package provides several classes of objective functions.\n",
        "We will use the `fun_rosen` in the `analytical` class [[SOURCE]](https://github.com/sequential-parameter-optimization/spotpython/blob/main/src/spotpython/fun/objectivefunctions.py).\n"
      ],
      "id": "7909fe4d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fun_rosen = analytical().fun_rosen"
      ],
      "id": "e6f53b83",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here we will use problem dimension $k=2$, which can be specified by the `lower` bound arrays.\n",
        "The size of the `lower` bound array determines the problem dimension.\n",
        "\n",
        "The prefix is set to `\"ROSEN\"` to distinguish the results from the one-dimensional case.\n",
        "Again, TensorBoard can be used to monitor the progress of the optimization.\n"
      ],
      "id": "b07d2325"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fun_control = fun_control_init(\n",
        "              PREFIX=\"ROSEN\",\n",
        "              lower = np.array([-5, -5]),\n",
        "              upper = np.array([10, 10]),\n",
        "              show_progress=True)\n",
        "surrogate_control = surrogate_control_init(n_theta=1)\n",
        "spot_rosen = spot.Spot(fun=fun_rosen,\n",
        "                  fun_control=fun_control,\n",
        "                  surrogate_control=surrogate_control)\n",
        "spot_rosen.run()"
      ],
      "id": "74e33378",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-note}\n",
        "Now we can start TensorBoard in the background with the following command:\n",
        "\n",
        "\n",
        "```{raw}\n",
        "tensorboard --logdir=\"./runs\"\n",
        "```\n",
        "\n",
        "and can access the TensorBoard web server with the following URL:\n",
        "\n",
        "\n",
        "```{raw}\n",
        "http://localhost:6006/\n",
        "```\n",
        "\n",
        "::: \n",
        "\n",
        "##### Results\n"
      ],
      "id": "db16dc05"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "_ = spot_rosen.print_results()"
      ],
      "id": "4c67e05e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_rosen.plot_progress()"
      ],
      "id": "538884a5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### A Contour Plot\n",
        "\n",
        "We can select two dimensions, say $i=0$ and $j=1$, and generate a contour plot as follows.\n"
      ],
      "id": "9e85582a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "min_z = None\n",
        "max_z = None\n",
        "spot_rosen.plot_contour(i=0, j=1, min_z=min_z, max_z=max_z)"
      ],
      "id": "9a864516",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "* The variable importance cannot be calculated, because only one `theta` value was used.\n",
        "\n",
        "\n",
        "##### TensorBoard\n",
        "\n",
        "TBD\n",
        "\n",
        "\n",
        "\n",
        "#### The Two Dimensional `fun_rosen`: The Anisotropic Case\n"
      ],
      "id": "30132dfa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from spotpython.fun.objectivefunctions import analytical\n",
        "from spotpython.utils.init import fun_control_init, surrogate_control_init\n",
        "from spotpython.spot import spot"
      ],
      "id": "fc1dbd5f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The `spotpython` package provides several classes of objective functions.\n",
        "We will use the `fun_rosen` in the `analytical` class [[SOURCE]](https://github.com/sequential-parameter-optimization/spotpython/blob/main/src/spotpython/fun/objectivefunctions.py).\n"
      ],
      "id": "18b1a5e9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fun_rosen = analytical().fun_rosen"
      ],
      "id": "2656b390",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here we will use problem dimension $k=2$, which can be specified by the `lower` bound arrays.\n",
        "The size of the `lower` bound array determines the problem dimension. \n",
        "\n",
        "We can also add interpreable labels to the dimensions, which will be used in the plots. "
      ],
      "id": "4c9cb2b0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fun_control = fun_control_init(\n",
        "              PREFIX=\"ROSEN\",\n",
        "              lower = np.array([-5, -5]),\n",
        "              upper = np.array([10, 10]),\n",
        "              show_progress=True)\n",
        "surrogate_control = surrogate_control_init(n_theta=2)\n",
        "spot_rosen = spot.Spot(fun=fun_rosen,\n",
        "                  fun_control=fun_control,\n",
        "                  surrogate_control=surrogate_control)\n",
        "spot_rosen.run()"
      ],
      "id": "83539c36",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-note}\n",
        "Now we can start TensorBoard in the background with the following command:\n",
        "\n",
        "\n",
        "```{raw}\n",
        "tensorboard --logdir=\"./runs\"\n",
        "```\n",
        "\n",
        "and can access the TensorBoard web server with the following URL:\n",
        "\n",
        "\n",
        "```{raw}\n",
        "http://localhost:6006/\n",
        "```\n",
        "\n",
        "::: \n",
        "\n",
        "##### Results\n"
      ],
      "id": "63100e10"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "_ = spot_rosen.print_results()"
      ],
      "id": "07141b53",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_rosen.plot_progress()"
      ],
      "id": "fb349e40",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### A Contour Plot\n",
        "\n",
        "We can select two dimensions, say $i=0$ and $j=1$, and generate a contour plot as follows.\n"
      ],
      "id": "9cbbef00"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "min_z = None\n",
        "max_z = None\n",
        "spot_rosen.plot_contour(i=0, j=1, min_z=min_z, max_z=max_z)"
      ],
      "id": "189e1cee",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "* The variable importance can be calculated as follows:\n"
      ],
      "id": "b602bd16"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "_ = spot_rosen.print_importance()"
      ],
      "id": "7b083d19",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spot_rosen.plot_importance()"
      ],
      "id": "ef091f31",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### TensorBoard\n",
        "\n",
        "TBD\n",
        "\n",
        "\n",
        "\n",
        "## Jupyter Notebook\n",
        "\n",
        ":::{.callout-note}\n",
        "\n",
        "* The Jupyter-Notebook of this lecture is available on GitHub in the [Hyperparameter-Tuning-Cookbook Repository](https://github.com/sequential-parameter-optimization/Hyperparameter-Tuning-Cookbook/blob/main/009_num_spot_anisotropic.ipynb)\n",
        "\n",
        ":::\n"
      ],
      "id": "b952e5aa"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/bartz/miniforge3/envs/spot312/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}