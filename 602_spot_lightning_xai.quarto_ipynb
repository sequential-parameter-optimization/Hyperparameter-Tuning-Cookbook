{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "execute:\n",
        "  cache: false\n",
        "  eval: true\n",
        "  echo: true\n",
        "  warning: false\n",
        "jupyter: python3\n",
        "title: Explainable AI with SpotPython and Pytorch\n",
        "---"
      ],
      "id": "8b6210e6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| label: imports\n",
        "import warnings\n",
        "warnings.filterwarnings(\"ignore\")"
      ],
      "id": "imports",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: configure_spot\n",
        "from spotpython.data.diabetes import Diabetes\n",
        "from spotpython.hyperdict.light_hyper_dict import LightHyperDict\n",
        "from spotpython.fun.hyperlight import HyperLight\n",
        "from spotpython.utils.init import (fun_control_init, surrogate_control_init, design_control_init)\n",
        "from spotpython.utils.eda import gen_design_table\n",
        "from spotpython.spot import spot\n",
        "from spotpython.utils.file import get_experiment_filename\n",
        "from spotpython.hyperparameters.values import set_hyperparameter\n",
        "from math import inf\n",
        "\n",
        "PREFIX=\"602_5\"\n",
        "\n",
        "data_set = Diabetes()\n",
        "\n",
        "fun_control = fun_control_init(\n",
        "    save_experiment=True,\n",
        "    PREFIX=PREFIX,\n",
        "    fun_evals=inf,\n",
        "    max_time=60,\n",
        "    data_set = data_set,\n",
        "    core_model_name=\"light.regression.NNLinearRegressor\",\n",
        "    hyperdict=LightHyperDict,\n",
        "    _L_in=10,\n",
        "    _L_out=1)\n",
        "\n",
        "fun = HyperLight().fun\n",
        "\n",
        "\n",
        "set_hyperparameter(fun_control, \"optimizer\", [ \"Adadelta\", \"Adam\", \"Adamax\"])\n",
        "set_hyperparameter(fun_control, \"l1\", [3,7])\n",
        "set_hyperparameter(fun_control, \"epochs\", [10,12])\n",
        "set_hyperparameter(fun_control, \"batch_size\", [4,11])\n",
        "set_hyperparameter(fun_control, \"dropout_prob\", [0.0, 0.025])\n",
        "set_hyperparameter(fun_control, \"patience\", [2,9])\n",
        "\n",
        "design_control = design_control_init(init_size=7)\n",
        "\n",
        "spot_tuner = spot.Spot(fun=fun,fun_control=fun_control, design_control=design_control)"
      ],
      "id": "configure_spot",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Running the Hyperparameter Tuning or Loading the Existing Model\n"
      ],
      "id": "866a6272"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: run_experiment\n",
        "from spotpython.utils.file import get_experiment_filename, load_experiment\n",
        "import os\n",
        "overwrite = False\n",
        "filename = get_experiment_filename(PREFIX)\n",
        "if os.path.exists(filename) and not overwrite:\n",
        "    (spot_tuner, fun_control, design_control,\n",
        "    surrogate_control, optimizer_control) = load_experiment(filename)\n",
        "else:\n",
        "    print(\"File does not exist or overwrite is True. Starting new experiment.\")\n",
        "    res = spot_tuner.run()\n",
        "# only needed for spotpython version < 0.16.0\n",
        "fun_control.update({\"_L_cond\": None})"
      ],
      "id": "run_experiment",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Results from the Hyperparameter Tuning Experiment\n",
        "\n",
        "* After the hyperparameter tuning is finished, the following information is available:\n",
        "    * the `spot_tuner` object and the associated\n",
        "    * `fun_control` dictionary\n"
      ],
      "id": "bc25e9bb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: print_results\n",
        "res = spot_tuner.print_results(print_screen=True)"
      ],
      "id": "print_results",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: 602_plot_progress_xai\n",
        "spot_tuner.plot_progress()"
      ],
      "id": "plot_progress_xai",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Getting the Best Model, i.e, the Tuned Architecture\n",
        "\n",
        "* The method `get_tuned_architecture` [[DOC]](https://sequential-parameter-optimization.github.io/spotPython/reference/spotpython/hyperparameters/values/#spotpython.hyperparameters.values.get_tuned_architecture) returns the best model architecture found during the hyperparameter tuning.\n",
        "* It returns the transformed values, i.e., `batch_size = 2^x` if the hyperparameter `batch_size` was transformed with the `transform_power_2_int` function.\n"
      ],
      "id": "5f352a46"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: get_tuned_architecture\n",
        "from spotpython.hyperparameters.values import get_tuned_architecture\n",
        "import pprint\n",
        "config = get_tuned_architecture(spot_tuner, fun_control)\n",
        "pprint.pprint(config)"
      ],
      "id": "get_tuned_architecture",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "* Note: `get_tuned_architecture` has the option `force_minX` which does not have any effect in this case.\n"
      ],
      "id": "fba9d9f7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: get_tuned_architecture_force_minX\n",
        "from spotpython.hyperparameters.values import get_tuned_architecture\n",
        "config = get_tuned_architecture(spot_tuner, fun_control, force_minX=True)\n",
        "pprint.pprint(config)"
      ],
      "id": "get_tuned_architecture_force_minX",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Training the Tuned Architecture on the Test Data\n",
        "\n",
        "* Since we are interested in the explainability of the model, we will train the tuned architecture on the test data.\n",
        "* `spotpythons`'s `test_model` function [[DOC]](https://sequential-parameter-optimization.github.io/spotPython/reference/spotpython/light/testmodel/) is used to train the model on the test data.\n",
        "* Note: Until now, we do not use any information about the NN's weights and biases. Only the architecture, which is available as the `config`, is used.\n",
        "* `spotpython` used the TensorBoard logger to save the training process in the `./runs` directory. Therefore, we have to enable the TensorBoard logger in the `fun_control` dictionary. To get a clean start, we remove an existing `runs` folder.\n"
      ],
      "id": "36f9687c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: test_model\n",
        "from spotpython.light.testmodel import test_model\n",
        "from spotpython.light.loadmodel import load_light_from_checkpoint\n",
        "import os\n",
        "# if the directory \"./runs\" exists, delete it\n",
        "if os.path.exists(\"./runs\"):\n",
        "    os.system(\"rm -r ./runs\")\n",
        "fun_control.update({\"tensorboard_log\": True})\n",
        "test_model(config, fun_control)"
      ],
      "id": "test_model",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: load_model_from_chkpt\n",
        "model = load_light_from_checkpoint(config, fun_control)"
      ],
      "id": "load_model_from_chkpt",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Details of the Training Process on the Test Data\n",
        "\n",
        "* The `test_model` method initializes the model with the tuned architecture as follows:\n",
        "\n",
        "```python\n",
        "model = fun_control[\"core_model\"](**config, _L_in=_L_in, _L_out=_L_out, _torchmetric=_torchmetric)\n",
        "```\n",
        "\n",
        "* Then, the Lightning Trainer is initialized with the `fun_control` dictionary and the model as follows:\n",
        "    \n",
        "    ```python\n",
        "        trainer = L.Trainer(\n",
        "        default_root_dir=os.path.join(fun_control[\"CHECKPOINT_PATH\"], config_id),\n",
        "        max_epochs=model.hparams.epochs,\n",
        "        accelerator=fun_control[\"accelerator\"],\n",
        "        devices=fun_control[\"devices\"],\n",
        "        logger=TensorBoardLogger(\n",
        "            save_dir=fun_control[\"TENSORBOARD_PATH\"],\n",
        "            version=config_id,\n",
        "            default_hp_metric=True,\n",
        "            log_graph=fun_control[\"log_graph\"],\n",
        "        ),\n",
        "        callbacks=[\n",
        "            EarlyStopping(monitor=\"val_loss\", patience=config[\"patience\"], mode=\"min\", strict=False, verbose=False),\n",
        "            ModelCheckpoint(\n",
        "                dirpath=os.path.join(fun_control[\"CHECKPOINT_PATH\"], config_id), save_last=True\n",
        "            ), \n",
        "        ],\n",
        "        enable_progress_bar=enable_progress_bar,\n",
        "    )\n",
        "    trainer.fit(model=model, datamodule=dm)    \n",
        "    test_result = trainer.test(datamodule=dm, ckpt_path=\"last\")\n",
        "    ```\n",
        "\n",
        "* As shown in the code above, the last checkpoint ist saved.\n",
        "* `spotpython`'s method `load_light_from_checkpoint` is used to load the last checkpoint and to get the model's weights and biases. It requires the `fun_control` dictionary and the `config_id` as input to find the correct checkpoint.\n",
        "* Now, the model is trained and the weights and biases are available.\n",
        "\n",
        "## Visualizing the Neural Network Architecture\n"
      ],
      "id": "9338491c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# get the device\n",
        "from spotpython.utils.device import getDevice\n",
        "device = getDevice()"
      ],
      "id": "fa40a4be",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: viz_net_spotpython\n",
        "from spotpython.plot.xai import viz_net\n",
        "viz_net(model, device=device)"
      ],
      "id": "viz_net_spotpython",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![architecture](./model_architecture.png)\n",
        "\n",
        "## XAI Methods\n",
        "\n",
        "* `spotpython` provides methods to explain the model's predictions. The following neural network elements can be analyzed: \n",
        "\n",
        "### Weights\n",
        "\n",
        "* Weights are the parameters of the neural network that are learned from the data during training. They connect neurons between layers and determine the strength and direction of the signal sent from one neuron to another. The network adjusts the weights during training to minimize the error between the predicted output and the actual output.\n",
        "* Interpretation of the weights: A high weight value indicates a strong influence of the input neuron on the output. Positive weights suggest a positive correlation, whereas negative weights suggest an inverse relationship between neurons.\n",
        "\n",
        "### Activations\n",
        "\n",
        "* Activations are the outputs produced by neurons after applying an activation function to the weighted sum of inputs. The activation function (e.g., ReLU, sigmoid, tanh) adds non-linearity to the model, allowing it to learn more complex relationships.\n",
        "* Interpretation of the activations: The value of activations indicates the intensity of the signal passed to the next layer. Certain activation patterns can highlight which features or parts of the data the network is focusing on.\n",
        "\n",
        "### Gradients\n",
        "\n",
        "* Gradients are the partial derivatives of the loss function with respect to different parameters (weights) of the network. During backpropagation, gradients are used to update the weights in the direction that reduces the loss by methods like gradient descent.\n",
        "* Interpretation of the gradients: The magnitude of the gradient indicates how much a parameter should change to reduce the error. A large gradient implies a steeper slope and a bigger update, while a small gradient suggests that the parameter is near an optimal point. If gradients are too small (vanishing gradient problem), the network may learn slowly or stop learning. If they are too large (exploding gradient problem), the updates may be unstable.\n",
        "* `sptpython` provides the method `get_gradients` to get the gradients of the model. \n"
      ],
      "id": "102a566a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: import_xai\n",
        "from spotpython.plot.xai import (get_activations, get_gradients, get_weights, visualize_weights, visualize_gradients, visualize_mean_activations, visualize_gradient_distributions, visualize_weights_distributions, visualize_activations_distributions)\n",
        "batch_size = config[\"batch_size\"]"
      ],
      "id": "import_xai",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Getting the Weights\n"
      ],
      "id": "eaf0c8c3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: get_weights\n",
        "from spotpython.plot.xai import sort_layers\n",
        "weights, _ = get_weights(model)\n",
        "# sort_layers(weights)"
      ],
      "id": "get_weights",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: visualize_weights\n",
        "visualize_weights(model, absolute=True, cmap=\"GreenYellowRed\", figsize=(6, 6))"
      ],
      "id": "visualize_weights",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: visualize_weights_distributions\n",
        "visualize_weights_distributions(model, color=f\"C{0}\", columns=4)"
      ],
      "id": "visualize_weights_distributions",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Getting the Activations\n"
      ],
      "id": "e44d94c7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: get_activations\n",
        "from spotpython.plot.xai import get_activations\n",
        "activations, mean_activations, layer_sizes = get_activations(net=model, fun_control=fun_control, batch_size=batch_size, device=device)"
      ],
      "id": "get_activations",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: visualize_mean_activations\n",
        "visualize_mean_activations(mean_activations, layer_sizes=layer_sizes, absolute=True, cmap=\"GreenYellowRed\", figsize=(6, 6))"
      ],
      "id": "visualize_mean_activations",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: visualize_activations_distributions\n",
        "visualize_activations_distributions(activations=activations,\n",
        "                                    net=model, color=\"C0\", columns=4)"
      ],
      "id": "visualize_activations_distributions",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Getting the Gradients\n"
      ],
      "id": "a079efaf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: get_gradients\n",
        "gradients, _ = get_gradients(net=model, fun_control=fun_control, batch_size=batch_size, device=device)"
      ],
      "id": "get_gradients",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: visualize_gradients\n",
        "visualize_gradients(model, fun_control, batch_size, absolute=True, cmap=\"GreenYellowRed\", figsize=(6, 6), device=device)"
      ],
      "id": "visualize_gradients",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: visualize_gradient_distributions\n",
        "visualize_gradient_distributions(model, fun_control, batch_size=batch_size, color=f\"C{0}\", device=device, columns=3)"
      ],
      "id": "visualize_gradient_distributions",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Feature Attributions\n",
        "\n",
        "### Integrated Gradients\n"
      ],
      "id": "737b1bf9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: get_attributions_xai\n",
        "from spotpython.plot.xai import get_attributions, plot_attributions\n",
        "df_att = get_attributions(spot_tuner, fun_control, attr_method=\"IntegratedGradients\", n_rel=10)\n",
        "plot_attributions(df_att, attr_method=\"IntegratedGradients\")"
      ],
      "id": "get_attributions_xai",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Deep Lift\n"
      ],
      "id": "5d1ccf7a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: get_attributions_deep_lift\n",
        "df_lift = get_attributions(spot_tuner, fun_control, attr_method=\"DeepLift\",n_rel=10)\n",
        "print(df_lift)\n",
        "plot_attributions(df_lift,  attr_method=\"DeepLift\")"
      ],
      "id": "get_attributions_deep_lift",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Feature Ablation\n"
      ],
      "id": "00ecd526"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: get_attributions_feature_ablation\n",
        "df_fl = get_attributions(spot_tuner, fun_control, attr_method=\"FeatureAblation\",n_rel=10)"
      ],
      "id": "get_attributions_feature_ablation",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: plot_attributions_feature_ablation\n",
        "print(df_fl)\n",
        "plot_attributions(df_fl, attr_method=\"FeatureAblation\")"
      ],
      "id": "plot_attributions_feature_ablation",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Conductance\n"
      ],
      "id": "59147965"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: get_conductance\n",
        "from spotpython.plot.xai import plot_conductance_last_layer, get_weights_conductance_last_layer\n",
        "weights_last, layer_conductance_last = get_weights_conductance_last_layer(spot_tuner, fun_control)\n",
        "plot_conductance_last_layer(weights_last, layer_conductance_last, figsize=(6, 6))"
      ],
      "id": "get_conductance",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/bartz/miniforge3/envs/spot312/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}