[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hyperparameter Tuning Cookbook",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "index.html#book-structure",
    "href": "index.html#book-structure",
    "title": "Hyperparameter Tuning Cookbook",
    "section": "Book Structure",
    "text": "Book Structure\nThis document is structured in two parts. The first part describes the surrogate model based optimization process and the second part describes the hyperparameter tuning.\nThe first part is structured as follows: The concept of the hyperparameter tuning software spotPython is described in Chapter 8. This introduction is based on one-dimensional examples. Higher-dimensional examples are presented in Chapter 9. Chapter 7 describes isotropic and anisotorpic kriging. How different surrogate models from scikit-learn can be used as surrogates in spotPython optimization runs is explained in Chapter 11. Chapter 4 describes how different optimizers from the scipy optimize package can be used on the surrogate. The differences between the Kriging implementation in spotPython and the GaussianProcessRegressor in scikit-learn are explained in Chapter 12. Chapter 12 describes the expected improvement approach. How noisy functions can be handled is described in Chapter 13. Chapter 14 demonstrates how noisy functions can be handled with Optimal Computational Budget Allocation (OCBA) by Spot.\nThe second part is structured as follows: Chapter 14 describes the hyperparameter tuning of a support vector classifier from scikit-learn with spotPython. Chapter 21 illustrates the hyperparameter tuning of a Hoeffding Adaptive Tree Regressor from river with spotPython.\nChapter 24 describes the execution of the example from the tutorial “Hyperparameter Tuning with Ray Tune” (PyTorch 2023). The integration of spotPython into the PyTorch training workflow is described in detail in the following sections. Section 24.1 describes the setup of the tuners. Section 24.3 describes the data loading. Section 24.5 describes the model to be tuned. The search space is introduced in Section 24.5.3. Optimizers are presented in Section 24.6.1. How to split the data in train, validation, and test sets is described in Section 24.7.1. The selection of the loss function and metrics is described in Section 24.7.5. Section 24.8.1 describes the preparation of the spotPython call. The objective function is described in Section 24.8.2. How to use results from previous runs and default hyperparameter configurations is described in Section 24.8.3. Starting the tuner is shown in Section 24.8.4. TensorBoard can be used to visualize the results as shown in Section 24.9. Results are discussed and explained in Section 24.10. Section 24.11 presents a summary and an outlook for the execution of the example from the tutorial “Hyperparameter Tuning with Ray Tune”.\nFour more examples are presented in the following sections: Chapter 15 describes the hyperparameter tuning of a random forest classifier from scikit-learn with spotPython. Chapter 16 describes the hyperparameter tuning of an XGBoost classifier from scikit-learn with spotPython. Chapter 17 describes the hyperparameter tuning of a support vector classifier from scikit-learn with spotPython. Chapter 18 describes the hyperparameter tuning of a k-nearest neighbors classifier from scikit-learn with spotPython.\nThis part of the book is concluded with a description of the most recent PyTorch hyperparameter tuning approach, which is the integration of spotPython into the PyTorch Lightning training workflow. This is described in Chapter 25. This is considered as the most effective, efficient, and flexible way to integrate spotPython into the PyTorch training workflow.\n\n\n\n\n\n\nHyperparameter Tuning Reference\n\n\n\n\nThe open access book Bartz et al. (2022) provides a comprehensive overview of hyperparameter tuning. It can be downloaded from https://link.springer.com/book/10.1007/978-981-19-5170-1.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe .ipynb notebook (Bartz-Beielstein 2023) is updated regularly and reflects updates and changes in the spotPython package. It can be downloaded from https://github.com/sequential-parameter-optimization/spotPython/blob/main/notebooks/14_spot_ray_hpt_torch_cifar10.ipynb."
  },
  {
    "objectID": "index.html#software-used-in-this-book",
    "href": "index.html#software-used-in-this-book",
    "title": "Hyperparameter Tuning Cookbook",
    "section": "Software Used in this Book",
    "text": "Software Used in this Book\nspotPython (“Sequential Parameter Optimization Toolbox in Python”) is the Python version of the well-known hyperparameter tuner SPOT, which has been developed in the R programming environment for statistical analysis for over a decade. The related open-access book is available here: Hyperparameter Tuning for Machine and Deep Learning with R—A Practical Guide.\nscikit-learn is a Python module for machine learning built on top of SciPy and is distributed under the 3-Clause BSD license. The project was started in 2007 by David Cournapeau as a Google Summer of Code project, and since then many volunteers have contributed.\nPyTorch is an optimized tensor library for deep learning using GPUs and CPUs. Lightning is a lightweight PyTorch wrapper for high-performance AI research. It allows you to decouple the research from the engineering.\nRiver is a Python library for online machine learning. It is designed to be used in real-world environments, where not all data is available at once, but streaming in.\nspotRiver provides an interface between spotPython and River."
  },
  {
    "objectID": "index.html#citation",
    "href": "index.html#citation",
    "title": "Hyperparameter Tuning Cookbook",
    "section": "Citation",
    "text": "Citation\nIf this document has been useful to you and you wish to cite it in a scientific publication, please refer to the following paper, which can be found on arXiv: https://arxiv.org/abs/2307.10262.\n@ARTICLE{bart23iArXiv,\n      author = {{Bartz-Beielstein}, Thomas},\n      title = \"{Hyperparameter Tuning Cookbook:\n          A guide for scikit-learn, PyTorch, river, and spotPython}\",\n     journal = {arXiv e-prints},\n    keywords = {Computer Science - Machine Learning,\n      Computer Science - Artificial Intelligence, 90C26, I.2.6, G.1.6},\n         year = 2023,\n        month = jul,\n          eid = {arXiv:2307.10262},\n        pages = {arXiv:2307.10262},\n          doi = {10.48550/arXiv.2307.10262},\narchivePrefix = {arXiv},\n       eprint = {2307.10262},\n primaryClass = {cs.LG},\n       adsurl = {https://ui.adsabs.harvard.edu/abs/2023arXiv230710262B},\n      adsnote = {Provided by the SAO/NASA Astrophysics Data System}\n}\n\n\n\n\n\n\nBartz, Eva, Thomas Bartz-Beielstein, Martin Zaefferer, and Olaf Mersmann, eds. 2022. Hyperparameter Tuning for Machine and Deep Learning with R - A Practical Guide. Springer.\n\n\nBartz-Beielstein, Thomas. 2023. “PyTorch Hyperparameter Tuning with SPOT: Comparison with Ray Tuner and Default Hyperparameters on CIFAR10.” https://github.com/sequential-parameter-optimization/spotPython/blob/main/notebooks/14_spot_ray_hpt_torch_cifar10.ipynb.\n\n\nPyTorch. 2023. “Hyperparameter Tuning with Ray Tune.” https://pytorch.org/tutorials/beginner/hyperparameter_tuning_tutorial.html."
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Hyperparameter Tuning Cookbook",
    "section": "",
    "text": "https://github.com/sequential-parameter-optimization↩︎"
  },
  {
    "objectID": "001_optimization_rsm.html#surrogates",
    "href": "001_optimization_rsm.html#surrogates",
    "title": "5  Response Surface Methods",
    "section": "5.1 Surrogates",
    "text": "5.1 Surrogates\n\nGathering data is expensive, and sometimes getting exactly the data you want is impossible or unethical\nSurrogate: substitute for the real thing\nIn statistics, draws from predictive equations derived from a fitted model can act as a surrogate for the data-generating mechanism\nBenefits of the surrogate approach:\n\nSurrogate could represent a cheaper way to explore relationships, and entertain “what ifs?”\nSurrogates favor faithful yet pragmatic reproduction of dynamics:\n\ninterpretation,\nestablishing causality, or\nidentification\n\nMany numerical simulators are deterministic, whereas field observations are noisy or have measurement error\n\n\n\n5.1.1 Costs of Simulation\n\nComputer simulations are generally cheaper (but not always!) than physical observation\nSome computer simulations can be just as expensive as field experimentation, but computer modeling is regarded as easier because:\n\nthe experimental apparatus is better understood\nmore aspects may be controlled.\n\n\n\n\n5.1.2 Mathematical Models and Meta-Models\n\nUse of mathematical models leveraging numerical solvers has been commonplace for some time\nMathematical models became more complex, requiring more resources to simulate/solve numerically\nPractitioners increasingly relied on meta-models built off of limited simulation campaigns\n\n\n\n5.1.3 Surrogates = Trained Meta-models\n\nData collected via expensive computer evaluations tuned flexible functional forms that could be used in lieu of further simulation to\n\nsave money or computational resources;\ncope with an inability to perform future runs (expired licenses, off-line or over-impacted supercomputers)\n\nTrained meta-models became known as surrogates\n\n\n\n5.1.4 Computer Experiments\n\nComputer experiment: design, running, and fitting meta-models.\n\nLike an ordinary statistical experiment, except the data are generated by computer codes rather than physical or field observations, or surveys\n\nSurrogate modeling is statistical modeling of computer experiments\n\n\n\n5.1.5 Limits of Mathematical Modeling\n\nMathematical biologists, economists and others had reached the limit of equilibrium-based mathematical modeling with cute closed-form solutions\nStochastic simulations replace deterministic solvers based on FEM, Navier–Stokes or Euler methods\nAgent-based simulation models are used to explore predator-prey (Lotka–Voltera) dynamics, spread of disease, management of inventory or patients in health insurance markets\nConsequence: the distinction between surrogate and statistical model is all but gone\n\n\n\n5.1.6 Example: Why Computer Simulations are Necessary\n\nYou can’t seed a real community with Ebola and watch what happens\nIf there’s (real) field data, say on a historical epidemic, further experimentation may be almost entirely limited to the mathematical and computer modeling side\nClassical statistical methods offer little guidance\n\n\n\n5.1.7 Simulation Requirements\n\nSimulation should\n\nenable rich diagnostics to help criticize that models\nunderstanding its sensitivity to inputs and other configurations\nproviding the ability to optimize and\nrefine both automatically and with expert intervention\n\nAnd it has to do all that while remaining computationally tractable\nOne perspective is so-called response surface methods (RSMs):\na poster child from industrial statistics’ heyday, well before information technology became a dominant industry"
  },
  {
    "objectID": "001_optimization_rsm.html#what-is-rsm",
    "href": "001_optimization_rsm.html#what-is-rsm",
    "title": "6  Response Surface Methods",
    "section": "6.1 What is RSM?",
    "text": "6.1 What is RSM?\n\nCollection of statistical and mathematical tools useful for\n\ndeveloping,\nimproving, and\noptimizing processes\n\nOverarching theme:\n\nstudy of how input variables controlling a product or process potentially influence a response measuring performance or quality characteristics\n\nPros of RSM:\n\nLiterature is rich\nMethods are tried and tested in practice, especially in manufacturing\nCareful experimental design paired with a well understood model and humble expectations\nCan add a lot of value to scientific inquiry, process refinement, optimization, and more\n\nCons of RSM:\n\nSurrogates: simple, crude\nHands-on methods\nLocal methods\n\n\n\n6.1.1 Response Surface Methods: Related Fields\n\nDesign of Experiments\nQuality management\nReliability and\nProductivity\n\n\n\n6.1.2 RSM Applications\n\nBillions of applications from industry and manufacturing\n\nFocused on design, development, and formulation of new products and the improvement of existing products\nAlso from laboratory research\n\nMain domains:\n\nmaterials science,\nmanufacturing,\napplied chemistry, and\nclimate science, and many more\n\n\n\n\n6.1.3 RSM Example\n\nRelationship between the response variable yield (\\(y\\)) in a chemical process and two process variables:\n\nreaction time (\\(\\xi_1\\)) and\nreaction temperature (\\(\\xi_2\\)).\n\nCode below synthesizes this setting for the benefit of illustration\n\nthe form is a variation on the so-called banana function\n\n\n\n\n6.1.4 3d Plot versus Contour Plot\n\n3d plot example:\n\n\\(x_1\\) and \\(x_2\\) are the independent variables\n\\(y\\) is the dependent variable\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef fun_rosen(x1, x2):\n    b = 10\n    return (x1-1)**2 + b*(x2-x1**2)**2\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nx = np.arange(-2.0, 2.0, 0.05)\ny = np.arange(-1.0, 3.0, 0.05)\nX, Y = np.meshgrid(x, y)\nzs = np.array(fun_rosen(np.ravel(X), np.ravel(Y)))\nZ = zs.reshape(X.shape)\n\nax.plot_surface(X, Y, Z)\n\nax.set_xlabel('X1')\nax.set_ylabel('X2')\nax.set_zlabel('Y')\n\nplt.show()\n\n\n\n\n\ncontour plot example:\n\n\\(x_1\\) and \\(x_2\\) are the independent variables\n\\(y\\) is the dependent variable\n\n\n\nimport numpy as np\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\n\ndelta = 0.025\nx1 = np.arange(-2.0, 2.0, delta)\nx2 = np.arange(-1.0, 3.0, delta)\nX1, X2 = np.meshgrid(x1, x2)\nY = fun_rosen(X1, X2)\nfig, ax = plt.subplots()\nCS = ax.contour(X1, X2, Y , 50)\nax.clabel(CS, inline=True, fontsize=10)\nax.set_title(\"Rosenbrock's Banana Function\")\n\nText(0.5, 1.0, \"Rosenbrock's Banana Function\")\n\n\n\n\n\n\nVisual inspection: yield is optimized near \\((\\xi_1. \\xi_2)\\)\n\n\n\n6.1.5 Visualization: Problems in Practice\n\nTrue response surface is unknown in practice\nWhen yield evaluation is not as simple as a toy banana function, but a process requiring care to monitor, reconfigure and run, it’s far too expensive to observe over a dense grid\nAnd, measuring yield may be a noisy/inexact process\nThat’s where stats (RSM) comes in\n\n\n\n6.1.6 RSM: Strategies\n\nRSMs consist of experimental strategies for\nexploring the space of the process (i.e., independent/input) variables (above \\(\\xi_1\\) and \\(\\xi2)\\)\nempirical statistical modeling targeted toward development of an appropriate approximating relationship between the response (yield) and process variables local to a study region of interest\noptimization methods for sequential refinement in search of the levels or values of process variables that produce desirable responses (e.g., that maximize yield or explain variation)\nRSM used for fitting an Empirical Model\nTrue response surface driven by an unknown physical mechanism\nObservations corrupted by noise\nHelpful: fit an empirical model to output collected under different process configurations\nConsider response \\(Y\\) that depends on controllable input variables \\(\\xi_1, \\xi_2, \\ldots, \\xi_m\\)\nRSM: Equations of the Empirical Model\n\n\\(Y=f(\\xi_1, \\xi_2, \\ldots, \\xi_m) + \\epsilon\\)\n\\(\\mathbb{E}\\{Y\\} = \\eta = f(\\xi1_1, \\xi_2, \\ldots, \\xi_m)\\)\n\\(\\epsilon\\) is treated as zero mean idiosyncratic noise possibly representing\n\ninherent variation, or\nthe effect of other systems or\nvariables not under our purview at this time\n\n\n\n\n\n6.1.7 RSM: Noise in the Empirical Model\n\nTypical simplifying assumption: \\(\\epsilon \\sim N(0,\\sigma^2)\\)\nWe seek estimates for \\(f\\) and \\(\\sigma^2\\) from noisy observations \\(Y\\) at inputs \\(\\xi\\)\n\n\n\n6.1.8 RSM: Natural and Coded Variables\n\nInputs \\(\\xi_1, \\xi_2, \\ldots, \\xi_m\\) called natural variables:\n\nexpressed in natural units of measurement, e.g., degrees Celsius, pounds per square inch (psi), etc.\n\nTransformed to coded variables \\(x_1, x_2, \\ldots, x_m\\):\n\nto mitigate hassles and confusion that can arise when working with a multitude of scales of measurement\n\nTypical Transformations offering dimensionless inputs \\(x_1, x_2, \\ldots, x_m\\)\n\nin the unit cube, or\nscaled to have a mean of zero and standard deviation of one, are common choices.\n\nEmpirical model becomes \\(\\eta = f(x_1, x_2, \\ldots, x_m)\\)\n\n\n\n6.1.9 RSM Low-order Polynomials\n\nLow-order polynomial make the following simplifying Assumptions\n\nLearning about \\(f\\) is lots easier if we make some simplifying approximations\nAppealing to Taylor’s theorem, a low-order polynomial in a small, localized region of the input (\\(x\\)) space is one way forward\nClassical RSM:\n\ndisciplined application of local analysis and\nsequential refinement of locality through conservative extrapolation\n\nInherently a hands-on process"
  },
  {
    "objectID": "001_optimization_rsm.html#first-order-models-main-effects-model",
    "href": "001_optimization_rsm.html#first-order-models-main-effects-model",
    "title": "5  Introduction: Numerical Methods",
    "section": "5.2 First-Order Models (Main Effects Model)",
    "text": "5.2 First-Order Models (Main Effects Model)\n\nFirst-order model (sometimes called main effects model) useful in parts of the input space where it’s believed that there’s little curvature in \\(f\\): \\[\\eta = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 \\]\nFor example: \\[\\eta = 50 + 8 x_1 + 3x_2\\]\nIn practice, such a surface would be obtained by fitting a model to the outcome of a designed experiment\nFirst-Order Model in python Evaluated on a Grid\nEvaluate model on a grid in a double-unit square centered at the origin\nCoded units are chosen arbitrarily, although one can imagine deploying this approximating function nearby \\(x^{(0)} = (0,0)\\)\n\n\ndef fun_1(x1,x2):\n    return 50 + 8*x1 + 3*x2\n\n\nimport numpy as np\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\n\ndelta = 0.025\nx1 = np.arange(-1.0, 1.0, delta)\nx2 = np.arange(-1.0, 1.0, delta)\nX1, X2 = np.meshgrid(x1, x2)\nY = fun_1(X1,X2)\nfig, ax = plt.subplots()\nCS = ax.contour(X1, X2, Y)\nax.clabel(CS, inline=True, fontsize=10)\nax.set_title('First Order Model: $50 + 8x_1 + 3x_2$')\n\nText(0.5, 1.0, 'First Order Model: $50 + 8x_1 + 3x_2$')\n\n\n\n\n\n\n5.2.1 First-Order Model Properties\n\nFirst-order model in 2d traces out a plane in \\(y \\times (x_1, x_2)\\) space\nOnly be appropriate for the most trivial of response surfaces, even when applied in a highly localized part of the input space\nAdding curvature is key to most applications:\n\nFirst-order model with interactions induces limited degree of curvature via different rates of change of \\(y\\) as \\(x_1\\) is varied for fixed \\(x_2\\), and vice versa: \\[\\eta = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\beta_{12} x_{12} \\]\n\nFor example \\(\\eta = 50+8x_1+3x_2-4x_1x_2\\)\n\n\n\n5.2.2 First-order Model with Interactions in python\n\nCode below facilitates evaluations for pairs \\((x_1, x_2)\\)\nResponses may be observed over a mesh in the same double-unit square\n\n\ndef fun_11(x1,x2):\n    return 50 + 8 * x1 + 3 * x2 - 4 * x1 * x2\n\n\nimport numpy as np\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\n\ndelta = 0.025\nx1 = np.arange(-2.0, 2.0, delta)\nx2 = np.arange(-2.0, 2.0, delta)\nX1, X2 = np.meshgrid(x1, x2)\nY = fun_11(X1,X2)\nfig, ax = plt.subplots()\nCS = ax.contour(X1, X2, Y, 20)\nax.clabel(CS, inline=True, fontsize=10)\nax.set_title('First Order Model with Interactions')\n\nText(0.5, 1.0, 'First Order Model with Interactions')\n\n\n\n\n\n\n\n5.2.3 Observations: First-Order Model with Interactions\n\nMean response \\(\\eta\\) is increasing marginally in both \\(x_1\\) and \\(x_2\\), or conditional on a fixed value of the other until \\(x_1\\) is 0.75\nRate of increase slows as both coordinates grow simultaneously since the coefficient in front of the interaction term \\(x_1 x_2\\) is negative\nCompared to the first-order model (without interactions): surface is far more useful locally\nLeast squares regressions often flag up significant interactions when fit to data collected on a design far from local optima"
  },
  {
    "objectID": "001_optimization_rsm.html#second-order-models",
    "href": "001_optimization_rsm.html#second-order-models",
    "title": "5  Introduction: Numerical Methods",
    "section": "5.3 Second-Order Models",
    "text": "5.3 Second-Order Models\n\nSecond-order model may be appropriate near local optima where \\(f\\) would have substantial curvature: \\[\\eta = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2  + \\beta_{11}x_1^2 + \\beta_{22}x^2 + \\beta_{12} x_1 x_2\\]\nFor example \\[\\eta = 50 + 8 x_1 + 3x_2 - 7x_1^2 - 3 x_2^2 - 4x_1x_2\\]\nImplementation of the Second-Order Model as fun_2().\n\n\ndef fun_2(x1,x2):\n    return 50 + 8 * x1 + 3 * x2 - 7 * x1**2 - 3*x2**2 - 4 * x1 * x2\n\n\nimport numpy as np\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\n\ndelta = 0.025\nx1 = np.arange(-2.0, 2.0, delta)\nx2 = np.arange(-2.0, 2.0, delta)\nX1, X2 = np.meshgrid(x1, x2)\nY = fun_2(X1,X2)\nfig, ax = plt.subplots()\nCS = ax.contour(X1, X2, Y, 20)\nax.clabel(CS, inline=True, fontsize=10)\nax.set_title('Second Order Model with Interactions. Maximum near about $(0.6,0.2)$')\n\nText(0.5, 1.0, 'Second Order Model with Interactions. Maximum near about $(0.6,0.2)$')\n\n\n\n\n\n\n5.3.1 Second-Order Models: Properties\n\nNot all second-order models would have a single stationary point (in RSM jargon called “a simple maximum”)\nIn “yield maximizing” setting we’re presuming response surface is concave down from a global viewpoint\n\neven though local dynamics may be more nuanced\n\nExact criteria depend upon the eigenvalues of a certain matrix built from those coefficients\nBox and Draper (2007) provide a diagram categorizing all of the kinds of second-order surfaces in RSM analysis, where finding local maxima is the goal\n\n\n\n5.3.2 Example: Stationary Ridge\n\nExample set of coefficients describing what’s called a stationary ridge is provided by the code below\n\n\ndef fun_ridge(x1, x2):\n    return 80 + 4*x1 + 8*x2 - 3*x1**2 - 12*x2**2 - 12*x1*x2\n\n\nimport numpy as np\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\n\ndelta = 0.025\nx1 = np.arange(-2.0, 2.0, delta)\nx2 = np.arange(-2.0, 2.0, delta)\nX1, X2 = np.meshgrid(x1, x2)\nY = fun_ridge(X1,X2)\nfig, ax = plt.subplots()\nCS = ax.contour(X1, X2, Y, 20)\nax.clabel(CS, inline=True, fontsize=10)\nax.set_title('Example of a stationary ridge')\n\nText(0.5, 1.0, 'Example of a stationary ridge')\n\n\n\n\n\n\n\n5.3.3 Observations: Second-Order Model (Ridge)\n\nRidge: a whole line of stationary points corresponding to maxima\nSituation means that the practitioner has some flexibility when it comes to optimizing:\n\ncan choose the precise setting of \\((x_1, x_2)\\) either arbitrarily or (more commonly) by consulting some tertiary criteria\n\n\n\n\n5.3.4 Example: Rising Ridge\n\nAn example of a rising ridge is implemented by the code below.\n\n\ndef fun_ridge_rise(x1, x2):\n     return 80 - 4*x1 + 12*x2 - 3*x1**2 - 12*x2**2 - 12*x1*x2\n\n\nimport numpy as np\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\n\ndelta = 0.025\nx1 = np.arange(-2.0, 2.0, delta)\nx2 = np.arange(-2.0, 2.0, delta)\nX1, X2 = np.meshgrid(x1, x2)\nY = fun_ridge_rise(X1,X2)\nfig, ax = plt.subplots()\nCS = ax.contour(X1, X2, Y, 20)\nax.clabel(CS, inline=True, fontsize=10)\nax.set_title('Rising ridge: $\\\\eta = 80 + 4x_1 + 8x_2 - 3x_1^2 - 12x_2^2 - 12x_1x_2$')\n\nText(0.5, 1.0, 'Rising ridge: $\\\\eta = 80 + 4x_1 + 8x_2 - 3x_1^2 - 12x_2^2 - 12x_1x_2$')\n\n\n\n\n\n\n\n5.3.5 Summary: Rising Ridge\n\nThe stationary point is remote to the study region\nCcontinuum of (local) stationary points along any line going through the 2d space, excepting one that lies directly on the ridge\nAlthough estimated response will increase while moving along the axis of symmetry toward its stationary point, this situation indicates\n\neither a poor fit by the approximating second-order function, or\nthat the study region is not yet precisely in the vicinity of a local optima—often both.\n\n\n\n\n5.3.6 Falling Ridge\n\nInversion of a rising ridge is a falling ridge\nSimilarly indicating one is far from local optima, except that the response decreases as you move toward the stationary point\nFinding a falling ridge system can be a back-to-the-drawing-board affair.\n\n\n\n5.3.7 Saddle Point\n\nFinally, we can get what’s called a saddle or minimax system.\n\n\ndef fun_saddle(x1, x2):\n    return 80 + 4*x1 + 8*x2 - 2*x2**2 - 12*x1*x2 \n\n\nimport numpy as np\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\n\ndelta = 0.025\nx1 = np.arange(-2.0, 2.0, delta)\nx2 = np.arange(-2.0, 2.0, delta)\nX1, X2 = np.meshgrid(x1, x2)\nY = fun_saddle(X1,X2)\nfig, ax = plt.subplots()\nCS = ax.contour(X1, X2, Y, 20)\nax.clabel(CS, inline=True, fontsize=10)\nax.set_title('Saddle Point: $\\\\eta = 80 + 4x_1 + 8x_2 - 2x_2^2 - 12x_1x_2$')\n\nText(0.5, 1.0, 'Saddle Point: $\\\\eta = 80 + 4x_1 + 8x_2 - 2x_2^2 - 12x_1x_2$')\n\n\n\n\n\n\n\n5.3.8 Interpretation: Saddle Points\n\nLikely further data collection, and/or outside expertise, is needed before determining a course of action in this situation\n\n\n\n5.3.9 Summary: Ridge Analysis\n\nFinding a simple maximum, or stationary ridge, represents ideals in the spectrum of second-order approximating functions\nBut getting there can be a bit of a slog\nUsing models fitted from data means uncertainty due to noise, and therefore uncertainty in the type of fitted second-order model\nA ridge analysis attempts to offer a principled approach to navigating uncertainties when one is seeking local maxima\nThe two-dimensional setting exemplified above is convenient for visualization, but rare in practice\nComplications compound when studying the effect of more than two process variables"
  },
  {
    "objectID": "001_optimization_rsm.html#general-rsm-models",
    "href": "001_optimization_rsm.html#general-rsm-models",
    "title": "5  Introduction: Numerical Methods",
    "section": "5.4 General RSM Models",
    "text": "5.4 General RSM Models\n\nGeneral first-order model on \\(m\\) process variables \\(x_1, x_2, \\cdots, x_m\\) is \\[\\eta = \\beta_0 + \\beta_1x_1 + \\cdots + \\beta_m x_m\\]\nGeneral second-order model on \\(m\\) process variables \\[\n\\eta= \\beta_0 + \\sum_{j=1}^m + \\sum_{j=1}^m x_j^2 + \\sum_{j=2}^m \\sum_{k=1}^j \\beta_{kj}x_k x_j.\n\\]\n\n\n5.4.1 Ordinary Least Squares\n\nInference from data is carried out by ordinary least squares (OLS)\nFor an excellent review including R examples, see Sheather (2009)\nOLS and maximum likelihood estimators (MLEs) are in the typical Gaussian linear modeling setup basically equivalent"
  },
  {
    "objectID": "001_optimization_rsm.html#designs",
    "href": "001_optimization_rsm.html#designs",
    "title": "5  Introduction: Numerical Methods",
    "section": "5.5 Designs",
    "text": "5.5 Designs\n\nImportant: Organize the data collection phase of a response surface study carefully\nDesign: choice of \\(x\\)’s where we plan to observe \\(y\\)’s, for the purpose of approximating \\(f\\)\nAnalyses and designs need to be carefully matched\nWhen using a first-order model, some designs are preferred over others\nWhen using a second-order model to capture curvature, a different sort of design is appropriate\nDesign choices often contain features enabling modeling assumptions to be challenged\n\ne.g., to check if initial impressions are supported by the data ultimately collected\n\n\n\n5.5.1 Different Designs\n\nScreening desings: determine which variables matter so that subsequent experiments may be smaller and/or more focused\nThen there are designs tailored to the form of model (first- or second-order, say) in the screened variables\nAnd then there are more designs still"
  },
  {
    "objectID": "001_optimization_rsm.html#rsm-experimentation",
    "href": "001_optimization_rsm.html#rsm-experimentation",
    "title": "5  Introduction: Numerical Methods",
    "section": "5.6 RSM Experimentation",
    "text": "5.6 RSM Experimentation\n\n5.6.1 First Step\n\nRSM-based experimentation begins with a first-order model, possibly with interactions\nPresumption: current process operating far from optimal conditions\nCollect data and apply method of steepest ascent (gradient) on fitted surfaces to move to the optimum\n\n\n\n5.6.2 Second Step\n\nEventually, if all goes well after several such carefully iterated refinements, second-order models are used on appropriate designs in order to zero-in on ideal operating conditions\nCareful analysis of the fitted surface:\n\nRidge analysis with further refinement using gradients of, and\nstandard errors associated with, the fitted surfaces, and so on\n\n\n\n\n5.6.3 Third Step\n\nOnce the practitioner is satisfied with the full arc of\n\ndesign(s),\nfit(s), and\ndecision(s):\n\nA small experiment called confirmation test may be performed to check if the predicted optimal settings are realizable in practice"
  },
  {
    "objectID": "001_optimization_rsm.html#rsm-review-and-general-considerations",
    "href": "001_optimization_rsm.html#rsm-review-and-general-considerations",
    "title": "5  Introduction: Numerical Methods",
    "section": "5.7 RSM: Review and General Considerations",
    "text": "5.7 RSM: Review and General Considerations\n\nFirst Glimpse, RSM seems sensible, and pretty straightforward as quantitative statistics-based analysis goes\nBut: RSM can get complicated, especially when input dimensions are not very low\nDesign considerations are particularly nuanced, since the goal is to obtain reliable estimates of main effects, interaction, and curvature while minimizing sampling effort/expense\nRSM Downside: Inefficiency\n\nDespite intuitive appeal, several RSM downsides become apparent upon reflection\nProblems in practice\nStepwise nature of sequential decision making is inefficient:\n\nNot obvious how to re-use or update analysis from earlier phases, or couple with data from other sources/related experiments\n\n\nRSM Downside: Locality\n\nIn addition to being local in experiment-time (stepwise approach), it’s local in experiment-space\nBalance between\n\nexploration (maybe we’re barking up the wrong tree) and\nexploitation (let’s make things a little better) is modest at best\n\n\nRSM Downside: Expert Knowledge\n\nInterjection of expert knowledge is limited to hunches about relevant variables (i.e., the screening phase), where to initialize search, how to design the experiments\nYet at the same time classical RSMs rely heavily on constant examination throughout stages of modeling and design and on the instincts of seasoned practitioners\n\nRSM Downside: Replicability\n\nParallel analyses, conducted according to the same best intentions, rarely lead to the same designs, model fits and so on\nSometimes that means they lead to different conclusions, which can be cause for concern\n\n\n\n5.7.1 Historical Considerations about RSM\n\nIn spite of those criticisms, however, there was historically little impetus to revise the status quo\nClassical RSM was comfortable in its skin, consistently led to improvements or compelling evidence that none can reasonably be expected\nBut then in the late 20th century came an explosive expansion in computational capability, and with it a means of addressing many of those downsides\n\n\n\n5.7.2 Status Quo\n\nNowadays, field experiments and statistical models, designs and optimizations are coupled with with mathematical models\nSimple equations are not regarded as sufficient to describe real-world systems anymore\nPhysicists figured that out fifty years ago; industrial engineers followed, biologists, social scientists, climate scientists and weather forecasters, etc.\nSystems of equations are required, solved over meshes (e.g., finite elements), or stochastically interacting agents\nGoals for those simulation experiments are as diverse as their underlying dynamics\nOptimization of systems is common, e.g., to identify worst-case scenarios\n\n\n\n5.7.3 The Role of Statistics\n\nSolving systems of equations, or interacting agents, requires computing\nStatistics involved at various stages:\n\nchoosing the mathematical model\nsolving by stochastic simulation (Monte Carlo)\ndesigning the computer experiment\nsmoothing over idiosyncrasies or noise\nfinding optimal conditions, or\ncalibrating mathematical/computer models to data from field experiments\n\n\n\n\n5.7.4 New RSM is needed: DACE\n\nClassical RSMs are not well-suited to any of those tasks, because\n\nthey lack the fidelity required to model these data\ntheir intended application is too local\nthey’re also too hands-on.\n\nOnce computers are involved, a natural inclination is to automate—to remove humans from the loop and set the computer running on the analysis in order to maximize computing throughput, or minimize idle time\nDesign and Analysis of Computer Experiments as a modern extension of RSM\nExperimentation is changing due to advances in machine learning\nGaussian process (GP) regression is the canonical surrogate model\nOrigins in geostatistics (gold mining)\nWide applicability in contexts where prediction is king\nMachine learners exposed GPs as powerful predictors for all sorts of tasks:\nfrom regression to classification,\nactive learning/sequential design,\nreinforcement learning and optimization,\nlatent variable modeling, and so on"
  },
  {
    "objectID": "001_optimization_rsm.html#exercises",
    "href": "001_optimization_rsm.html#exercises",
    "title": "5  Introduction: Numerical Methods",
    "section": "5.8 Exercises",
    "text": "5.8 Exercises\n\nGenerate 3d Plots for the Contour Plots in this notebook.\nWrite a plot_3d function, that takes the objective function fun as an argument.\n\n\nIt should provide the following interface: plot_3d(fun).\n\n\nWrite a plot_contour function, that takes the objective function fun as an argument:\n\n\nIt should provide the following interface: plot_contour(fun).\n\n\nConsider further arguments that might be useful for both function, e.g., ranges, size, etc."
  },
  {
    "objectID": "002_optimization_dace.html#dace-and-rsm",
    "href": "002_optimization_dace.html#dace-and-rsm",
    "title": "2  Design and Analysis of Computer Experiments",
    "section": "2.1 DACE and RSM",
    "text": "2.1 DACE and RSM\nMathematical models implemented in computer codes are used to circumvent the need for expensive field data collection. These models are particularly useful when dealing with highly nonlinear response surfaces, high signal-to-noise ratios (which often involve deterministic evaluations), and a global scope. As a result, a new approach is required in comparison to Response Surface Methodology (RSM).\nWith the improvement in computing power and simulation fidelity, researchers gain higher confidence and a better understanding of the dynamics in physical, biological, and social systems. However, the expansion of configuration spaces and increasing input dimensions necessitates more extensive designs. High-performance computing (HPC) allows for thousands of runs, whereas previously only tens were possible. This shift towards larger models and training data presents new computational challenges.\nResearch questions for DACE (Design and Analysis of Computer Experiments) include how to design computer experiments that make efficient use of computation and how to meta-model computer codes to save on simulation effort. The choice of surrogate model for computer codes significantly impacts the optimal experiment design, and the preferred model-design pairs can vary depending on the specific goal.\nThe combination of computer simulation, design, and modeling with field data from similar real-world experiments introduces a new category of computer model tuning problems. The ultimate goal is to automate these processes to the greatest extent possible, allowing for the deployment of HPC with minimal human intervention.\nOne of the remaining differences between RSM and DACE lies in how they handle noise. DACE employs replication, a technique that would not be used in a deterministic setting, to separate signal from noise. Traditional RSM is best suited for situations where a substantial proportion of the variability in the data is due to noise, and where the acquisition of data values can be severely limited. Consequently, RSM is better suited for a different class of problems, aligning with its intended purposes.\n\n2.1.1 DACE Literature\n\nTwo very good texts on computer experiments and surrogate modeling:\n\nThe Design and Analysis of Computer Experiments, by Santner, Williams, and Notz (2018) is the canonical reference in the statistics literature\nEngineering Design via Surrogate Modeling by Forrester, Sobester, and Keane (2008) is perhaps more popular in engineering\n\n\nWe will analyze an example from the latter."
  },
  {
    "objectID": "002_optimization_dace.html#aircraft-wing-weight-example",
    "href": "002_optimization_dace.html#aircraft-wing-weight-example",
    "title": "2  Design and Analysis of Computer Experiments",
    "section": "2.2 Aircraft Wing Weight Example",
    "text": "2.2 Aircraft Wing Weight Example\n\n2.2.1 AWWE Equation\n\nExample from Forrester et al. \nUnderstand the weight of an unpainted light aircraft wing as a function of nine design and operational parameters:\n\n\\[ W = 0.036 S_W^{0.758} \\times W_{fw}^{0.0035} \\left( \\frac{A}{\\cos^2 \\Lambda} \\right)^{0.6} \\times  q^{0.006}  \\times \\lambda^{0.04} \\] \\[ \\times \\left( \\frac{100 R_{tc}}{\\cos \\Lambda} \\right)^{-0.3} \\times (N_z W_{dg})^{0.49}\\]\n\n\n2.2.2 AWWE AWWE Parameters and Equations (Part 1)\n\n\nTable 2.1: Aircraft Wing Weight Parameters\n\n\n\n\n\n\n\n\n\nSymbol\nParameter\nBaseline\nMinimum\nMaximum\n\n\n\n\n\\(S_W\\)\nWing area (\\(ft^2\\))\n174\n150\n200\n\n\n\\(W_{fw}\\)\nWeight of fuel in wing (lb)\n252\n220\n300\n\n\n\\(A\\)\nAspect ratio\n7.52\n6\n10\n\n\n\\(\\Lambda\\)\nQuarter-chord sweep (deg)\n0\n-10\n10\n\n\n\\(q\\)\nDynamic pressure at cruise (\\(lb/ft^2\\))\n34\n16\n45\n\n\n\\(\\lambda\\)\nTaper ratio\n0.672\n0.5\n1\n\n\n\\(R_{tc}\\)\nAerofoil thickness to chord ratio\n0.12\n0.08\n0.18\n\n\n\\(N_z\\)\nUltimate load factor\n3.8\n2.5\n6\n\n\n\\(W_{dg}\\)\nFlight design gross weight (lb)\n2000\n1700\n2500\n\n\n\\(W_p\\)\npaint weight (lb/ft^2)\n0.064\n0.025\n0.08\n\n\n\n\nThe study begins with a baseline Cessna C172 Skyhawk Aircraft as its reference point. It aims to investigate the impact of wing area and fuel weight on the overall weight of the aircraft. Two crucial parameters in this analysis are the aspect ratio (\\(A\\)), defined as the ratio of the wing’s length to the average chord (thickness of the airfoil), and the taper ratio (\\(\\lambda\\)), which represents the ratio of the maximum to the minimum thickness of the airfoil or the maximum to minimum chord.\nIt’s important to note that the equation used in this context is not a computer simulation but will be treated as one for the purpose of illustration. This approach involves employing a true mathematical equation, even if it’s considered unknown, as a useful tool for generating realistic settings to test the methodology. The functional form of this equation was derived by “calibrating” known physical relationships to curves obtained from existing aircraft data, as referenced in Raymer 2012. Essentially, it acts as a surrogate for actual measurements of aircraft weight.\nExamining the mathematical properties of the AWWE (Aircraft Weight With Wing Area and Fuel Weight Equation), it is evident that the response is highly nonlinear concerning its inputs. While it’s common to apply the logarithm to simplify equations with complex exponents, even when modeling the logarithm, which transforms powers into slope coefficients and products into sums, the response remains nonlinear due to the presence of trigonometric terms. Given the combination of nonlinearity and high input dimension, simple linear and quadratic response surface approximations are likely to be inadequate for this analysis.\n\n\n2.2.3 Goals: Understanding and Optimization\nThe primary goals of this study revolve around understanding and optimization:\n\nUnderstanding: One of the straightforward objectives is to gain a deep understanding of the input-output relationships in this context. Given the global perspective implied by this setting, it becomes evident that a more sophisticated model is almost necessary. At this stage, let’s focus on this specific scenario to establish a clear understanding.\nOptimization: Another application of this analysis could be optimization. There may be an interest in minimizing the weight of the aircraft, but it’s likely that there will be constraints in place. For example, the presence of wings with a nonzero area is essential for the aircraft to be capable of flying. In situations involving (constrained) optimization, a global perspective and, consequently, the use of flexible modeling are vital.\n\nThe provided Python code serves as a genuine computer implementation that “solves” a mathematical model. It accepts arguments encoded in the unit cube, with defaults used to represent baseline settings, as detailed in the table labeled as Table 2.1. To map values from the interval \\([a, b]\\) to the interval \\([0, 1]\\), the following formula can be employed:\n\\[y = f(x) = \\frac{x - a}{b - a}.\\]\nTo reverse this mapping and obtain the original values, the formula \\[g(y) = a + (b - a) y\\] can be used.\n\nimport numpy as np\n\ndef wingwt(Sw=0.48, Wfw=0.4, A=0.38, L=0.5, q=0.62, l=0.344,  Rtc=0.4, Nz=0.37, Wdg=0.38):\n    # put coded inputs back on natural scale\n    Sw = Sw * (200 - 150) + 150 \n    Wfw = Wfw * (300 - 220) + 220 \n    A = A * (10 - 6) + 6 \n    L = (L * (10 - (-10)) - 10) * np.pi/180\n    q = q * (45 - 16) + 16 \n    l = l * (1 - 0.5) + 0.5  \n    Rtc = Rtc * (0.18 - 0.08) + 0.08\n    Nz = Nz * (6 - 2.5) + 2.5\n    Wdg = Wdg*(2500 - 1700) + 1700\n    # calculation on natural scale\n    W = 0.036 * Sw**0.758 * Wfw**0.0035 * (A/np.cos(L)**2)**0.6 * q**0.006 \n    W = W * l**0.04 * (100*Rtc/np.cos(L))**(-0.3) * (Nz*Wdg)**(0.49)\n    return(W)\n\n\n\n2.2.4 Properties of the Python “Solver”\nThe compute time required by the “wingwt” solver is extremely short and can be considered trivial in terms of computational resources. The approximation error is exceptionally small, effectively approaching machine precision, which indicates the high accuracy of the solver’s results.\nTo simulate time-consuming evaluations, a deliberate delay is introduced by incorporating a sleep(3600) command, which effectively synthesizes a one-hour execution time for a particular evaluation.\nMoving on to the AWWE visualization, plotting in two dimensions is considerably simpler than dealing with nine dimensions. To aid in creating visual representations, the code provided below establishes a grid within the unit square to facilitate the generation of sliced visuals. This involves generating a “meshgrid” as outlined in the code.\n\nimport numpy as np\nx = np.linspace(0, 1, 3)\ny = np.linspace(0, 1, 3)\nX, Y = np.meshgrid(x, y)\nzp = zip(np.ravel(X), np.ravel(Y))\nlist(zp)\n\n[(0.0, 0.0),\n (0.5, 0.0),\n (1.0, 0.0),\n (0.0, 0.5),\n (0.5, 0.5),\n (1.0, 0.5),\n (0.0, 1.0),\n (0.5, 1.0),\n (1.0, 1.0)]\n\n\nThe coding used to transform inputs from natural units is largely a matter of taste, so long as it’s easy to undo for reporting back on original scales\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\n# plt.style.use('seaborn-white')\nimport numpy as np\nx = np.linspace(0, 1, 100)\ny = np.linspace(0, 1, 100)\nX, Y = np.meshgrid(x, y)\n\n\n\n2.2.5 Plot 1: Load Factor (\\(N_z\\)) and Aspect Ratio (\\(A\\))\nWe will vary \\(N_z\\) and \\(A\\), with other inputs fixed at their baseline values.\n\nz = wingwt(A = X, Nz = Y)\nfig = plt.figure(figsize=(7., 5.))\nplt.contourf(X, Y, z, 20, cmap='jet')\nplt.xlabel(\"A\")\nplt.ylabel(\"Nz\")\nplt.title(\"Load factor (Nz) vs. Aspect Ratio (A)\")\nplt.colorbar()\nplt.show()\n\n\n\n\nContour plots can be refined, e.g., by adding explicit contour lines as shown in the following figure.\n\ncontours = plt.contour(X, Y, z, 4, colors='black')\nplt.clabel(contours, inline=True, fontsize=8)\nplt.xlabel(\"A\")\nplt.ylabel(\"Nz\")\n\nplt.imshow(z, extent=[0, 1, 0, 1], origin='lower',\n           cmap='jet', alpha=0.9)\nplt.colorbar()\n\n&lt;matplotlib.colorbar.Colorbar at 0x147f8e910&gt;\n\n\n\n\n\nThe interpretation of the AWWE plot can be summarized as follows:\n\nThe figure displays the weight response as a function of two variables, \\(N_z\\) and \\(A\\), using an image-contour plot.\nThe slight curvature observed in the contours suggests an interaction between these two variables.\nNotably, the range of outputs depicted in the figure, spanning from approximately 160 to 320, nearly encompasses the entire range of outputs observed from various input settings within the full 9-dimensional input space.\nThe plot indicates that aircraft wings tend to be heavier when the aspect ratios (\\(A\\)) are high.\nThis observation aligns with the idea that wings are designed to withstand and accommodate high gravitational forces (\\(g\\)-forces, large \\(N_z\\)), and there may be a compounding effect where larger values of \\(N_z\\) contribute to increased wing weight.\nIt’s plausible that this phenomenon is related to the design considerations of fighter jets, which cannot have the efficient and lightweight glider-like wings typically found in other types of aircraft.\n\n\n\n2.2.6 Plot 2: Taper Ratio and Fuel Weight\n\nThe same experiment for two other inputs, e.g., taper ratio \\(\\lambda\\) and fuel weight \\(W_{fw}\\)\n\n\nz = wingwt(Wfw = X,  Nz = Y)\ncontours = plt.contour(X, Y, z, 4, colors='black')\nplt.clabel(contours, inline=True, fontsize=8)\nplt.xlabel(\"WfW\")\nplt.ylabel(\"l\")\n\nplt.imshow(z, extent=[0, 1, 0, 1], origin='lower',\n           cmap='jet', alpha=0.9)\nplt.colorbar();\n\n\n\n\n\nInterpretation of Taper Ratio (\\(l\\)) and Fuel Weight (\\(W_{fw}\\))\n\nApparently, neither input has much effect on wing weight:\n\nwith \\(\\lambda\\) having a marginally greater effect, covering less than 4 percent of the span of weights observed in the \\(A \\times N_z\\) plane\n\nThere’s no interaction evident in \\(\\lambda \\times W_{fw}\\)\n\n\n\n\n2.2.7 The Big Picture: Combining all Variables\n\npl = [\"Sw\", \"Wfw\", \"A\", \"L\", \"q\", \"l\",  \"Rtc\", \"Nz\", \"Wdg\"]\n\n\nimport math\n\nZ = []\nZlab = []\nl = len(pl)\n# lc = math.comb(l,2)\nfor i in range(l):\n    for j in range(i+1, l):\n    # for j in range(l):\n        # print(pl[i], pl[j])\n        d = {pl[i]: X, pl[j]: Y}\n        Z.append(wingwt(**d))\n        Zlab.append([pl[i],pl[j]])\n\nNow we can generate all 36 combinations, e.g., our first example is combination p = 19.\n\np = 19\nZlab[p]\n\n['A', 'Nz']\n\n\nTo help interpret outputs from experiments such as this one—to level the playing field when comparing outputs from other pairs of inputs—code below sets up a color palette that can be re-used from one experiment to the next. We use the arguments vmin=180 and vmax =360 to implement comparibility\n\nplt.contourf(X, Y, Z[p], 20, cmap='jet', vmin=180, vmax=360)\nplt.xlabel(Zlab[p][0])\nplt.ylabel(Zlab[p][1])\nplt.colorbar()\n\n&lt;matplotlib.colorbar.Colorbar at 0x15626f210&gt;\n\n\n\n\n\n\nLet’s plot the second example, taper ratio \\(\\lambda\\) and fuel weight \\(W_{fw}\\)\nThis is combination 11:\n\n\np = 11\nZlab[p]\n\n['Wfw', 'l']\n\n\n\nplt.contourf(X, Y, Z[p], 20, cmap='jet', vmin=180, vmax=360)\nplt.xlabel(Zlab[p][0])\nplt.ylabel(Zlab[p][1])\nplt.colorbar()\n\n&lt;matplotlib.colorbar.Colorbar at 0x15633a7d0&gt;\n\n\n\n\n\n\nUsing a global colormap indicates that these variables have minor effects on the wing weight.\nImportant factors can be detected by visual inspection\nPlotting the Big Picture: we can plot all 36 combinations in one figure.\n\n\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import ImageGrid\nimport numpy as np\n\nfig = plt.figure(figsize=(20., 20.))\ngrid = ImageGrid(fig, 111,  # similar to subplot(111)\n                 nrows_ncols=(6,6),  # creates 2x2 grid of axes\n                 axes_pad=0.5,  # pad between axes in inch.\n                 share_all=True,\n                 label_mode=\"0\",\n                 ) \ni = 0\nfor ax, im in zip(grid, Z):\n    # Iterating over the grid returns the Axes.\n    ax.set_xlabel(Zlab[i][0])\n    ax.set_ylabel(Zlab[i][1])\n    # ax.set_title(Zlab[i][1] + \" vs. \" + Zlab[i][0])\n    ax.contourf(X, Y, im, 30, cmap = \"jet\",  vmin = 180, vmax = 360)\n    i = i + 1\n       \nplt.show()\n\n\n\n\n\n\n2.2.8 AWWE Landscape\n\nOur Observations\n\nThe load factor \\(N_z\\), which determines the magnitude of the maximum aerodynamic load on the wing, is very active and involved in interactions with other variables.\n\n\nClassic example: the interaction of \\(N_z\\) with the aspect ratio \\(A\\) indicates a heavy wing for high aspect ratios and large \\(g\\)-forces\nThis is the reaon why highly manoeuvrable fighter jets cannot have very efficient, glider wings)\n\n\nAspect ratio \\(A\\) and airfoil thickness to chord ratio \\(R_{tc}\\) have nonlinear interactions.\nMost important variables:\n\n\nUltimate load factor \\(N_z\\), wing area \\(S_w\\), and flight design gross weight\\(W_{dg}\\).\n\n\nLittle impact: dynamic pressure \\(q\\), taper ratio \\(l\\), and quarter-chord sweep \\(L\\).\n\nExpert Knowledge\n\nAircraft designers know that the overall weight of the aircraft and the wing area must be kept to a minimum\nthe latter usually dictated by constraints such as required stall speed, landing distance, turn rate, etc.\n\n\n\n\n2.2.9 Summary of the First Experiments\n\nFirst, we considered two pairs of inputs, out of 36 total pairs\nThen, the “Big Picture”:\n\nFor each pair we evaluated wingwt 10,000 times\n\nDoing the same for all pairs would require 360K evaluations:\n\nnot a reasonable number with a real computer simulation that takes any non-trivial amount of time to evaluate\nOnly 1s per evaluation: \\(&gt;100\\) hours\n\nMany solvers take minutes/hours/days to execute a single run\nAnd: three-way interactions?\nConsequence: a different strategy is needed"
  },
  {
    "objectID": "002_optimization_dace.html#exercise",
    "href": "002_optimization_dace.html#exercise",
    "title": "2  Design and Analysis of Computer Experiments",
    "section": "2.3 Exercise",
    "text": "2.3 Exercise\n\n2.3.1 Adding Paint Weight\n\nPaint weight is not considered.\nAdd Paint Weight \\(W_p\\) to formula (the updated formula is shown below) and update the functions and plots in the notebook.\n\n\\[ W = 0.036S_W^{0.758} \\times W_{fw}^{0.0035} \\times \\left( \\frac{A}{\\cos^2 \\Lambda} \\right)^{0.6} \\times q^{0.006} \\times \\lambda^{0.04} \\] \\[ \\times \\left( \\frac{100 R_{tc}}{\\cos \\Lambda} \\right)^{-0.3} \\times (N_z W_{dg})^{0.49} + S_w W_p\\]"
  },
  {
    "objectID": "003_optimization_gp.html",
    "href": "003_optimization_gp.html",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "",
    "text": "8 Kriging in a Nutshell"
  },
  {
    "objectID": "003_optimization_gp.html#introduction-to-gaussian-processes",
    "href": "003_optimization_gp.html#introduction-to-gaussian-processes",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "7.2 Introduction to Gaussian Processes",
    "text": "7.2 Introduction to Gaussian Processes\nThe concept of GP (Gaussian Process) regression can be understood as a simple extension of linear modeling. It is worth noting that this approach goes by various names and acronyms, including “kriging,” a term derived from geostatistics, as introduced by Matheron in 1963. Additionally, it is referred to as Gaussian spatial modeling or a Gaussian stochastic process, and machine learning (ML) researchers often use the term Gaussian process regression (GPR). In all of these instances, the central focus is on regression. This involves training on both inputs and outputs, with the ultimate objective of making predictions and quantifying uncertainty (referred to as uncertainty quantification or UQ).\nHowever, it’s important to emphasize that GPs are not a universal solution for every problem. Specialized tools may outperform GPs in specific, non-generic contexts, and GPs have their own set of limitations that need to be considered.\n\n7.2.1 Gaussian Process Prior\nIn this context, any finite collection of realizations, which is represented by \\(n\\) observations, is modeled as having a multivariate normal (MVN) distribution. The characteristics of these realizations can be fully described by two key parameters:\n\nTheir mean, denoted as an \\(n\\)-vector \\(\\mu\\).\nThe covariance matrix, denoted as an \\(n \\times n\\) matrix \\(\\Sigma\\). This covariance matrix encapsulates the relationships and variability between the individual realizations within the collection.\n\n\n\n7.2.2 Covariance Function\nThe covariance function is defined by inverse exponentiated squared Euclidean distance: \\[\\Sigma(x, x') = \\exp\\{ - || x - x '||^2 \\}.\\]\nCovariance decays exponentially fast as \\(x\\) and \\(x'\\) become farther apart. Observe that \\[\\Sigma(x,x) = 1\\] and \\[\\Sigma(x, x') &lt; 1\\] for \\(x \\neq x'\\) The function \\(\\Sigma(x,x')\\) must be positive definite.\nPositive definiteness in the context of the covariance matrix \\(\\Sigma_n\\) is a fundamental requirement. It is determined by evaluating \\(\\Sigma(x_i, x_j)\\) at pairs of \\(n\\) \\(x\\)-values, denoted as \\(x_1, x_2, \\ldots, x_n\\). The condition for positive definiteness is that for all \\(x\\) vectors that are not equal to zero, the expression \\(x^\\top \\Sigma_n x\\) must be greater than zero. This property is essential when intending to use \\(\\Sigma_n\\) as a covariance matrix in multivariate normal (MVN) analysis. It is analogous to the requirement in univariate Gaussian distributions where the variance parameter, \\(\\sigma^2\\), must be positive.\nGaussian Processes (GPs) can be effectively utilized to generate random data that follows a smooth functional relationship. The process involves the following steps:\n\nSelect a set of \\(x\\)-values, denoted as \\(x_1, x_2, \\ldots, x_n\\).\nDefine the covariance matrix \\(\\Sigma_n\\) by evaluating \\(\\Sigma_n^{ij} = \\Sigma(x_i, x_j)\\) for \\(i, j = 1, 2, \\ldots, n\\).\nGenerate an \\(n\\)-variate realization \\(Y\\) that follows a multivariate normal distribution with a mean of zero and a covariance matrix \\(\\Sigma_n\\), expressed as \\(Y \\sim \\mathcal{N}_n(0, \\Sigma_n)\\).\nVisualize the result by plotting it in the \\(x\\)-\\(y\\) plane.\n\n\n\n7.2.3 Construction of the Covariance Matrix\nHere is an one-dimensional example. The process begins by creating an input grid using \\(x\\)-values. This grid consists of 100 elements, providing the basis for further analysis and visualization.\n\nimport numpy as np\nn = 100\nX = np.linspace(0, 10, n, endpoint=False).reshape(-1,1)\n\nIn the context of this discussion, the construction of the covariance matrix, denoted as \\(\\Sigma_n\\), relies on the concept of inverse exponentiated squared Euclidean distances. However, it’s important to note that a modification is introduced later in the process. Specifically, the diagonal of the covariance matrix is augmented with a small value, represented as “eps” or \\(\\epsilon\\).\nThe reason for this augmentation is that while inverse exponentiated distances theoretically ensure the covariance matrix’s positive definiteness, in practical applications, the matrix can sometimes become numerically ill-conditioned. By adding a small value to the diagonal, such as \\(\\epsilon\\), this ill-conditioning issue is mitigated. In this context, \\(\\epsilon\\) is often referred to as “jitter.”\n\nimport numpy as np\nfrom numpy import array, zeros, power, ones, exp, multiply, eye, linspace, mat, spacing, sqrt, arange, append, ravel\nfrom numpy.linalg import cholesky, solve\nfrom numpy.random import multivariate_normal\ndef build_Psi(X, theta):\n    n = X.shape[0]\n    k = X.shape[1]\n    D = zeros((k, n, n))\n    for l in range(k):\n        for i in range(n):\n            for j in range(i, n):\n                D[l, i, j] = theta[l]*(X[i,l] - X[j,l])**2\n    D = sum(D)\n    D = D + D.T\n    return exp(-D)  \n\n\ntheta = np.array([1.0])\nPsi = build_Psi(X, theta)\nnp.round(Psi, 3)\n\narray([[1.   , 0.99 , 0.961, ..., 0.   , 0.   , 0.   ],\n       [0.99 , 1.   , 0.99 , ..., 0.   , 0.   , 0.   ],\n       [0.961, 0.99 , 1.   , ..., 0.   , 0.   , 0.   ],\n       ...,\n       [0.   , 0.   , 0.   , ..., 1.   , 0.99 , 0.961],\n       [0.   , 0.   , 0.   , ..., 0.99 , 1.   , 0.99 ],\n       [0.   , 0.   , 0.   , ..., 0.961, 0.99 , 1.   ]])\n\n\n\nimport matplotlib.pyplot as plt\nplt.imshow(Psi, cmap='hot', interpolation='nearest')\nplt.colorbar()\nplt.show()\n\n\n\n\n\n\n7.2.4 Generation of Random Samples and Plotting the Realizations of the Random Function\nIn the context of the multivariate normal distribution, the next step is to utilize the previously constructed covariance matrix denoted as Psi. It is used as an essential component in generating random samples from the multivariate normal distribution.\nThe function multivariate_normal is employed for this purpose. It serves as a random number generator specifically designed for the multivariate normal distribution. In this case, the mean of the distribution is set equal to mean, and the covariance matrix is provided as Psi. The argument size specifies the number of realizations, which, in this specific scenario, is set to one.\nBy default, the mean vector is initialized to zero. To match the number of samples, which is equivalent to the number of rows in the X and Psi matrices, the argument zeros(n) is used, where n represents the number of samples.\n\nY = multivariate_normal(zeros(Psi.shape[0]), Psi, size = 1).reshape(-1,1)\nY.shape\n\n(100, 1)\n\n\nNow we can plot the results, i.e., a finite realization of the random function \\(Y()\\) under a GP prior with a particular covariance structure. We will plot those X and Y pairs as connected points on an \\(x\\)-\\(y\\) plane.\n\nimport matplotlib.pyplot as plt\nplt.plot(X, Y)\nplt.title(\"Realization of Random Functions under a GP prior.\\n theta: {}\".format(theta[0]))\nplt.show()\n\n\n\n\n\n\n7.2.5 Properties of the 1d Example\n\n7.2.5.1 Several Bumps:\nIn this analysis, we observe several bumps in the \\(x\\)-range of \\([0,10]\\). These bumps in the function occur because shorter distances exhibit high correlation, while longer distances tend to be essentially uncorrelated. This leads to variations in the function’s behavior.\n\n\n7.2.5.2 Smoothness:\nThe function plotted in the above figure represents only a finite realization, which means that we have data for a limited number of pairs, specifically 100 points. These points appear smooth in a tactile sense because they are closely spaced, and the plot function connects the dots with lines to create the appearance of smoothness. The complete surface, which can be conceptually extended to an infinite realization over a compact domain, is exceptionally smooth in a calculus sense due to the covariance function’s property of being infinitely differentiable.\n\n\n7.2.5.3 Scale of Two:\nRegarding the scale of the \\(Y\\) values, they have a range of approximately \\([-2,2]\\), with a 95% probability of falling within this range. This range is influenced by the scale of the covariance, which is set to 1, without considering the small value, \\(\\epsilon\\), added to the diagonal. In standard statistical terms, 95% of the data points typically fall within two standard deviations of the mean, which is a common measure of the spread or range of data."
  },
  {
    "objectID": "003_optimization_gp.html#background-expectation-mean",
    "href": "003_optimization_gp.html#background-expectation-mean",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "7.3 Background: Expectation, Mean",
    "text": "7.3 Background: Expectation, Mean\nThe distribution of a random vector is characterized by some indexes. One of them is the expected value, which is defined as \\[\nE[X] = \\sum_{x \\in D_X} xp_X(x)  \\qquad \\text{if $X$ is discrete}\n\\] \\[\nE[X] = \\int\\limits_{x \\in D_X} xf_X(x)\\mathrm{d}x  \\quad  \\text{if $X$ is continuous.}\n\\]\nThe mean, \\(\\mu\\), of a probability distribution is a measure of its central tendency or location. That is, \\(E(X)\\) is defined as the average of all possible values of \\(X\\), weighted by their probabilities.\n\n7.3.1 Example\nLet \\(X\\) denote the number produced by rolling a fair die. Then \\[\nE(X) = 1 \\times 1/6 + 2 \\times 1/6 + 3 \\times 1/6 + 4 \\times 1/6 + 5 \\times 1/6 + 6\\times 1/6 = 3.5\n\\]\n\n\n7.3.2 Sample Mean\nThe sample mean is an important estimate of the population mean. The sample mean of a sample \\(\\{x_i\\}\\) (\\(i=1,2,\\ldots,n\\)) is defined as \\[\\overline{x}  = \\frac{1}{n} \\sum_i x_i.\\]\n\n\n7.3.3 Variance and Standard Deviation\nIf we are trying to predict the value of a random variable \\(X\\) by its mean \\(\\mu = E(X)\\), the error will be \\(X-\\mu\\). In many situations it is useful to have an idea how large this deviation or error is. Since \\(E(X-\\mu) = E(X) -\\mu = 0\\), it is necessary to use the absolute value or the square of (\\(X-\\mu\\)). The squared error is the first choice, because the derivatives are easier to calculate. These considerations motivate the definition of the variance:\nThe variance of a random variable \\(X\\) is the mean squared deviation of \\(X\\) from its expected value \\(\\mu = E(X)\\). \\[\\begin{equation}\nVar(X) = E[ (X-\\mu)^2].\n\\end{equation}\\]\n\n\n7.3.4 Standard Deviation\nTaking the square root of the variance to get back to the same scale of units as \\(X\\) gives the standard deviation. The standard deviation of \\(X\\) is the square root of the variance of \\(X\\). \\[\\begin{equation}\nsd(X) = \\sqrt{Var(X)}.\n\\end{equation}\\]\n\n\n7.3.5 Calculation of the Standard Deviation with Python\nThe function numpy.std returns the standard deviation, a measure of the spread of a distribution, of the array elements. The standard deviation is computed for the flattened array by default, otherwise over the specified axis. The argument ddof specifies the Delta Degrees of Freedom. The divisor used in calculations is N - ddof, where N represents the number of elements. By default ddof is zero, i.e., std uses the formula \\[\\begin{equation}  \\sqrt{  \\frac{1}{N} \\sum_i \\left( x_i - \\bar{x} \\right)^2  } \\qquad \\text{with } \\quad \\bar{x} = \\sum_{i=1}^N x_i /N. \\end{equation}\\]\nIf no axis is specified, std uses the flattened array (which is the default.) Since \\(\\bar{x} = 2\\), the following value is computed: \\[ \\sqrt{1/3 \\times \\left( (1-2)^2 + (2-2)^2 + (3-2)^2  \\right)} = \\sqrt{2/3}.\\]\n\nimport numpy as np\na = np.array([[1, 2, 3]])\nnp.std(a)\n\n0.816496580927726\n\n\n\nnp.std(a, axis = 0)\n\narray([0., 0., 0.])\n\n\nThe empirical standard deviation (which uses N-1), \\(\\sqrt{1/2 \\times \\left( (1-2)^2 + (2-2)^2 + (3-2)^2 \\right)} = \\sqrt{2/2}\\), can be calculated as follows:\n\nnp.std(a, ddof=1)\n\n1.0\n\n\n\nnp.std(a, axis = 1)\n\narray([0.81649658])\n\n\n\nA = np.array([[1, 2], [3, 4]])\nA\n\narray([[1, 2],\n       [3, 4]])\n\n\n\nnp.std(A)\n\n1.118033988749895\n\n\n\nnp.std(A, axis=0)\n\narray([1., 1.])\n\n\n\nnp.std(A, axis=1)\n\narray([0.5, 0.5])\n\n\n\n\n7.3.6 Single Versus Double Precision\nIn single precision, std() can be inaccurate:\n\na = np.zeros((2, 4*4), dtype=np.float32)\n\n\na[0, :] = 1.0\na[1, :] = 0.1\na \n\narray([[1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. ,\n        1. , 1. , 1. ],\n       [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1,\n        0.1, 0.1, 0.1]], dtype=float32)\n\n\n\nnp.std(a)\n\n0.45000002\n\n\nComputing the standard deviation in float64 is more accurate (result may vary):\n\nnp.std(a, dtype=np.float64)\n\n0.44999999925494194\n\n\n\n\n7.3.7 Visualization of the Standard Deviation\nThe standard deviation of normal distributed can be visualized in terms of the histogram of \\(X\\):\n\nabout 68% of the values will lie in the interval within one standard deviation of the mean\n95% lie within two standard deviation of the mean\nand 99.9% lie within 3 standard deviations of the mean.\n\n\nimport matplotlib\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(1)\n\n# example data\nmu = 0.0  # mean of distribution\nsigma = 1  # standard deviation of distribution\nx = mu + sigma * np.random.randn(2000)\nnum_bins = 33\nfig, ax = plt.subplots()\n# the histogram of the data\nn, bins, patches = ax.hist(x, num_bins, density=1)\n# add a 'best fit' line\ny = ((1 / (np.sqrt(2 * np.pi) * sigma)) *\n     np.exp(-0.5 * (1 / sigma * (bins - mu))**2))\nax.plot(bins, y, '--')\nax.set_xlabel('x')\nax.set_ylabel('Probability density')\nax.set_title(r'Histogram: $\\mu=0$, $\\sigma=1$')\nax.vlines(-1, ymin=0, ymax = ((1 / (np.sqrt(2 * np.pi) * sigma)) *\n     np.exp(-0.5 * (1 / sigma * (-1.0 - mu))**2)), colors=\"orange\", linestyles=\"-.\")\nax.vlines(1, ymin=0, ymax = ((1 / (np.sqrt(2 * np.pi) * sigma)) *\n     np.exp(-0.5 * (1 / sigma * (1.0 - mu))**2)), colors=\"orange\", linestyles=\"-.\")\n# Tweak spacing to prevent clipping of ylabel\nfig.tight_layout()\nplt.show()"
  },
  {
    "objectID": "003_optimization_gp.html#standardization",
    "href": "003_optimization_gp.html#standardization",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "7.4 Standardization",
    "text": "7.4 Standardization\nTo compare statistical properties of random variables which use different units, it is a common practice to transform these random variables into standardized variables. If a random variable \\(X\\) has expectation \\(E(X) = \\mu\\) and standard deviation \\(sd(X) = \\sigma &gt;0\\), the random variable \\[\nX^{\\ast} = (X-\\mu)/\\sigma\n\\] is called \\(X\\) in standard units. It has \\(E(X^{\\ast}) = 0\\) and \\(sd(X^{\\ast}) =1\\)."
  },
  {
    "objectID": "003_optimization_gp.html#random-numbers-in-python",
    "href": "003_optimization_gp.html#random-numbers-in-python",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "7.5 Random Numbers in Python",
    "text": "7.5 Random Numbers in Python\nResults from computers are deterministic, so it sounds like a contradiction in terms to generate random numbers on a computer. Standard computers generate pseudo-randomnumbers, i.e., numbers that behave as if they were drawn randomly. To generate ten random numbers from a normal distribution, the following command can be used.\n\nimport numpy as np\nrng = np.random.default_rng()\nn = 10\nmu, sigma = 2, 0.1\nx = rng.normal(mu, sigma, n)\n\nVerify the mean:\n\nabs(mu - np.mean(x))\n\n0.005185834748437035\n\n\nNote: To verify the standard deviation, we use ddof = 1 (empirical standard deviation):\n\nabs(sigma - np.std(x, ddof=1))\n\n0.0114191178674692"
  },
  {
    "objectID": "003_optimization_gp.html#the-multivariate-normal-distribution",
    "href": "003_optimization_gp.html#the-multivariate-normal-distribution",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "7.6 The Multivariate Normal Distribution",
    "text": "7.6 The Multivariate Normal Distribution\nThe multivariate normal, multinormal, or Gaussian distribution serves as a generalization of the one-dimensional normal distribution to higher dimensions. To fully define this distribution, it is necessary to specify its mean and covariance matrix. These parameters are analogous to the mean, which represents the central location, and the variance (squared standard deviation) of the one-dimensional normal distribution.\nIn the context of the multivariate normal distribution, the mean takes the form of a coordinate within an n-dimensional space. This coordinate represents the location where samples are most likely to be generated, akin to the peak of the bell curve in a one-dimensional or univariate normal distribution.\nOn the other hand, the covariance within the multivariate normal distribution denotes the extent to which two variables vary together. When drawing n-dimensional samples from this distribution, it results in a set of values represented as \\(X = [x_1, x_2, \\ldots, x_n]\\). The elements of the covariance matrix, such as \\(C_{ij}\\), represent the covariances between the variables \\(x_i\\) and \\(x_j\\). These covariances describe how the different variables in the distribution are related to each other in terms of their variability.\n\nimport numpy as np\nrng = np.random.default_rng()\nimport matplotlib.pyplot as plt\nmean = [0, 0]\ncov = [[9, 0], [0, 4]]  # diagonal covariance\nx, y = rng.multivariate_normal(mean, cov, 1000).T\nplt.plot(x, y, 'x')\nplt.axis('equal')\nplt.grid()\nplt.title(\"Bivariate Normal. Mean zero and covariance: {}\".format(cov))\nplt.show()"
  },
  {
    "objectID": "003_optimization_gp.html#kriging",
    "href": "003_optimization_gp.html#kriging",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "7.7 Kriging",
    "text": "7.7 Kriging\n\n7.7.1 The Kriging Covariance Matrix\n\nBasis functions of the form \\[\\begin{equation} \\psi^{(i)} = \\exp \\left( - \\sum_{l=1}^k \\theta_l | x_{l}^{(i)} - x_{l} | ^{p_l} \\right) \\end{equation}\\] are used in a method known as Kriging.\nAlthough the Kriging basis function is related to the Gaussian basis function, there are some differences:\n\nWhere the Gaussian basis function has \\(1/\\sigma^2\\), the Kriging basis has a vector \\(\\theta = [\\theta_1, \\theta_2, \\ldots, \\theta_k]^T\\).\nThe \\(\\theta\\) vector allows the width of the basis function to vary from dimension to dimension.\nIn the Gaussian basis function, the exponent is fixed at 2, Kriging allows this exponent to vary (typically from 1 to 2).\n\n\n\n\n7.7.2 Building the Kriging Model\n\nConsider a set of \\(k\\)-dimensional sample data \\[X = [x_1, x_2, \\ldots, x_n],\\] i.e., \\(X\\) is a \\((n,k)\\)-matrix, with related responses \\[y = [y_1, y_2, \\ldots, y_n].\\]\nWe are interested in finding an expression for the predicted value at a new point \\(x\\).\nWe are going to interpret the observed responses as if they are generated by a stochastic process, which will be denoted as follows: \\[\\begin{equation} Y = [Y(x_1), \\ldots, Y(x_n) ]^T. \\end{equation}\\]\nThe random process has a mean of \\(\\mu\\) (which is a (n,1)-dimensional vector). The random variables are correlated with each other using the basis function expression \\[\\begin{equation} \\text{cor} [Y(x_i), Y(x_j)] =  \\exp \\left( - \\sum_{l=1}^k \\theta_l | x_{il} - x_{jl} | ^{p_l} \\right). \\end{equation}\\]\nFrom this, the \\((n,n)\\) correlation matrix \\(\\Psi\\) of the observed data can be computed: \\[\\begin{equation} \\Psi = \\begin{pmatrix} \\text{cor} [Y(x_1), Y(x_1)] & \\ldots & \\text{cor} [Y(x_1), Y(x_n)] \\\\  \\vdots & \\ddots & \\vdots \\\\ \\text{cor} [Y(x_n), Y(x_1)] &  \\ldots & \\text{cor} [Y(x_n), Y(x_n)] \\end{pmatrix} .\\end{equation}\\]\n\n\n\n7.7.3 Example: Correlation Matrix\n\nLet \\(n=4\\) and \\(k=3\\). The sample plan is represented by the following matrix \\(X\\): \\[X = \\begin{pmatrix} x_{11} & x_{12} & x_{13}\\\\ x_{21} & x_{22} & x_{23}\\\\ x_{31} & x_{32} & x_{33}\\\\ x_{41} & x_{42} & x_{43}\\\\ \\end{pmatrix}\\]\nTo compute the elements of the matrix \\(\\Psi\\), the following \\(k\\) \\((n,n)\\)-matrices have to be computed: \\[ D_1 = \\begin{pmatrix} x_{11} - x_{11} & x_{11} - x_{21} & x_{11} -x_{31} & x_{11} - x_{41} \\\\  x_{21} - x_{11} & x_{21} - x_{21} & x_{21} -x_{31} & x_{21} - x_{41} \\\\ x_{31} - x_{11} & x_{31} - x_{21} & x_{31} -x_{31} & x_{31} - x_{41} \\\\ x_{41} - x_{11} & x_{41} - x_{21} & x_{41} -x_{31} & x_{41} - x_{41} \\\\\\end{pmatrix}\\] \\[ D_2 = \\begin{pmatrix} x_{12} - x_{12} & x_{12} - x_{22} & x_{12} -x_{32} & x_{12} - x_{42} \\\\  x_{22} - x_{12} & x_{22} - x_{22} & x_{22} -x_{32} & x_{22} - x_{42} \\\\ x_{32} - x_{12} & x_{32} - x_{22} & x_{32} -x_{32} & x_{32} - x_{42} \\\\ x_{42} - x_{12} & x_{42} - x_{22} & x_{42} -x_{32} & x_{42} - x_{42} \\\\\\end{pmatrix}\\] \\[ D_3 = \\begin{pmatrix} x_{13} - x_{13} & x_{13} - x_{23} & x_{13} -x_{33} & x_{13} - x_{43} \\\\  x_{23} - x_{13} & x_{23} - x_{23} & x_{23} -x_{33} & x_{23} - x_{43} \\\\ x_{33} - x_{13} & x_{33} - x_{23} & x_{33} -x_{33} & x_{33} - x_{43} \\\\ x_{43} - x_{13} & x_{43} - x_{23} & x_{43} -x_{33} & x_{43} - x_{43} \\\\\\end{pmatrix}\\]\nSince the matrices are symmetric and the main diagonals are zero, it is sufficient to compute the following matrices: \\[D_1 = \\begin{pmatrix} 0 & x_{11} - x_{21} & x_{11} -x_{31} & x_{11} - x_{41} \\\\  0 &  0 & x_{21} -x_{31} & x_{21} - x_{41} \\\\ 0 & 0 & 0 & x_{31} - x_{41} \\\\ 0 & 0 & 0 & 0 \\\\\\end{pmatrix}\\] \\[ D_2 = \\begin{pmatrix} 0 & x_{12} - x_{22} & x_{12} -x_{32} & x_{12} - x_{42} \\\\  0 & 0 & x_{22} -x_{32} & x_{22} - x_{42} \\\\ 0 & 0 & 0 & x_{32} - x_{42} \\\\ 0 & 0 & 0 & 0 \\\\\\end{pmatrix}\\] \\[ D_3 = \\begin{pmatrix} 0 & x_{13} - x_{23} & x_{13} -x_{33} & x_{13} - x_{43} \\\\  0 & 0 & x_{23} -x_{33} & x_{23} - x_{43} \\\\ 0 & 0 & 0 & x_{33} - x_{43} \\\\ 0 & 0 & 0 & 0 \\\\\\end{pmatrix}\\]\nWe will consider \\(p_l=2\\).\nThe differences will be squared and multiplied by \\(\\theta_i\\), i.e.: \\[ D_1 = \\theta_1 \\begin{pmatrix} 0 & (x_{11} - x_{21})^2 & (x_{11} -x_{31})^2 & (x_{11} - x_{41})^2 \\\\  0 &  0 & (x_{21} -x_{31})^2 & (x_{21} - x_{41})^2 \\\\ 0 & 0 & 0 & (x_{31} - x_{41})^2 \\\\ 0 & 0 & 0 & 0 \\\\\\end{pmatrix}\\] \\[ D_2 = \\theta_2 \\begin{pmatrix} 0 & (x_{12} - x_{22})^2 & (x_{12} -x_{32})^2 & (x_{12} - x_{42})^2 \\\\  0 & 0 & (x_{22} -x_{32})^2 & (x_{22} - x_{42})^2 \\\\ 0 & 0 & 0 & (x_{32} - x_{42})^2 \\\\ 0 & 0 & 0 & 0 \\\\\\end{pmatrix}\\] \\[ D_3 = \\theta_3 \\begin{pmatrix} 0 & (x_{13} - x_{23})^2 & (x_{13} -x_{33})^2 & (x_{13} - x_{43})^2 \\\\  0 & 0 & (x_{23} -x_{33})^2 & (x_{23} - x_{43})^2 \\\\ 0 & 0 & 0 & (x_{33} - x_{43})^2 \\\\ 0 & 0 & 0 & 0 \\\\\\end{pmatrix}\\]\nThe sum of the three matrices \\(D=D_1+ D_2 + D_3\\) will be calculated next: \\[ \\begin{pmatrix} 0 &\n\\theta_1  (x_{11} - x_{21})^2 + \\theta_2 (x_{12} - x_{22})^2 + \\theta_3  (x_{13} - x_{23})^2  &\n\\theta_1 (x_{11} -x_{31})^2 + \\theta_2  (x_{12} -x_{32})^2 + \\theta_3  (x_{13} -x_{33})^2 &\n\\theta_1  (x_{11} - x_{41})^2 + \\theta_2  (x_{12} - x_{42})^2 + \\theta_3 (x_{13} - x_{43})^2\n\\\\  0 &  0 &\n\\theta_1  (x_{21} -x_{31})^2 + \\theta_2 (x_{22} -x_{32})^2 + \\theta_3  (x_{23} -x_{33})^2 &\n\\theta_1  x_{21} - x_{41})^2 + \\theta_2  (x_{22} - x_{42})^2 + \\theta_3 (x_{23} - x_{43})^2\n\\\\ 0 & 0 & 0 &\n\\theta_1 (x_{31} - x_{41})^2 + \\theta_2 (x_{32} - x_{42})^2 + \\theta_3 (x_{33} - x_{43})^2\n\\\\ 0 & 0 & 0 & 0 \\\\\\end{pmatrix}\\]\nFinally, \\[ \\Psi = \\exp(-D)\\] is computed.\nNext, we will demonstrate how this computation can be implemented in Python.\n\n\nfrom numpy import array, zeros, power, ones, exp, multiply, eye, linspace, mat, spacing, sqrt, arange, append, ravel\nfrom numpy.linalg import cholesky, solve\ntheta = np.array([1,2,3])\nX = np.array([ [1,0,0], [0,1,0], [0,0,1], [0,0,0]])\nX\n\narray([[1, 0, 0],\n       [0, 1, 0],\n       [0, 0, 1],\n       [0, 0, 0]])\n\n\n\ndef build_Psi(X, theta):\n    n = X.shape[0]\n    k = X.shape[1]\n    D = zeros((k, n, n))\n    for l in range(k):\n        for i in range(n):\n            for j in range(i, n):\n                D[l, i, j] = theta[l]*(X[i,l] - X[j,l])**2\n    D = sum(D)\n    D = D + D.T\n    return exp(-D)  \n\n\nPsi = build_Psi(X, theta)\nPsi\n\narray([[1.        , 0.04978707, 0.01831564, 0.36787944],\n       [0.04978707, 1.        , 0.00673795, 0.13533528],\n       [0.01831564, 0.00673795, 1.        , 0.04978707],\n       [0.36787944, 0.13533528, 0.04978707, 1.        ]])\n\n\n\nThe same result can be obtained with existing python functions, e.g., from the package scipy.\n\nNote: A small value, eps, can be passed to the function build_Psi to improve the condition number.\n\n\n\nfrom scipy.spatial.distance import squareform\nfrom scipy.spatial.distance import pdist\n\ndef build_Psi(X, theta, eps=sqrt(spacing(1))):\n    return exp(- squareform(pdist(X, metric='sqeuclidean', out=None, w=theta))) +  multiply(eye(X.shape[0]), eps)\n\nPsi = build_Psi(X, theta, eps=.0)\nPsi\n\narray([[1.        , 0.04978707, 0.01831564, 0.36787944],\n       [0.04978707, 1.        , 0.00673795, 0.13533528],\n       [0.01831564, 0.00673795, 1.        , 0.04978707],\n       [0.36787944, 0.13533528, 0.04978707, 1.        ]])\n\n\n\n\n7.7.4 Generate sample from N(\\(\\mu\\), \\(\\Psi\\))\n\nThe following block of code generates 5 draws from a bivariate normal distribution with zero mean and covariance matrix \\(\\Psi\\).\nBecause our input space is three dimensional, the results cannot be visualized in a simple way.\nThe next examples will use a one-dimensional input space, so that our results can be easily visualized in 2d.\n\n\nimport numpy as np\nfrom numpy.random import multivariate_normal\nm = 5\nrng = np.random.default_rng()\nY = multivariate_normal(zeros(Psi.shape[0]), Psi, size=m)"
  },
  {
    "objectID": "003_optimization_gp.html#tuning-theta-and-p",
    "href": "003_optimization_gp.html#tuning-theta-and-p",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "8.1 Tuning \\(\\theta\\) and \\(p\\)",
    "text": "8.1 Tuning \\(\\theta\\) and \\(p\\)\n\nOptimizers such as Nelder-Mead, Conjugate Gradient, or Simulated Annealing can be used to determine optimal values for \\(\\theta\\) and \\(p\\).\nAfter the optimization, the correlation matrix is build with the optimized \\(\\theta\\) and \\(p\\) values. This is best (most likely) Kriging model for the given data \\(y\\).\nWe will skip the optimization step here and use \\(\\theta = 1\\) and \\(p=2\\)."
  },
  {
    "objectID": "003_optimization_gp.html#kriging-prediction",
    "href": "003_optimization_gp.html#kriging-prediction",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "8.2 Kriging Prediction",
    "text": "8.2 Kriging Prediction\n\nMain idea for prediction:\n\nThe new \\(Y(x)\\) should be consistent with the old sample data \\(X\\).\n\nFor a new prediction \\(\\hat{y}\\) at \\(\\vec{x}\\), the value of \\(\\hat{y}\\) is chosen so that it maximizes the likelihood of the sample data \\(\\vec{X}\\) and the prediction, given the (optimized) correlation parameter \\(\\vec{\\theta}\\) and \\(\\vec{p}\\) from above.\nThe observed data \\(\\vec{y}\\) is augmented with the new prediction \\(\\hat{y}\\) which results in the augmented vector \\(\\vec{\\tilde{y}} = ( \\vec{y}^T, \\hat{y})^T\\).\nA vector of correlations between the observed data and the new prediction is defined as \\[\\begin{equation*}\n\\vec{\\psi} =\n\\begin{pmatrix}\n\\text{cor}\\left(\n\\vec{Y}(\\vec{x}^{(1)}),\n\\vec{Y}(\\vec{x})\n\\right) \\\\\n\\vdots  \\\\\n\\text{cor}\\left(\n\\vec{Y}(\\vec{x}^{(n)}),\n\\vec{Y}(\\vec{x})\n\\right)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\vec{\\psi}^{(1)}\\\\\n\\vdots\\\\\n\\vec{\\psi}^{(n)}\n\\end{pmatrix}.\n\\end{equation*}\\]\nThe augmented correlation matrix is constructed as \\[\\begin{equation*}\n\\tilde{\\vec{\\Psi}} =\n\\begin{pmatrix}\n\\vec{\\Psi} & \\vec{\\psi} \\\\\n\\vec{\\psi}^T & 1\n\\end{pmatrix}.\n\\end{equation*}\\]\nThe log-likelihood of the augmented data is \\[\\ln(L) = - \\frac{n}{2} \\ln(2\\pi) - \\frac{n}{2} \\ln(\\hat{\\sigma}^2) - \\frac{1}{2} \\ln |\\vec{\\hat{\\Psi}}| -  \\frac{(\\vec{\\tilde{y}} - \\vec{1}\\hat{\\mu})^T \\vec{\\tilde{\\Psi}}^{-1}(\\vec{\\tilde{y}} - \\vec{1}\\hat{\\mu})}{2 \\hat{\\sigma}^2}.\\]\nThe MLE for \\(\\hat{y}\\) can be calculated as \\[\\hat{y}(\\vec{x}) = \\hat{\\mu} + \\vec{\\psi}^T \\vec{\\tilde{\\Psi}}^{-1} (\\vec{y} - \\vec{1}\\hat{\\mu}).\\]\n\n\n8.2.1 Properties of the Predictor\n\nThis Equation reveals two important properties of the Kriging predictor:\n\nBasis functions: The basis function impacts the vector \\(\\vec{\\psi}\\), which contains the \\(n\\) correlations between the new point \\(\\vec{x}\\) and the observed locations. Values from the \\(n\\) basis functions are added to a mean base term \\(\\mu\\) with weightings \\(\\vec{w} = \\vec{\\tilde{\\Psi}}^{(-1)} (\\vec{y} - \\vec{1}\\hat{\\mu})\\).\nInterpolation: The predictions interpolate the sample data. When calculating the prediction at the \\(i\\)th sample point, \\(\\vec{x}^{(i)}\\), the \\(i\\)th column of \\(\\vec{\\Psi}^{-1}\\) is \\(\\vec{\\psi}\\), and \\(\\vec{\\psi} \\vec{\\Psi}^{-1}\\) is the \\(i\\)th unit vector. Hence, \\(\\hat{y}(\\vec{x}^{(i)}) = y^{(i)}\\)."
  },
  {
    "objectID": "003_optimization_gp.html#example-sinusoid-function",
    "href": "003_optimization_gp.html#example-sinusoid-function",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "8.3 Example: Sinusoid Function",
    "text": "8.3 Example: Sinusoid Function\n\nToy example in 1d where the response is a simple sinusoid measured at eight equally spaced \\(x\\)-locations in the span of a single period of oscillation."
  },
  {
    "objectID": "003_optimization_gp.html#calculating-the-correlation-matrix-psi",
    "href": "003_optimization_gp.html#calculating-the-correlation-matrix-psi",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "8.4 Calculating the Correlation Matrix \\(\\Psi\\)",
    "text": "8.4 Calculating the Correlation Matrix \\(\\Psi\\)\n\nThe correlation matrix \\(\\Psi\\) is based on the pairwise squared distances between the input locations\nHere we will use \\(n=8\\) sample locations\n\\(\\theta\\) is set to 1.0\n\n\nn = 8\nX = np.linspace(0, 2*np.pi, n, endpoint=False).reshape(-1,1)\n# theta should be an array (of one value, for the moment, will be changed later)\ntheta = np.array([1.0])\nPsi = build_Psi(X, theta)\n\n\nEvaluate at sample points\n\n\ny = np.sin(X)\n\n\nimport matplotlib.pyplot as plt\nplt.plot(X, y, \"bo\")\nplt.title(\"Sin(x) evaluated at {} points\".format(n))\nplt.show()"
  },
  {
    "objectID": "003_optimization_gp.html#computing-the-psi-vector",
    "href": "003_optimization_gp.html#computing-the-psi-vector",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "8.5 Computing the \\(\\psi\\) Vector",
    "text": "8.5 Computing the \\(\\psi\\) Vector\n\n8.5.1 Based on Distances Between Testing and Training Data Locations\n\nDistances between testing locations \\(x\\) and training data locations \\(X\\).\n\n\nfrom scipy.spatial.distance import cdist\n\ndef build_psi(X, x, theta, eps=sqrt(spacing(1))):\n    n = X.shape[0]\n    k = X.shape[1]\n    m = x.shape[0]\n    psi = zeros((n, m))\n    theta = theta * ones(k)\n    D = zeros((n, m))\n    D = cdist(x.reshape(-1, k),\n              X.reshape(-1, k),\n              metric='sqeuclidean',\n              out=None,\n              w=theta)\n    print(D.shape)\n    psi = exp(-D)\n    # return psi transpose to be consistent with the literature\n    return(psi.T)\n\n\nWe would like to predict at \\(m = 100\\) new locations:\n\n\nm = 100\nx = np.linspace(0, 2*np.pi, m, endpoint=False).reshape(-1,1)\npsi = build_psi(X, x, theta)\n\n(100, 8)"
  },
  {
    "objectID": "003_optimization_gp.html#predictive-equations",
    "href": "003_optimization_gp.html#predictive-equations",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "8.6 Predictive Equations",
    "text": "8.6 Predictive Equations\n\nU = cholesky(Psi).T\n\n\none = np.ones(n).reshape(-1,1)\nmu = (one.T.dot(solve(U, solve(U.T, y)))) / one.T.dot(solve(U, solve(U.T, one)))\n\n\nf = mu * ones(m).reshape(-1,1) + psi.T.dot(solve(U, solve(U.T, y - one * mu)))\n\n\nimport matplotlib.pyplot as plt\nplt.plot(x, f, color = \"orange\", label=\"Fitted\")\nplt.plot(x, np.sin(x), color = \"grey\", label=\"Original\")\nplt.plot(X, y, \"bo\", label=\"Measurements\")\nplt.title(\"Kriging prediction of sin(x) with {} points.\\n theta: {}\".format(n, theta[0]))\nplt.legend(loc='upper right')\nplt.show()"
  },
  {
    "objectID": "003_optimization_gp.html#number-of-sample-points",
    "href": "003_optimization_gp.html#number-of-sample-points",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "9.1 1 Number of Sample Points",
    "text": "9.1 1 Number of Sample Points\n\nThe example uses \\(n=8\\) sample points to fit the sin function.\n\nWhat happens, if less than 8 samples are available?"
  },
  {
    "objectID": "003_optimization_gp.html#modified-theta-values",
    "href": "003_optimization_gp.html#modified-theta-values",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "9.2 2 Modified \\(\\theta\\) values",
    "text": "9.2 2 Modified \\(\\theta\\) values\n\nThe example uses a \\(\\theta\\) value of \\(1.0\\).\n\nWhat happens if \\(\\theta\\) is modified?\nCan get better predictions with smaller or larger \\(\\theta\\) values?"
  },
  {
    "objectID": "003_optimization_gp.html#prediction-interval",
    "href": "003_optimization_gp.html#prediction-interval",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "9.3 3 Prediction Interval",
    "text": "9.3 3 Prediction Interval\n\nThe prediction interval was identical to the measurement interval, i.e., in the range from \\(0\\) to \\(2\\pi\\). This is referred to as “interpolation”.\n\nWhat happens if this interval is increased (which is referred to as “extrapolation”)?"
  },
  {
    "objectID": "003_optimization_gp.html#exercise-rbf",
    "href": "003_optimization_gp.html#exercise-rbf",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "9.4 Exercise RBF",
    "text": "9.4 Exercise RBF\n\n9.4.1 Package Loading\n\n%matplotlib inline\nimport numpy as np\nfrom numpy.matlib import eye\nimport scipy.linalg\nfrom numpy import linalg as LA\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.fun.objectivefunctions import analytical\nimport matplotlib.pyplot as plt\n\n\n\n9.4.2 Define a small number\n\neps = np.sqrt(np.spacing(1))\n\n\n\n9.4.3 The Sampling Plan (X)\n\nWe will use 256 points.\nThe first 10 points are shown below.\n\n\ngen = spacefilling(2)\nrng = np.random.RandomState(1)\nlower = np.array([-1,-1])\nupper = np.array([2,2])\nX = gen.scipy_lhd(256, lower=lower, upper = upper)\nX[1:10]\n\narray([[ 0.67319891, -0.11153561],\n       [ 0.4979386 , -0.10717298],\n       [-0.9991017 ,  1.66863389],\n       [-0.423669  , -0.97527218],\n       [-0.57241762,  1.77447307],\n       [ 1.34580967,  0.62640122],\n       [ 0.18662343,  0.18793039],\n       [ 1.7664757 ,  1.65743858],\n       [ 0.98282275,  0.42361525]])\n\n\n\n\n9.4.4 The Objective Function\n\nHere we use \\(\\sum_{i=1}^n (x_i-1)^2\\).\nf_map() is a helper function that maps \\(f\\) to the entries (points) in the matrix \\(X\\).\n\n\ndef f(x):\n    return np.sum((x-1.0)**2)\n\ndef f_map(x):\n    return np.array(list(map(f, x)))\n\n\ny = f_map(X)\ny[1:10]\n\narray([1.34231036, 1.47789766, 4.44347889, 5.9285336 , 3.07230572,\n       0.25916038, 1.32103849, 1.01971047, 0.33251443])\n\n\n\nAlternatively, we can use pre-defined functions from the pyspot package:\n\n\n# fun = analytical(sigma=0).fun_branin\n# fun = analytical(sigma=0).fun_sphere\n\n\nXX, YY = np.meshgrid(np.linspace(-1, 2, 128), np.linspace(-1, 2, 128))\nzz = np.array([f_map(np.array([xi, yi]).reshape(-1,2)) for xi, yi in zip(np.ravel(XX), np.ravel(YY))]).reshape(128,128)\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nco = ax.pcolormesh(XX, YY, zz, vmin=-1, vmax=1, cmap='RdBu_r')\n\n\n\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nco = ax.contourf(XX, YY, zz, levels=np.linspace(0,2, 10))\n\n\n\n\n\n\n9.4.5 The Gram Matrix\n\ndef build_Gram(X):\n        \"\"\"\n        Construction of the Gram matrix.\n        \"\"\"\n        n = X.shape[0]\n        G = np.zeros((n, n))\n        for i in range(n):\n            for j in range(i, n):\n                G[i, j] = np.linalg.norm(X[i] - X[j])\n        G = G + G.T    \n        return G\n\n\nG = build_Gram(X)\nnp.round(G,2)\n\narray([[0.  , 0.51, 0.57, ..., 0.99, 0.62, 1.39],\n       [0.51, 0.  , 0.18, ..., 0.91, 0.94, 1.41],\n       [0.57, 0.18, 0.  , ..., 0.75, 0.87, 1.26],\n       ...,\n       [0.99, 0.91, 0.75, ..., 0.  , 0.71, 0.52],\n       [0.62, 0.94, 0.87, ..., 0.71, 0.  , 0.91],\n       [1.39, 1.41, 1.26, ..., 0.52, 0.91, 0.  ]])\n\n\n\n\n9.4.6 The Radial Basis Functions\n\ndef basis_linear(r):\n    return r*r*r\n\n\ndef basis_gauss(r, sigma = 1e-1):\n    return np.exp(-r**2/sigma)\n\n\nWe select the Gaussian basis function for the following examples:\n\n\nbasis = basis_gauss\n\n\n\n9.4.7 The \\(\\Psi\\) Matrix\n\ndef build_Phi(G, basis, eps=np.sqrt(np.spacing(1))):\n    n = G.shape[0]\n    Phi = np.zeros((n,n))\n    for i in range(n):\n        for j in range(n):\n            Phi[i,j] = basis(G[i,j])\n    Phi = Phi +  np.multiply(np.mat(eye(n)), eps)\n    return Phi\n\n\nPhi = build_Phi(G, basis=basis)\nPhi[0:3,0:3]\n\nmatrix([[1.00000001, 0.07413611, 0.03828587],\n        [0.07413611, 1.00000001, 0.73539165],\n        [0.03828587, 0.73539165, 1.00000001]])\n\n\n\n\n9.4.8 Inverting \\(\\Psi\\) via Cholesky Factorization\n\nThere a two different implementations of the Cholesky factorization oin Python:\n\nnumpy’s linalg.cholesky() and\nscipy’s linalg.cholesky()\n\nWe will use numpy’s version.\n\n\ndef get_rbf_weights(Phi, y):\n    \"\"\" \n    Calculating the weights of the radial basis function surrogate.\n    Cholesky factorization used.\n    LU decomposition otherwise (not implemented yet).\n    \"\"\"\n    # U = scipy.linalg.cholesky(Phi, lower=True)\n    U = np.linalg.cholesky(Phi)\n    U = U.T\n    # w = U\\(U'\\ModelInfo.y)\n    w = np.linalg.solve(U, np.linalg.solve(U.T, y))\n    return w\n\n\nw = get_rbf_weights(Phi, y)\nw[0:3]\n\narray([-6.98432952,  3.06393352, -5.13738971])\n\n\n\n\n9.4.9 Predictions\n\n9.4.9.1 The Predictor\n\ndef pred_rbf(x, X, basis, w):\n    n = X.shape[0]\n    d = np.zeros((n))\n    phi = np.zeros((n))\n    for i in range(n):\n        d[i] = np.linalg.norm(x - X[i])\n    for i in range(n):\n        phi[i] = basis(d[i])\n    return w @ phi    \n\n\n\n9.4.9.2 Testing some Example Points\n\nx = X[0]\nx\n\narray([ 0.76153494, -0.61391197])\n\n\n\n\n9.4.9.3 The RBF Prediction \\(\\hat{f}\\)\n\npred_rbf(x=x, X=X, basis=basis, w=w)\n\n2.6615775203204706\n\n\n\n\n9.4.9.4 The Original (True) Value \\(f\\)\n\nf_map(np.array(x).reshape(1,-1))\n\narray([2.66157742])\n\n\n\n\n9.4.9.5 Visualizations\n\nXX, YY = np.meshgrid(np.linspace(-1, 2, 128), np.linspace(-1, 2, 128))\nzz = np.array([pred_rbf(x=np.array([xi, yi]), X=X, basis=basis,w=w) for xi, yi in zip(np.ravel(XX), np.ravel(YY))]).reshape(128,128)\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nco = ax.pcolormesh(XX, YY, zz, vmin=-1, vmax=1, cmap='RdBu_r')\n\n\n\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nco = ax.contourf(XX, YY, zz, levels=np.linspace(0,2, 5))\n\n\n\n\n\n\n9.4.9.6 Note\nThe original function \\(f\\) is cheaper than the surrogate \\(\\hat{f}\\) in this example, because we have chosen a simple analytical function as the ground truth. This is not the case in real-world settings.\n\n\n\n9.4.10 Cholesky Factorization\n\n9.4.10.0.1 \\(A = U^T U\\)\n\n\\(U\\) is an upper triangular matrix\n\n\ndef cholesky_U(A):\n    N = A.shape[0]\n    U = np.zeros((N,N))\n    for k in range(0,N):\n         # compute diagonal entry\n         U[k,k] = A[k,k]\n         for j in range(0,k):\n             U[k,k] = U[k,k] - U[j,k]*U[j,k]\n         U[k,k] = np.sqrt(U[k,k])\n         # compute remaining column\n         for i in range(k+1,N):\n             U[k,i] = A[k,i]\n             for j in range(0,k):\n                 U[k,i] = U[k,i] - U[j,i]*U[j,k]\n             U[k,i] = U[k,i] / U[k,k]\n    return U\n\n\n\n9.4.10.1 \\(A = L L^T\\)\n\\(L\\) is a lower triangular matrix\n\ndef cholesky_L(A):\n    N = A.shape[0]\n    L = np.zeros((N,N))\n    for k in range(0,N):\n         # compute diagonal entry\n         L[k,k] = A[k,k]\n         for j in range(0,k):\n             L[k,k] = L[k,k] - L[k,j]*L[k,j]\n         L[k,k] = np.sqrt(L[k,k])\n         # compute remaining column\n         for i in range(k+1,N):\n             L[i,k] = A[i,k]\n             for j in range(0,k):\n                 L[i,k] = L[i,k] - L[i,j]*L[k,j]\n             L[i,k] = L[i,k] / L[k,k]\n    return L\n\n\n\n9.4.10.2 Example\n\nA = np.array([[4, 2, 4, 4], [2, 10, 5, 2], [4, 5, 9, 6], [4, 2, 6, 9]])\nA\n\narray([[ 4,  2,  4,  4],\n       [ 2, 10,  5,  2],\n       [ 4,  5,  9,  6],\n       [ 4,  2,  6,  9]])\n\n\n\n\n9.4.10.3 Check: Is \\(A\\) positive definite?\n\nassert(np.all(np.linalg.eigvals(A) &gt; 0))\n\n\n\n9.4.10.4 \\(A = U^T U\\)\nPerform Cholesky Factorization\n\nU = cholesky_U(A)\nU\n\narray([[2., 1., 2., 2.],\n       [0., 3., 1., 0.],\n       [0., 0., 2., 1.],\n       [0., 0., 0., 2.]])\n\n\nTest Result\n\nU.T @ U\n\narray([[ 4.,  2.,  4.,  4.],\n       [ 2., 10.,  5.,  2.],\n       [ 4.,  5.,  9.,  6.],\n       [ 4.,  2.,  6.,  9.]])\n\n\n\n\n9.4.10.5 \\(A = L L^T\\)\n\nL = cholesky_L(A)\nL\n\narray([[2., 0., 0., 0.],\n       [1., 3., 0., 0.],\n       [2., 1., 2., 0.],\n       [2., 0., 1., 2.]])\n\n\nTest Result\n\nL @ L.T\n\narray([[ 4.,  2.,  4.,  4.],\n       [ 2., 10.,  5.,  2.],\n       [ 4.,  5.,  9.,  6.],\n       [ 4.,  2.,  6.,  9.]])"
  },
  {
    "objectID": "003_optimization_gp.html#exercises-1",
    "href": "003_optimization_gp.html#exercises-1",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "9.5 Exercises",
    "text": "9.5 Exercises\n\n9.5.1 Gaussian Basis Function\n\nPlot the Gaussian Basis Function basis_gauss in the range from -2 to 2 using matplotlib.pyplot\n\nHint: Check the matplotlib documentation for examples.\nGenerate a plot with several sigma values, e.g., 0.1, 1.0, and 10.\n\nWhat is the meaning of the sigma parameter: Can you explain its influence / effect on the model quality?\n\nIs the sigma value important?\n\n\n\n\n9.5.2 Linear Basis Function\n\nSelect the linear basis function?\nWhat errors occur?\nDo you have any ideas how to fix this error?"
  },
  {
    "objectID": "004_scipy_optimize_intro.html",
    "href": "004_scipy_optimize_intro.html",
    "title": "4  Introduction to scipy.optimize",
    "section": "",
    "text": "5 Unconstrained minimization of multivariate scalar functions\nThe minimize function provides a common interface to unconstrained and constrained minimization algorithms for multivariate scalar functions in scipy.optimize. To demonstrate the minimization function, consider the problem of minimizing the Rosenbrock function of N variables:\n[ f() = {i=1}^{N-1} 100 (x{i+1} - x_i2)2 + (1 - x_i)^2 ]\nThe minimum value of this function is 0, which is achieved when (x_i = 1).\nNote that the Rosenbrock function and its derivatives are included in scipy.optimize. The implementations shown in the following sections provide examples of how to define an objective function as well as its Jacobian and Hessian functions. Objective functions in scipy.optimize expect a numpy array as their first parameter, which is to be optimized and must return a float value. The exact calling signature must be f(x, *args), where x represents a numpy array, and args is a tuple of additional arguments supplied to the objective function."
  },
  {
    "objectID": "01_spot_intro.html#example-spot-and-the-sphere-function",
    "href": "01_spot_intro.html#example-spot-and-the-sphere-function",
    "title": "8  Introduction to spotPython",
    "section": "8.1 Example: Spot and the Sphere Function",
    "text": "8.1 Example: Spot and the Sphere Function\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom scipy.optimize import shgo\nfrom scipy.optimize import direct\nfrom scipy.optimize import differential_evolution\nimport matplotlib.pyplot as plt\n\n\n8.1.1 The Objective Function: Sphere\nThe spotPython package provides several classes of objective functions. We will use an analytical objective function, i.e., a function that can be described by a (closed) formula: \\[f(x) = x^2\\]\n\nfun = analytical().fun_sphere\n\nWe can apply the function fun to input values and plot the result:\n\nx = np.linspace(-1,1,100).reshape(-1,1)\ny = fun(x)\nplt.figure()\nplt.plot(x, y, \"k\")\nplt.show()\n\n\n\n\n\nspot_0 = spot.Spot(fun=fun,\n                   lower = np.array([-1]),\n                   upper = np.array([1]))\n\n\nspot_0.run()\n\nspotPython tuning: 1.2459257396367542e-08 [#######---] 73.33% \n\n\nspotPython tuning: 1.2459257396367542e-08 [########--] 80.00% \n\n\nspotPython tuning: 1.2459257396367542e-08 [#########-] 86.67% \n\n\nspotPython tuning: 1.2459257396367542e-08 [#########-] 93.33% \n\n\nspotPython tuning: 4.897545259852824e-10 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x16da603d0&gt;\n\n\n\nspot_0.print_results()\n\nmin y: 4.897545259852824e-10\nx0: 2.2130398233770724e-05\n\n\n[['x0', 2.2130398233770724e-05]]\n\n\n\nspot_0.plot_progress(log_y=True)\n\n\n\n\n\nspot_0.plot_model()"
  },
  {
    "objectID": "01_spot_intro.html#spot-parameters-fun_evals-init_size-and-show_models",
    "href": "01_spot_intro.html#spot-parameters-fun_evals-init_size-and-show_models",
    "title": "8  Introduction to spotPython",
    "section": "8.2 Spot Parameters: fun_evals, init_size and show_models",
    "text": "8.2 Spot Parameters: fun_evals, init_size and show_models\nWe will modify three parameters:\n\nThe number of function evaluations (fun_evals)\nThe size of the initial design (init_size)\nThe parameter show_models, which visualizes the search process for 1-dim functions.\n\nThe full list of the Spot parameters is shown in the Help System and in the notebook spot_doc.ipynb.\n\nspot_1 = spot.Spot(fun=fun,\n                   lower = np.array([-1]),\n                   upper = np.array([2]),\n                   fun_evals= 10,\n                   seed=123,\n                   show_models=True,\n                   design_control={\"init_size\": 9})\nspot_1.run()\n\n\n\n\n\n\n\nspotPython tuning: 3.648984784366253e-07 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x16da1c0d0&gt;"
  },
  {
    "objectID": "01_spot_intro.html#print-the-results",
    "href": "01_spot_intro.html#print-the-results",
    "title": "8  Introduction to spotPython",
    "section": "8.3 Print the Results",
    "text": "8.3 Print the Results\n\nspot_1.print_results()\n\nmin y: 3.648984784366253e-07\nx0: -0.0006040682729929005\n\n\n[['x0', -0.0006040682729929005]]"
  },
  {
    "objectID": "01_spot_intro.html#show-the-progress",
    "href": "01_spot_intro.html#show-the-progress",
    "title": "8  Introduction to spotPython",
    "section": "8.4 Show the Progress",
    "text": "8.4 Show the Progress\n\nspot_1.plot_progress()"
  },
  {
    "objectID": "01_spot_intro.html#sec-visualizing-tensorboard-01",
    "href": "01_spot_intro.html#sec-visualizing-tensorboard-01",
    "title": "8  Introduction to spotPython",
    "section": "8.5 Visualizing the Optimization and Hyperparameter Tuning Process with TensorBoard",
    "text": "8.5 Visualizing the Optimization and Hyperparameter Tuning Process with TensorBoard\nspotPython supports the visualization of the hyperparameter tuning process with TensorBoard. The following example shows how to use TensorBoard with spotPython.\nFirst, we define an “experiment name” to identify the hyperparameter tuning process. The experiment name is used to create a directory for the TensorBoard files.\n\nfrom spotPython.utils.file import get_experiment_name\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_spot_tensorboard_path\n\nPREFIX = \"01\"\nexperiment_name = get_experiment_name(prefix=PREFIX)\nprint(experiment_name)\n\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name))\n\n01_bartz09_2023-11-03_22-14-02\n\n\nSince the spot_tensorboard_path is defined, spotPython will log the optimization process in the TensorBoard files. The TensorBoard files are stored in the directory spot_tensorboard_path. We can pass the TensorBoard information to the Spot method via the fun_control dictionary.\n\nspot_tuner = spot.Spot(fun=fun,\n                   lower = np.array([-1]),\n                   upper = np.array([2]),\n                   fun_evals= 10,\n                   seed=123,\n                   show_models=False,\n                   design_control={\"init_size\": 5},\n                   fun_control=fun_control,)\nspot_tuner.run()\n\nspotPython tuning: 2.760068954719313e-05 [######----] 60.00% \n\n\nspotPython tuning: 7.588618329369276e-07 [#######---] 70.00% \n\n\nspotPython tuning: 7.546340185833067e-07 [########--] 80.00% \n\n\nspotPython tuning: 3.3653559447366466e-07 [#########-] 90.00% \n\n\nspotPython tuning: 7.948275967360275e-11 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2b97eb050&gt;\n\n\nNow we can start TensorBoard in the background. The TensorBoard process will read the TensorBoard files and visualize the hyperparameter tuning process. From the terminal, we can start TensorBoard with the following command:\ntensorboard --logdir=\"./runs\"\nlogdir is the directory where the TensorBoard files are stored. In our case, the TensorBoard files are stored in the directory ./runs.\nTensorBoard will start a web server on port 6006. We can access the TensorBoard web server with the following URL:\nhttp://localhost:6006/\nThe first TensorBoard visualization shows the objective function values plotted against the wall time. The wall time is the time that has passed since the start of the hyperparameter tuning process. The five initial design points are shown in the upper left region of the plot. The line visualizes the optimization process. \nThe second TensorBoard visualization shows the input values, i.e., \\(x_0\\), plotted against the wall time. \nThe third TensorBoard plot illustrates how spotPython can be used as a microscope for the internal mechanisms of the surrogate-based optimization process. Here, one important parameter, the learning rate \\(\\theta\\) of the Kriging surrogate is plotted against the number of optimization steps.\n\n\n\nTensorBoard visualization of the spotPython process."
  },
  {
    "objectID": "02_spot_multidim.html#example-spot-and-the-3-dim-sphere-function",
    "href": "02_spot_multidim.html#example-spot-and-the-3-dim-sphere-function",
    "title": "9  Multi-dimensional Functions",
    "section": "9.1 Example: Spot and the 3-dim Sphere Function",
    "text": "9.1 Example: Spot and the 3-dim Sphere Function\n\nimport numpy as np\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\n\n\n9.1.1 The Objective Function: 3-dim Sphere\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function, i.e., a function that can be described by a (closed) formula: \\[f(x) = \\sum_i^n x_i^2 \\]\nHere we will use \\(n=3\\).\n\n\nfun = analytical().fun_sphere\n\n\nThe size of the lower bound vector determines the problem dimension.\nHere we will use -1.0 * np.ones(3), i.e., a three-dim function.\nWe will use three different theta values (one for each dimension), i.e., we set\nsurrogate_control={\"n_theta\": 3}.\n\n\n\n\n\n\n\nTensorBoard\n\n\n\nSimilar to the one-dimensional case, which was introduced in Section Section 8.5, we can use TensorBoard to monitor the progress of the optimization. We will use the same code, only the prefix is different:\n\nfrom spotPython.utils.file import get_experiment_name\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_spot_tensorboard_path\n\nPREFIX = \"02\"\nexperiment_name = get_experiment_name(prefix=PREFIX)\nprint(experiment_name)\n\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name))\n\n02_bartz09_2023-11-03_22-14-13\n\n\n\n\n\nspot_3 = spot.Spot(fun=fun,\n                   lower = -1.0*np.ones(3),\n                   upper = np.ones(3),\n                   var_name=[\"Pressure\", \"Temp\", \"Lambda\"],\n                   show_progress=True,\n                   surrogate_control={\"n_theta\": 3},\n                   fun_control=fun_control,)\n\nspot_3.run()\n\nspotPython tuning: 0.03443367156190887 [#######---] 73.33% \n\n\nspotPython tuning: 0.031348911082058686 [########--] 80.00% \n\n\nspotPython tuning: 0.0009629115535977041 [#########-] 86.67% \n\n\nspotPython tuning: 8.600065786394651e-05 [#########-] 93.33% \n\n\nspotPython tuning: 5.9908343748136085e-05 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2b7029390&gt;\n\n\nNow we can start TensorBoard in the background with the following command:\ntensorboard --logdir=\"./runs\"\nWe can access the TensorBoard web server with the following URL:\nhttp://localhost:6006/\n\n\n9.1.2 Results\n\nspot_3.print_results()\n\nmin y: 5.9908343748136085e-05\nPressure: 0.005157864627379999\nTemp: 0.00195710957248863\nLambda: 0.005429042121316765\n\n\n[['Pressure', 0.005157864627379999],\n ['Temp', 0.00195710957248863],\n ['Lambda', 0.005429042121316765]]\n\n\n\nspot_3.plot_progress()\n\n\n\n\n\n\n9.1.3 A Contour Plot\n\nWe can select two dimensions, say \\(i=0\\) and \\(j=1\\), and generate a contour plot as follows.\n\nNote: We have specified identical min_z and max_z values to generate comparable plots!\n\n\n\nspot_3.plot_contour(i=0, j=1, min_z=0, max_z=2.25)\n\n\n\n\n\nIn a similar manner, we can plot dimension \\(i=0\\) and \\(j=2\\):\n\n\nspot_3.plot_contour(i=0, j=2, min_z=0, max_z=2.25)\n\n\n\n\n\nThe final combination is \\(i=1\\) and \\(j=2\\):\n\n\nspot_3.plot_contour(i=1, j=2, min_z=0, max_z=2.25)\n\n\n\n\n\nThe three plots look very similar, because the fun_sphere is symmetric.\nThis can also be seen from the variable importance:\n\n\nspot_3.print_importance()\n\nPressure:  100.0\nTemp:  99.78247670817808\nLambda:  94.72233826625329\n\n\n[['Pressure', 100.0],\n ['Temp', 99.78247670817808],\n ['Lambda', 94.72233826625329]]\n\n\n\n\n9.1.4 TensorBoard\n\n\n\nTensorBoard visualization of the spotPython process. Objective function values plotted against wall time.\n\n\nThe second TensorBoard visualization shows the input values, i.e., \\(x_0, \\ldots, x_2\\), plotted against the wall time. \nThe third TensorBoard plot illustrates how spotPython can be used as a microscope for the internal mechanisms of the surrogate-based optimization process. Here, one important parameter, the learning rate \\(\\theta\\) of the Kriging surrogate is plotted against the number of optimization steps.\n\n\n\nTensorBoard visualization of the spotPython surrogate model."
  },
  {
    "objectID": "02_spot_multidim.html#conclusion",
    "href": "02_spot_multidim.html#conclusion",
    "title": "9  Multi-dimensional Functions",
    "section": "9.2 Conclusion",
    "text": "9.2 Conclusion\nBased on this quick analysis, we can conclude that all three dimensions are equally important (as expected, because the analytical function is known)."
  },
  {
    "objectID": "02_spot_multidim.html#exercises",
    "href": "02_spot_multidim.html#exercises",
    "title": "9  Multi-dimensional Functions",
    "section": "9.3 Exercises",
    "text": "9.3 Exercises\n\nImportant:\n\nResults from these exercises should be added to this document, i.e., you should submit an updated version of this notebook.\nPlease combine your results using this notebook.\nOnly one notebook from each group!\nPresentation is based on this notebook. No addtional slides are required!\nspotPython version 0.16.11 (or greater) is required\n\n\n\n9.3.1 The Three Dimensional fun_cubed\n\nThe input dimension is 3. The search range is \\(-1 \\leq x \\leq 1\\) for all dimensions.\nGenerate contour plots\nCalculate the variable importance.\nDiscuss the variable importance:\n\nAre all variables equally important?\nIf not:\n\nWhich is the most important variable?\nWhich is the least important variable?\n\n\n\n\n\n9.3.2 The Ten Dimensional fun_wing_wt\n\nThe input dimension is 10. The search range is \\(0 \\leq x \\leq 1\\) for all dimensions.\nCalculate the variable importance.\nDiscuss the variable importance:\n\nAre all variables equally important?\nIf not:\n\nWhich is the most important variable?\nWhich is the least important variable?\n\nGenerate contour plots for the three most important variables. Do they confirm your selection?\n\n\n\n\n9.3.3 The Three Dimensional fun_runge\n\nThe input dimension is 3. The search range is \\(-5 \\leq x \\leq 5\\) for all dimensions.\nGenerate contour plots\nCalculate the variable importance.\nDiscuss the variable importance:\n\nAre all variables equally important?\nIf not:\n\nWhich is the most important variable?\nWhich is the least important variable?\n\n\n\n\n\n9.3.4 The Three Dimensional fun_linear\n\nThe input dimension is 3. The search range is \\(-5 \\leq x \\leq 5\\) for all dimensions.\nGenerate contour plots\nCalculate the variable importance.\nDiscuss the variable importance:\n\nAre all variables equally important?\nIf not:\n\nWhich is the most important variable?\nWhich is the least important variable?"
  },
  {
    "objectID": "03_spot_anisotropic.html#example-isotropic-spot-surrogate-and-the-2-dim-sphere-function",
    "href": "03_spot_anisotropic.html#example-isotropic-spot-surrogate-and-the-2-dim-sphere-function",
    "title": "7  Isotropic and Anisotropic Kriging",
    "section": "7.1 Example: Isotropic Spot Surrogate and the 2-dim Sphere Function",
    "text": "7.1 Example: Isotropic Spot Surrogate and the 2-dim Sphere Function\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\n\n\n7.1.1 The Objective Function: 2-dim Sphere\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function, i.e., a function that can be described by a (closed) formula: \\[f(x, y) = x^2 + y^2\\]\n\n\nfun = analytical().fun_sphere\nfun_control = {\"sigma\": 0,\n               \"seed\": 123}\n\n\nThe size of the lower bound vector determines the problem dimension.\nHere we will use np.array([-1, -1]), i.e., a two-dim function.\n\n\nspot_2 = spot.Spot(fun=fun,\n                   lower = np.array([-1, -1]),\n                   upper = np.array([1, 1]))\n\nspot_2.run()\n\nspotPython tuning: 1.8750731199649933e-05 [#######---] 73.33% \n\n\nspotPython tuning: 1.8750731199649933e-05 [########--] 80.00% \n\n\nspotPython tuning: 1.8750731199649933e-05 [#########-] 86.67% \n\n\nspotPython tuning: 1.8750731199649933e-05 [#########-] 93.33% \n\n\nspotPython tuning: 1.8750731199649933e-05 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x16d6d4d90&gt;\n\n\n\n\n7.1.2 Results\n\nspot_2.print_results()\n\nmin y: 1.8750731199649933e-05\nx0: 0.0015130475553084242\nx1: 0.0040572673433020325\n\n\n[['x0', 0.0015130475553084242], ['x1', 0.0040572673433020325]]\n\n\n\nspot_2.plot_progress(log_y=True)"
  },
  {
    "objectID": "03_spot_anisotropic.html#example-with-anisotropic-kriging",
    "href": "03_spot_anisotropic.html#example-with-anisotropic-kriging",
    "title": "7  Isotropic and Anisotropic Kriging",
    "section": "7.2 Example With Anisotropic Kriging",
    "text": "7.2 Example With Anisotropic Kriging\n\nThe default parameter setting of spotPython’s Kriging surrogate uses the same theta value for every dimension.\nThis is referred to as “using an isotropic kernel”.\nIf different theta values are used for each dimension, then an anisotropic kernel is used\nTo enable anisotropic models in spotPython, the number of theta values should be larger than one.\nWe can use surrogate_control={\"n_theta\": 2} to enable this behavior (2 is the problem dimension).\n\n\n\n\n\n\n\nTensorBoard\n\n\n\nSimilar to the one-dimensional case, which was introduced in Section Section 5.5, we can use TensorBoard to monitor the progress of the optimization. We will use the same code, only the prefix is different:\n\nfrom spotPython.utils.file import get_experiment_name\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_spot_tensorboard_path\n\nPREFIX = \"03\"\nexperiment_name = get_experiment_name(prefix=PREFIX)\nprint(experiment_name)\n\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name))\n\n03_bartz09_2023-11-03_22-14-28\n\n\n\n\n\nspot_2_anisotropic = spot.Spot(fun=fun,\n                   lower = np.array([-1, -1]),\n                   upper = np.array([1, 1]),\n                   surrogate_control={\"n_theta\": 2},\n                   fun_control=fun_control)\nspot_2_anisotropic.run()\n\nspotPython tuning: 1.7904944376943484e-05 [#######---] 73.33% \n\n\nspotPython tuning: 1.7904944376943484e-05 [########--] 80.00% \n\n\nspotPython tuning: 1.7904944376943484e-05 [#########-] 86.67% \n\n\nspotPython tuning: 1.7904944376943484e-05 [#########-] 93.33% \n\n\nspotPython tuning: 5.68261952864018e-06 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2b1564910&gt;\n\n\n\nThe search progress of the optimization with the anisotropic model can be visualized:\n\n\nspot_2_anisotropic.plot_progress(log_y=True)\n\n\n\n\n\nspot_2_anisotropic.print_results()\n\nmin y: 5.68261952864018e-06\nx0: -0.002137037687426695\nx1: -0.0010562620182313395\n\n\n[['x0', -0.002137037687426695], ['x1', -0.0010562620182313395]]\n\n\n\nspot_2_anisotropic.surrogate.plot()\n\n\n\n\n\n7.2.1 Taking a Look at the theta Values\n\n7.2.1.1 theta Values from the spot Model\n\nWe can check, whether one or several theta values were used.\nThe theta values from the surrogate can be printed as follows:\n\n\nspot_2_anisotropic.surrogate.theta\n\narray([0.16545225, 0.28999215])\n\n\n\nSince the surrogate from the isotropic setting was stored as spot_2, we can also take a look at the theta value from this model:\n\n\nspot_2.surrogate.theta\n\narray([0.26287446])\n\n\n\n\n7.2.1.2 TensorBoard\nNow we can start TensorBoard in the background with the following command:\ntensorboard --logdir=\"./runs\"\nWe can access the TensorBoard web server with the following URL:\nhttp://localhost:6006/\nThe TensorBoard plot illustrates how spotPython can be used as a microscope for the internal mechanisms of the surrogate-based optimization process. Here, one important parameter, the learning rate \\(\\theta\\) of the Kriging surrogate is plotted against the number of optimization steps.\n\n\n\nTensorBoard visualization of the spotPython surrogate model."
  },
  {
    "objectID": "03_spot_anisotropic.html#exercises",
    "href": "03_spot_anisotropic.html#exercises",
    "title": "7  Isotropic and Anisotropic Kriging",
    "section": "7.3 Exercises",
    "text": "7.3 Exercises\n\n7.3.1 fun_branin\n\nDescribe the function.\n\nThe input dimension is 2. The search range is \\(-5 \\leq x_1 \\leq 10\\) and \\(0 \\leq x_2 \\leq 15\\).\n\nCompare the results from spotPython run a) with isotropic and b) anisotropic surrogate models.\nModify the termination criterion: instead of the number of evaluations (which is specified via fun_evals), the time should be used as the termination criterion. This can be done as follows (max_time=1 specifies a run time of one minute):\n\n\nfun_evals=inf,\nmax_time=1,\n\n\n\n7.3.2 fun_sin_cos\n\nDescribe the function.\n\nThe input dimension is 2. The search range is \\(-2\\pi \\leq x_1 \\leq 2\\pi\\) and \\(-2\\pi \\leq x_2 \\leq 2\\pi\\).\n\nCompare the results from spotPython run a) with isotropic and b) anisotropic surrogate models.\nModify the termination criterion (max_time instead of fun_evals) as described for fun_branin.\n\n\n\n7.3.3 fun_runge\n\nDescribe the function.\n\nThe input dimension is 2. The search range is \\(-5 \\leq x_1 \\leq 5\\) and \\(-5 \\leq x_2 \\leq 5\\).\n\nCompare the results from spotPython run a) with isotropic and b) anisotropic surrogate models.\nModify the termination criterion (max_time instead of fun_evals) as described for fun_branin.\n\n\n\n7.3.4 fun_wingwt\n\nDescribe the function.\n\nThe input dimension is 10. The search ranges are between 0 and 1 (values are mapped internally to their natural bounds).\n\nCompare the results from spotPython run a) with isotropic and b) anisotropic surrogate models.\nModify the termination criterion (max_time instead of fun_evals) as described for fun_branin."
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html#example-branin-function-with-spotpythons-internal-kriging-surrogate",
    "href": "04_spot_sklearn_surrogate.html#example-branin-function-with-spotpythons-internal-kriging-surrogate",
    "title": "11  Using sklearn Surrogates in spotPython",
    "section": "11.1 Example: Branin Function with spotPython’s Internal Kriging Surrogate",
    "text": "11.1 Example: Branin Function with spotPython’s Internal Kriging Surrogate\n\n11.1.1 The Objective Function Branin\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function, i.e., a function that can be described by a (closed) formula.\nHere we will use the Branin function:\n  y = a * (x2 - b * x1**2 + c * x1 - r) ** 2 + s * (1 - t) * np.cos(x1) + s,\n  where values of a, b, c, r, s and t are: a = 1, b = 5.1 / (4*pi**2),\n  c = 5 / pi, r = 6, s = 10 and t = 1 / (8*pi).\nIt has three global minima:\n  f(x) = 0.397887 at (-pi, 12.275), (pi, 2.275), and (9.42478, 2.475).\n\n\nfrom spotPython.fun.objectivefunctions import analytical\nlower = np.array([-5,-0])\nupper = np.array([10,15])\n\n\nfun = analytical().fun_branin\n\n\n\n\n\n\n\nTensorBoard\n\n\n\nSimilar to the one-dimensional case, which was introduced in Section Section 8.5, we can use TensorBoard to monitor the progress of the optimization. We will use the same code, only the prefix is different:\n\nfrom spotPython.utils.file import get_experiment_name\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_spot_tensorboard_path\n\nPREFIX = \"04\"\nexperiment_name = get_experiment_name(prefix=PREFIX)\nprint(experiment_name)\n\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name))\n\n04_bartz09_2023-11-03_22-14-44\n\n\n\n\n\n\n11.1.2 Running the surrogate model based optimizer Spot:\n\nspot_2 = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = 20,\n                   max_time = inf,\n                   seed=123,\n                   design_control={\"init_size\": 10},\n                   fun_control=fun_control)\n\n\nspot_2.run()\n\nspotPython tuning: 3.447460568213552 [######----] 55.00% \n\n\nspotPython tuning: 3.447460568213552 [######----] 60.00% \n\n\nspotPython tuning: 3.0394923470341615 [######----] 65.00% \n\n\nspotPython tuning: 3.0394923470341615 [#######---] 70.00% \n\n\nspotPython tuning: 1.1632551812894665 [########--] 75.00% \n\n\nspotPython tuning: 0.612453922191154 [########--] 80.00% \n\n\nspotPython tuning: 0.4576355201245761 [########--] 85.00% \n\n\nspotPython tuning: 0.3983178342401956 [#########-] 90.00% \n\n\nspotPython tuning: 0.3983178342401956 [##########] 95.00% \n\n\nspotPython tuning: 0.3983178342401956 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2ba9285d0&gt;\n\n\n\n\n11.1.3 TensorBoard\nNow we can start TensorBoard in the background with the following command:\ntensorboard --logdir=\"./runs\"\nWe can access the TensorBoard web server with the following URL:\nhttp://localhost:6006/\nThe TensorBoard plot illustrates how spotPython can be used as a microscope for the internal mechanisms of the surrogate-based optimization process. Here, one important parameter, the learning rate \\(\\theta\\) of the Kriging surrogate is plotted against the number of optimization steps.\n\n\n\nTensorBoard visualization of the spotPython optimization process and the surrogate model.\n\n\n\n\n11.1.4 Print the Results\n\nspot_2.print_results()\n\nmin y: 0.3983178342401956\nx0: 3.135416996435963\nx1: 2.2955490975636685\n\n\n[['x0', 3.135416996435963], ['x1', 2.2955490975636685]]\n\n\n\n\n11.1.5 Show the Progress and the Surrogate\n\nspot_2.plot_progress(log_y=True)\n\n\n\n\n\nspot_2.surrogate.plot()"
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html#example-using-surrogates-from-scikit-learn",
    "href": "04_spot_sklearn_surrogate.html#example-using-surrogates-from-scikit-learn",
    "title": "11  Using sklearn Surrogates in spotPython",
    "section": "11.2 Example: Using Surrogates From scikit-learn",
    "text": "11.2 Example: Using Surrogates From scikit-learn\n\nDefault is the spotPython (i.e., the internal) kriging surrogate.\nIt can be called explicitely and passed to Spot.\n\n\nfrom spotPython.build.kriging import Kriging\nS_0 = Kriging(name='kriging', seed=123)\n\n\nAlternatively, models from scikit-learn can be selected, e.g., Gaussian Process, RBFs, Regression Trees, etc.\n\n\n# Needed for the sklearn surrogates:\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn import linear_model\nfrom sklearn import tree\nimport pandas as pd\n\n\nHere are some additional models that might be useful later:\n\n\nS_Tree = DecisionTreeRegressor(random_state=0)\nS_LM = linear_model.LinearRegression()\nS_Ridge = linear_model.Ridge()\nS_RF = RandomForestRegressor(max_depth=2, random_state=0)\n\n\n11.2.1 GaussianProcessRegressor as a Surrogate\n\nTo use a Gaussian Process model from sklearn, that is similar to spotPython’s Kriging, we can proceed as follows:\n\n\nkernel = 1 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2))\nS_GP = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)\n\n\nThe scikit-learn GP model S_GP is selected for Spot as follows:\nsurrogate = S_GP\nWe can check the kind of surogate model with the command isinstance:\n\n\nisinstance(S_GP, GaussianProcessRegressor)\n\nTrue\n\n\n\nisinstance(S_0, Kriging)\n\nTrue\n\n\n\nSimilar to the Spot run with the internal Kriging model, we can call the run with the scikit-learn surrogate:\n\n\nfun = analytical(seed=123).fun_branin\nspot_2_GP = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = 20,\n                   seed=123,\n                   design_control={\"init_size\": 10},\n                   surrogate = S_GP)\nspot_2_GP.run()\n\nspotPython tuning: 18.865102092040814 [######----] 55.00% \n\n\nspotPython tuning: 4.067063943633956 [######----] 60.00% \n\n\nspotPython tuning: 3.461921636551292 [######----] 65.00% \n\n\nspotPython tuning: 3.461921636551292 [#######---] 70.00% \n\n\nspotPython tuning: 1.3283243814960493 [########--] 75.00% \n\n\nspotPython tuning: 0.9549503108510411 [########--] 80.00% \n\n\nspotPython tuning: 0.9352250003678275 [########--] 85.00% \n\n\nspotPython tuning: 0.39960822331589974 [#########-] 90.00% \n\n\nspotPython tuning: 0.3981631812933486 [##########] 95.00% \n\n\nspotPython tuning: 0.3981631812933486 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2ca51ee10&gt;\n\n\n\nspot_2_GP.plot_progress()\n\n\n\n\n\nspot_2_GP.print_results()\n\nmin y: 0.3981631812933486\nx0: 3.1491652274330053\nx1: 2.2698186003445153\n\n\n[['x0', 3.1491652274330053], ['x1', 2.2698186003445153]]"
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html#example-one-dimensional-sphere-function-with-spotpythons-kriging",
    "href": "04_spot_sklearn_surrogate.html#example-one-dimensional-sphere-function-with-spotpythons-kriging",
    "title": "11  Using sklearn Surrogates in spotPython",
    "section": "11.3 Example: One-dimensional Sphere Function With spotPython’s Kriging",
    "text": "11.3 Example: One-dimensional Sphere Function With spotPython’s Kriging\n\nIn this example, we will use an one-dimensional function, which allows us to visualize the optimization process.\n\nshow_models= True is added to the argument list.\n\n\n\nfrom spotPython.fun.objectivefunctions import analytical\nlower = np.array([-1])\nupper = np.array([1])\nfun = analytical(seed=123).fun_sphere\n\n\nspot_1 = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = 10,\n                   max_time = inf,\n                   seed=123,\n                   show_models= True,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   design_control={\"init_size\": 3},)\nspot_1.run()\n\n\n\n\n\n\n\nspotPython tuning: 0.03475493366922229 [####------] 40.00% \n\n\n\n\n\nspotPython tuning: 0.03475493366922229 [#####-----] 50.00% \n\n\n\n\n\nspotPython tuning: 0.014642358641673271 [######----] 60.00% \n\n\n\n\n\nspotPython tuning: 0.00018032497380230452 [#######---] 70.00% \n\n\n\n\n\nspotPython tuning: 2.1786524623022742e-08 [########--] 80.00% \n\n\n\n\n\nspotPython tuning: 2.1786524623022742e-08 [#########-] 90.00% \n\n\n\n\n\nspotPython tuning: 2.1786524623022742e-08 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2ca785250&gt;\n\n\n\n11.3.1 Results\n\nspot_1.print_results()\n\nmin y: 2.1786524623022742e-08\nx0: -0.00014760259016366462\n\n\n[['x0', -0.00014760259016366462]]\n\n\n\nspot_1.plot_progress(log_y=True)\n\n\n\n\n\nThe method plot_model plots the final surrogate:\n\n\nspot_1.plot_model()"
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html#example-sklearn-model-gaussianprocess",
    "href": "04_spot_sklearn_surrogate.html#example-sklearn-model-gaussianprocess",
    "title": "11  Using sklearn Surrogates in spotPython",
    "section": "11.4 Example: Sklearn Model GaussianProcess",
    "text": "11.4 Example: Sklearn Model GaussianProcess\n\nThis example visualizes the search process on the GaussianProcessRegression surrogate from sklearn.\nTherefore surrogate = S_GP is added to the argument list.\n\n\nfun = analytical(seed=123).fun_sphere\nspot_1_GP = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = 10,\n                   max_time = inf,\n                   seed=123,\n                   show_models= True,\n                   design_control={\"init_size\": 3},\n                   surrogate = S_GP)\nspot_1_GP.run()\n\n\n\n\n\n\n\nspotPython tuning: 0.0049257617153734565 [####------] 40.00% \n\n\n\n\n\nspotPython tuning: 0.002612076484523571 [#####-----] 50.00% \n\n\n\n\n\nspotPython tuning: 5.912935436232656e-07 [######----] 60.00% \n\n\n\n\n\nspotPython tuning: 4.211659449449057e-08 [#######---] 70.00% \n\n\n\n\n\nspotPython tuning: 4.211659449449057e-08 [########--] 80.00% \n\n\n\n\n\nspotPython tuning: 1.6119389142446866e-09 [#########-] 90.00% \n\n\n\n\n\nspotPython tuning: 1.6119389142446866e-09 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2ca985e90&gt;\n\n\n\nspot_1_GP.print_results()\n\nmin y: 1.6119389142446866e-09\nx0: 4.0148959068009304e-05\n\n\n[['x0', 4.0148959068009304e-05]]\n\n\n\nspot_1_GP.plot_progress(log_y=True)\n\n\n\n\n\nspot_1_GP.plot_model()"
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html#exercises",
    "href": "04_spot_sklearn_surrogate.html#exercises",
    "title": "11  Using sklearn Surrogates in spotPython",
    "section": "11.5 Exercises",
    "text": "11.5 Exercises\n\n11.5.1 DecisionTreeRegressor\n\nDescribe the surrogate model.\nUse the surrogate as the model for optimization.\n\n\n\n11.5.2 RandomForestRegressor\n\nDescribe the surrogate model.\nUse the surrogate as the model for optimization.\n\n\n\n11.5.3 linear_model.LinearRegression\n\nDescribe the surrogate model.\nUse the surrogate as the model for optimization.\n\n\n\n11.5.4 linear_model.Ridge\n\nDescribe the surrogate model.\nUse the surrogate as the model for optimization."
  },
  {
    "objectID": "04_spot_sklearn_surrogate.html#exercise-2",
    "href": "04_spot_sklearn_surrogate.html#exercise-2",
    "title": "11  Using sklearn Surrogates in spotPython",
    "section": "11.6 Exercise 2",
    "text": "11.6 Exercise 2\n\nCompare the performance of the five different surrogates on both objective functions:\n\nspotPython’s internal Kriging\nDecisionTreeRegressor\nRandomForestRegressor\nlinear_model.LinearRegression\nlinear_model.Ridge"
  },
  {
    "objectID": "05_spot_sklearn_optimization.html#the-objective-function-branin",
    "href": "05_spot_sklearn_optimization.html#the-objective-function-branin",
    "title": "4  Sequential Parameter Optimization: Using scipy Optimizers",
    "section": "4.1 The Objective Function Branin",
    "text": "4.1 The Objective Function Branin\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function, i.e., a function that can be described by a (closed) formula.\nHere we will use the Branin function. The 2-dim Branin function is\n\\[y = a * (x2 - b * x1**2 + c * x1 - r) ** 2 + s * (1 - t) * cos(x1) + s,\\] where values of a, b, c, r, s and t are: \\(a = 1, b = 5.1 / (4*pi**2), c = 5 / pi, r = 6, s = 10\\) and \\(t = 1 / (8*pi)\\).\nIt has three global minima:\n\\(f(x) = 0.397887\\) at \\((-\\pi, 12.275)\\), \\((\\pi, 2.275)\\), and \\((9.42478, 2.475)\\).\nInput Domain: This function is usually evaluated on the square x1 in [-5, 10] x x2 in [0, 15].\n\n\nfrom spotPython.fun.objectivefunctions import analytical\nlower = np.array([-5,-0])\nupper = np.array([10,15])\n\n\nfun = analytical(seed=123).fun_branin"
  },
  {
    "objectID": "05_spot_sklearn_optimization.html#the-optimizer",
    "href": "05_spot_sklearn_optimization.html#the-optimizer",
    "title": "4  Sequential Parameter Optimization: Using scipy Optimizers",
    "section": "4.2 The Optimizer",
    "text": "4.2 The Optimizer\n\nDifferential Evalution from the scikit.optimize package, see https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution is the default optimizer for the search on the surrogate.\nOther optimiers that are available in spotPython:\n\ndual_annealing\ndirect\nshgo\nbasinhopping, see https://docs.scipy.org/doc/scipy/reference/optimize.html#global-optimization.\n\nThese can be selected as follows:\nsurrogate_control = \"model_optimizer\": differential_evolution\nWe will use differential_evolution.\nThe optimizer can use 1000 evaluations. This value will be passed to the differential_evolution method, which has the argument maxiter (int). It defines the maximum number of generations over which the entire differential evolution population is evolved, see https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution\n\n\n\n\n\n\n\nTensorBoard\n\n\n\nSimilar to the one-dimensional case, which was introduced in Section Section 8.5, we can use TensorBoard to monitor the progress of the optimization. We will use the same code, only the prefix is different:\n\nfrom spotPython.utils.file import get_experiment_name\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_spot_tensorboard_path\n\nPREFIX = \"05_DE_\"\nexperiment_name = get_experiment_name(prefix=PREFIX)\nprint(experiment_name)\n\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name))\n\n05_DE__bartz09_2023-11-03_22-16-53\n\n\n\n\n\nspot_de = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = 20,\n                   max_time = inf,\n                   seed=125,\n                   noise=False,\n                   show_models= False,\n                   design_control={\"init_size\": 10},\n                   surrogate_control={\"n_theta\": len(lower),\n                                      \"model_optimizer\": differential_evolution,\n                                      \"model_fun_evals\": 1000,\n                                      },\n                  fun_control=fun_control)\nspot_de.run()\n\nspotPython tuning: 5.213735995388665 [######----] 55.00% \n\n\nspotPython tuning: 5.213735995388665 [######----] 60.00% \n\n\nspotPython tuning: 2.5179173635657266 [######----] 65.00% \n\n\nspotPython tuning: 1.016872525620073 [#######---] 70.00% \n\n\nspotPython tuning: 0.4160579721446034 [########--] 75.00% \n\n\nspotPython tuning: 0.4096599475220657 [########--] 80.00% \n\n\nspotPython tuning: 0.4096599475220657 [########--] 85.00% \n\n\nspotPython tuning: 0.3999223417849329 [#########-] 90.00% \n\n\nspotPython tuning: 0.39969164980122684 [##########] 95.00% \n\n\nspotPython tuning: 0.39969164980122684 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2b6828ed0&gt;\n\n\n\n4.2.1 TensorBoard\nNow we can start TensorBoard in the background with the following command:\ntensorboard --logdir=\"./runs\"\nWe can access the TensorBoard web server with the following URL:\nhttp://localhost:6006/\nThe TensorBoard plot illustrates how spotPython can be used as a microscope for the internal mechanisms of the surrogate-based optimization process. Here, one important parameter, the learning rate \\(\\theta\\) of the Kriging surrogate is plotted against the number of optimization steps.\n\n\n\nTensorBoard visualization of the spotPython optimization process and the surrogate model."
  },
  {
    "objectID": "05_spot_sklearn_optimization.html#print-the-results",
    "href": "05_spot_sklearn_optimization.html#print-the-results",
    "title": "4  Sequential Parameter Optimization: Using scipy Optimizers",
    "section": "4.3 Print the Results",
    "text": "4.3 Print the Results\n\nspot_de.print_results()\n\nmin y: 0.39969164980122684\nx0: -3.158224446089584\nx1: 12.293182279400076\n\n\n[['x0', -3.158224446089584], ['x1', 12.293182279400076]]"
  },
  {
    "objectID": "05_spot_sklearn_optimization.html#show-the-progress",
    "href": "05_spot_sklearn_optimization.html#show-the-progress",
    "title": "4  Sequential Parameter Optimization: Using scipy Optimizers",
    "section": "4.4 Show the Progress",
    "text": "4.4 Show the Progress\n\nspot_de.plot_progress(log_y=True)\n\n\n\n\n\nspot_de.surrogate.plot()"
  },
  {
    "objectID": "05_spot_sklearn_optimization.html#exercises",
    "href": "05_spot_sklearn_optimization.html#exercises",
    "title": "4  Sequential Parameter Optimization: Using scipy Optimizers",
    "section": "4.5 Exercises",
    "text": "4.5 Exercises\n\n4.5.1 dual_annealing\n\nDescribe the optimization algorithm\nUse the algorithm as an optimizer on the surrogate\n\n\n\n4.5.2 direct\n\nDescribe the optimization algorithm\nUse the algorithm as an optimizer on the surrogate\n\n\n\n4.5.3 shgo\n\nDescribe the optimization algorithm\nUse the algorithm as an optimizer on the surrogate\n\n\n\n4.5.4 basinhopping\n\nDescribe the optimization algorithm\nUse the algorithm as an optimizer on the surrogate\n\n\n\n4.5.5 Performance Comparison\nCompare the performance and run time of the 5 different optimizers:\n* `differential_evolution`\n* `dual_annealing`\n*  `direct`\n* `shgo`\n* `basinhopping`.\nThe Branin function has three global minima:\n\n\\(f(x) = 0.397887\\) at\n\n\\((-\\pi, 12.275)\\),\n\\((\\pi, 2.275)\\), and\n\\((9.42478, 2.475)\\).\n\n\nWhich optima are found by the optimizers? Does the seed change this behavior?"
  },
  {
    "objectID": "06_spot_gaussian.html#gaussian-processes-regression-basic-introductory-scikit-learn-example",
    "href": "06_spot_gaussian.html#gaussian-processes-regression-basic-introductory-scikit-learn-example",
    "title": "10  Sequential Parameter Optimization: Gaussian Process Models",
    "section": "10.1 Gaussian Processes Regression: Basic Introductory scikit-learn Example",
    "text": "10.1 Gaussian Processes Regression: Basic Introductory scikit-learn Example\n\nThis is the example from scikit-learn: https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html\nAfter fitting our model, we see that the hyperparameters of the kernel have been optimized.\nNow, we will use our kernel to compute the mean prediction of the full dataset and plot the 95% confidence interval.\n\n\n10.1.1 Train and Test Data\n\nX = np.linspace(start=0, stop=10, num=1_000).reshape(-1, 1)\ny = np.squeeze(X * np.sin(X))\nrng = np.random.RandomState(1)\ntraining_indices = rng.choice(np.arange(y.size), size=6, replace=False)\nX_train, y_train = X[training_indices], y[training_indices]\n\n\n\n10.1.2 Building the Surrogate With Sklearn\n\nThe model building with sklearn consisits of three steps:\n\nInstantiating the model, then\nfitting the model (using fit), and\nmaking predictions (using predict)\n\n\n\nkernel = 1 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2))\ngaussian_process = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)\ngaussian_process.fit(X_train, y_train)\nmean_prediction, std_prediction = gaussian_process.predict(X, return_std=True)\n\n\n\n10.1.3 Plotting the SklearnModel\n\nplt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, mean_prediction, label=\"Mean prediction\")\nplt.fill_between(\n    X.ravel(),\n    mean_prediction - 1.96 * std_prediction,\n    mean_prediction + 1.96 * std_prediction,\n    alpha=0.5,\n    label=r\"95% confidence interval\",\n)\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"sk-learn Version: Gaussian process regression on noise-free dataset\")\n\n\n\n\n\n\n10.1.4 The spotPython Version\n\nThe spotPython version is very similar:\n\nInstantiating the model, then\nfitting the model and\nmaking predictions (using predict).\n\n\n\nS = Kriging(name='kriging',  seed=123, log_level=50, cod_type=\"norm\")\nS.fit(X_train, y_train)\nS_mean_prediction, S_std_prediction, S_ei = S.predict(X, return_val=\"all\")\n\n\nplt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, S_mean_prediction, label=\"Mean prediction\")\nplt.fill_between(\n    X.ravel(),\n    S_mean_prediction - 1.96 * S_std_prediction,\n    S_mean_prediction + 1.96 * S_std_prediction,\n    alpha=0.5,\n    label=r\"95% confidence interval\",\n)\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"spotPython Version: Gaussian process regression on noise-free dataset\")\n\n\n\n\n\n\n10.1.5 Visualizing the Differences Between the spotPython and the sklearn Model Fits\n\nplt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, S_mean_prediction, label=\"spotPython Mean prediction\")\nplt.plot(X, mean_prediction, label=\"Sklearn Mean Prediction\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Comparing Mean Predictions\")"
  },
  {
    "objectID": "06_spot_gaussian.html#exercises",
    "href": "06_spot_gaussian.html#exercises",
    "title": "10  Sequential Parameter Optimization: Gaussian Process Models",
    "section": "10.2 Exercises",
    "text": "10.2 Exercises\n\n10.2.1 Schonlau Example Function\n\nThe Schonlau Example Function is based on sample points only (there is no analytical function description available):\n\n\nX = np.linspace(start=0, stop=13, num=1_000).reshape(-1, 1)\nX_train = np.array([1., 2., 3., 4., 12.]).reshape(-1,1)\ny_train = np.array([0., -1.75, -2, -0.5, 5.])\n\n\nDescribe the function.\nCompare the two models that were build using the spotPython and the sklearn surrogate.\nNote: Since there is no analytical function available, you might be interested in adding some points and describe the effects.\n\n\n\n10.2.2 Forrester Example Function\n\nThe Forrester Example Function is defined as follows:\nf(x) = (6x- 2)^2 sin(12x-4) for x in [0,1].\nData points are generated as follows:\n\n\nX = np.linspace(start=-0.5, stop=1.5, num=1_000).reshape(-1, 1)\nX_train = np.array([0.0, 0.175, 0.225, 0.3, 0.35, 0.375, 0.5,1]).reshape(-1,1)\nfun = analytical().fun_forrester\nfun_control = {\"sigma\": 0.1,\n               \"seed\": 123}\ny = fun(X, fun_control=fun_control)\ny_train = fun(X_train, fun_control=fun_control)\n\n\nDescribe the function.\nCompare the two models that were build using the spotPython and the sklearn surrogate.\nNote: Modify the noise level (\"sigma\"), e.g., use a value of 0.2, and compare the two models.\n\n\nfun_control = {\"sigma\": 0.2}\n\n\n\n10.2.3 fun_runge Function (1-dim)\n\nThe Runge function is defined as follows:\nf(x) = 1/ (1 + sum(x_i))^2\nData points are generated as follows:\n\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_runge\nfun_control = {\"sigma\": 0.025,\n               \"seed\": 123}\nX_train = gen.scipy_lhd(10, lower=lower, upper = upper).reshape(-1,1)\ny_train = fun(X, fun_control=fun_control)\nX = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\ny = fun(X, fun_control=fun_control)\n\n\nDescribe the function.\nCompare the two models that were build using the spotPython and the sklearn surrogate.\nNote: Modify the noise level (\"sigma\"), e.g., use a value of 0.05, and compare the two models.\n\n\nfun_control = {\"sigma\": 0.5}\n\n\n\n10.2.4 fun_cubed (1-dim)\n\nThe Cubed function is defined as follows:\nnp.sum(X[i]** 3)\nData points are generated as follows:\n\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_cubed\nfun_control = {\"sigma\": 0.025,\n               \"seed\": 123}\nX_train = gen.scipy_lhd(10, lower=lower, upper = upper).reshape(-1,1)\ny_train = fun(X, fun_control=fun_control)\nX = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\ny = fun(X, fun_control=fun_control)\n\n\nDescribe the function.\nCompare the two models that were build using the spotPython and the sklearn surrogate.\nNote: Modify the noise level (\"sigma\"), e.g., use a value of 0.05, and compare the two models.\n\n\nfun_control = {\"sigma\": 0.05}\n\n\n\n10.2.5 The Effect of Noise\nHow does the behavior of the spotPython fit changes when the argument noise is set to True, i.e.,\nS = Kriging(name='kriging',  seed=123, n_theta=1, noise=True)\nis used?"
  },
  {
    "objectID": "07_spot_ei.html#example-spot-and-the-1-dim-sphere-function",
    "href": "07_spot_ei.html#example-spot-and-the-1-dim-sphere-function",
    "title": "12  Expected Improvement",
    "section": "12.1 Example: Spot and the 1-dim Sphere Function",
    "text": "12.1 Example: Spot and the 1-dim Sphere Function\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nimport matplotlib.pyplot as plt\n\n\n12.1.1 The Objective Function: 1-dim Sphere\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function, i.e., a function that can be described by a (closed) formula: \\[f(x) = x^2 \\]\n\n\nfun = analytical().fun_sphere\n\n\nfun = analytical().fun_sphere\n\n\nThe size of the lower bound vector determines the problem dimension.\nHere we will use np.array([-1]), i.e., a one-dim function.\n\n\n\n\n\n\n\nTensorBoard\n\n\n\nSimilar to the one-dimensional case, which was introduced in Section Section 8.5, we can use TensorBoard to monitor the progress of the optimization. We will use the same code, only the prefix is different:\n\nfrom spotPython.utils.file import get_experiment_name\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_spot_tensorboard_path\n\nPREFIX = \"07_Y\"\nexperiment_name = get_experiment_name(prefix=PREFIX)\nprint(experiment_name)\n\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    sigma=0,\n    seed=123,)\n\n07_Y_bartz09_2023-11-03_22-20-06\n\n\n\n\n\nspot_1 = spot.Spot(fun=fun,\n                   fun_evals = 25,\n                   lower = np.array([-1]),\n                   upper = np.array([1]),\n                   design_control={\"init_size\": 10},\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   fun_control = fun_control,)\n\nspot_1.run()\n\nspotPython tuning: 1.2459257396367542e-08 [####------] 44.00% \n\n\nspotPython tuning: 1.2459257396367542e-08 [#####-----] 48.00% \n\n\nspotPython tuning: 1.2459257396367542e-08 [#####-----] 52.00% \n\n\nspotPython tuning: 1.2459257396367542e-08 [######----] 56.00% \n\n\nspotPython tuning: 4.897545259852824e-10 [######----] 60.00% \n\n\nspotPython tuning: 4.897545259852824e-10 [######----] 64.00% \n\n\nspotPython tuning: 4.897545259852824e-10 [#######---] 68.00% \n\n\nspotPython tuning: 4.897545259852824e-10 [#######---] 72.00% \n\n\nspotPython tuning: 4.897545259852824e-10 [########--] 76.00% \n\n\nspotPython tuning: 4.897545259852824e-10 [########--] 80.00% \n\n\nspotPython tuning: 1.9335518024989866e-10 [########--] 84.00% \n\n\nspotPython tuning: 1.9335518024989866e-10 [#########-] 88.00% \n\n\nspotPython tuning: 1.9335518024989866e-10 [#########-] 92.00% \n\n\nspotPython tuning: 1.9335518024989866e-10 [##########] 96.00% \n\n\nspotPython tuning: 2.135607331180881e-12 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2b8cfa750&gt;\n\n\n\n\n12.1.2 Results\n\nspot_1.print_results()\n\nmin y: 2.135607331180881e-12\nx0: -1.4613717292943917e-06\n\n\n[['x0', -1.4613717292943917e-06]]\n\n\n\nspot_1.plot_progress(log_y=True)\n\n\n\n\n\n\n\nTensorBoard visualization of the spotPython optimization process and the surrogate model."
  },
  {
    "objectID": "07_spot_ei.html#same-but-with-ei-as-infill_criterion",
    "href": "07_spot_ei.html#same-but-with-ei-as-infill_criterion",
    "title": "12  Expected Improvement",
    "section": "12.2 Same, but with EI as infill_criterion",
    "text": "12.2 Same, but with EI as infill_criterion\n\nPREFIX = \"07_EI_ISO\"\nexperiment_name = get_experiment_name(prefix=PREFIX)\nprint(experiment_name)\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    sigma=0,\n    seed=123,)\n\n07_EI_ISO_bartz09_2023-11-03_22-20-29\n\n\n\nspot_1_ei = spot.Spot(fun=fun,\n                   lower = np.array([-1]),\n                   upper = np.array([1]),\n                   fun_evals = 25,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   infill_criterion = \"ei\",\n                   design_control={\"init_size\": 10},\n                   fun_control = fun_control,)\nspot_1_ei.run()\n\nspotPython tuning: 8.79000773789907e-08 [####------] 44.00% \n\n\nspotPython tuning: 2.6197300077861015e-08 [#####-----] 48.00% \n\n\nspotPython tuning: 2.6197300077861015e-08 [#####-----] 52.00% \n\n\nspotPython tuning: 2.6197300077861015e-08 [######----] 56.00% \n\n\nspotPython tuning: 2.1963022660037201e-10 [######----] 60.00% \n\n\nspotPython tuning: 2.1963022660037201e-10 [######----] 64.00% \n\n\nspotPython tuning: 2.1963022660037201e-10 [#######---] 68.00% \n\n\nspotPython tuning: 2.1963022660037201e-10 [#######---] 72.00% \n\n\nspotPython tuning: 2.1963022660037201e-10 [########--] 76.00% \n\n\nspotPython tuning: 2.1963022660037201e-10 [########--] 80.00% \n\n\nspotPython tuning: 2.1963022660037201e-10 [########--] 84.00% \n\n\nspotPython tuning: 2.1963022660037201e-10 [#########-] 88.00% \n\n\nspotPython tuning: 2.1963022660037201e-10 [#########-] 92.00% \n\n\nspotPython tuning: 2.1963022660037201e-10 [##########] 96.00% \n\n\nspotPython tuning: 2.1963022660037201e-10 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2b8eda690&gt;\n\n\n\nspot_1_ei.plot_progress(log_y=True)\n\n\n\n\n\nspot_1_ei.print_results()\n\nmin y: 2.1963022660037201e-10\nx0: 1.4819926673245452e-05\n\n\n[['x0', 1.4819926673245452e-05]]\n\n\n\n\n\nTensorBoard visualization of the spotPython optimization process and the surrogate model. Expected improvement, isotropic Kriging."
  },
  {
    "objectID": "07_spot_ei.html#non-isotropic-kriging",
    "href": "07_spot_ei.html#non-isotropic-kriging",
    "title": "12  Expected Improvement",
    "section": "12.3 Non-isotropic Kriging",
    "text": "12.3 Non-isotropic Kriging\n\nPREFIX = \"07_EI_NONISO\"\nexperiment_name = get_experiment_name(prefix=PREFIX)\nprint(experiment_name)\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    sigma=0,\n    seed=123,)\n\n07_EI_NONISO_bartz09_2023-11-03_22-20-47\n\n\n\nspot_2_ei_noniso = spot.Spot(fun=fun,\n                   lower = np.array([-1, -1]),\n                   upper = np.array([1, 1]),\n                   fun_evals = 25,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   infill_criterion = \"ei\",\n                   show_models=True,\n                   design_control={\"init_size\": 10},\n                   surrogate_control={\"noise\": False,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": 2,\n                                      \"model_fun_evals\": 1000,\n                                      },\n                    fun_control=fun_control,)\nspot_2_ei_noniso.run()\n\nspotPython tuning: 1.8247169797759505e-05 [####------] 44.00% \n\n\nspotPython tuning: 1.8247169797759505e-05 [#####-----] 48.00% \n\n\nspotPython tuning: 1.8247169797759505e-05 [#####-----] 52.00% \n\n\nspotPython tuning: 1.0281222147432436e-05 [######----] 56.00% \n\n\nspotPython tuning: 1.0281222147432436e-05 [######----] 60.00% \n\n\nspotPython tuning: 1.088759927339735e-07 [######----] 64.00% \n\n\nspotPython tuning: 1.088759927339735e-07 [#######---] 68.00% \n\n\nspotPython tuning: 1.088759927339735e-07 [#######---] 72.00% \n\n\nspotPython tuning: 1.088759927339735e-07 [########--] 76.00% \n\n\nspotPython tuning: 1.088759927339735e-07 [########--] 80.00% \n\n\nspotPython tuning: 1.088759927339735e-07 [########--] 84.00% \n\n\nspotPython tuning: 1.088759927339735e-07 [#########-] 88.00% \n\n\nspotPython tuning: 1.088759927339735e-07 [#########-] 92.00% \n\n\nspotPython tuning: 1.088759927339735e-07 [##########] 96.00% \n\n\nspotPython tuning: 1.088759927339735e-07 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2b9028b90&gt;\n\n\n\nspot_2_ei_noniso.plot_progress(log_y=True)\n\n\n\n\n\nspot_2_ei_noniso.print_results()\n\nmin y: 1.088759927339735e-07\nx0: -0.0002833471276146305\nx1: 0.00016908695398081962\n\n\n[['x0', -0.0002833471276146305], ['x1', 0.00016908695398081962]]\n\n\n\nspot_2_ei_noniso.surrogate.plot()\n\n\n\n\n\n\n\nTensorBoard visualization of the spotPython optimization process and the surrogate model. Expected improvement, isotropic Kriging."
  },
  {
    "objectID": "07_spot_ei.html#using-sklearn-surrogates",
    "href": "07_spot_ei.html#using-sklearn-surrogates",
    "title": "12  Expected Improvement",
    "section": "12.4 Using sklearn Surrogates",
    "text": "12.4 Using sklearn Surrogates\n\n12.4.1 The spot Loop\nThe spot loop consists of the following steps:\n\nInit: Build initial design \\(X\\)\nEvaluate initial design on real objective \\(f\\): \\(y = f(X)\\)\nBuild surrogate: \\(S = S(X,y)\\)\nOptimize on surrogate: \\(X_0 = \\text{optimize}(S)\\)\nEvaluate on real objective: \\(y_0 = f(X_0)\\)\nImpute (Infill) new points: \\(X = X \\cup X_0\\), \\(y = y \\cup y_0\\).\nGot 3.\n\nThe spot loop is implemented in R as follows:\n\n\n\nVisual representation of the model based search with SPOT. Taken from: Bartz-Beielstein, T., and Zaefferer, M. Hyperparameter tuning approaches. In Hyperparameter Tuning for Machine and Deep Learning with R - A Practical Guide, E. Bartz, T. Bartz-Beielstein, M. Zaefferer, and O. Mersmann, Eds. Springer, 2022, ch. 4, pp. 67–114.\n\n\n\n\n12.4.2 spot: The Initial Model\n\n12.4.2.1 Example: Modifying the initial design size\nThis is the “Example: Modifying the initial design size” from Chapter 4.5.1 in [bart21i].\n\nspot_ei = spot.Spot(fun=fun,\n               lower = np.array([-1,-1]),\n               upper= np.array([1,1]),\n               design_control={\"init_size\": 5})\nspot_ei.run()\n\nspotPython tuning: 0.13881986540743513 [####------] 40.00% \n\n\nspotPython tuning: 0.011157100173301121 [#####-----] 46.67% \n\n\nspotPython tuning: 0.0010077722891862157 [#####-----] 53.33% \n\n\nspotPython tuning: 0.0006326308401677749 [######----] 60.00% \n\n\nspotPython tuning: 0.0005880000745278913 [#######---] 66.67% \n\n\nspotPython tuning: 0.0005853974252148365 [#######---] 73.33% \n\n\nspotPython tuning: 0.0005615353015376504 [########--] 80.00% \n\n\nspotPython tuning: 0.0004470375728318479 [#########-] 86.67% \n\n\nspotPython tuning: 6.506371306758665e-05 [#########-] 93.33% \n\n\nspotPython tuning: 1.881581967484049e-05 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2b8ec1ed0&gt;\n\n\n\nspot_ei.plot_progress()\n\n\n\n\n\nnp.min(spot_1.y), np.min(spot_ei.y)\n\n(2.135607331180881e-12, 1.881581967484049e-05)\n\n\n\n\n\n12.4.3 Init: Build Initial Design\n\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nfrom spotPython.fun.objectivefunctions import analytical\ngen = spacefilling(2)\nrng = np.random.RandomState(1)\nlower = np.array([-5,-0])\nupper = np.array([10,15])\nfun = analytical().fun_branin\n\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\nprint(X)\ny = fun(X, fun_control=fun_control)\nprint(y)\n\n[[ 8.97647221 13.41926847]\n [ 0.66946019  1.22344228]\n [ 5.23614115 13.78185824]\n [ 5.6149825  11.5851384 ]\n [-1.72963184  1.66516096]\n [-4.26945568  7.1325531 ]\n [ 1.26363761 10.17935555]\n [ 2.88779942  8.05508969]\n [-3.39111089  4.15213772]\n [ 7.30131231  5.22275244]]\n[128.95676449  31.73474356 172.89678121 126.71295908  64.34349975\n  70.16178611  48.71407916  31.77322887  76.91788181  30.69410529]\n\n\n\nS = Kriging(name='kriging',  seed=123)\nS.fit(X, y)\nS.plot()\n\n\n\n\n\ngen = spacefilling(2, seed=123)\nX0 = gen.scipy_lhd(3)\ngen = spacefilling(2, seed=345)\nX1 = gen.scipy_lhd(3)\nX2 = gen.scipy_lhd(3)\ngen = spacefilling(2, seed=123)\nX3 = gen.scipy_lhd(3)\nX0, X1, X2, X3\n\n(array([[0.77254938, 0.31539299],\n        [0.59321338, 0.93854273],\n        [0.27469803, 0.3959685 ]]),\n array([[0.78373509, 0.86811887],\n        [0.06692621, 0.6058029 ],\n        [0.41374778, 0.00525456]]),\n array([[0.121357  , 0.69043832],\n        [0.41906219, 0.32838498],\n        [0.86742658, 0.52910374]]),\n array([[0.77254938, 0.31539299],\n        [0.59321338, 0.93854273],\n        [0.27469803, 0.3959685 ]]))\n\n\n\n\n12.4.4 Evaluate\n\n\n12.4.5 Build Surrogate\n\n\n12.4.6 A Simple Predictor\nThe code below shows how to use a simple model for prediction.\n\nAssume that only two (very costly) measurements are available:\n\nf(0) = 0.5\nf(2) = 2.5\n\nWe are interested in the value at \\(x_0 = 1\\), i.e., \\(f(x_0 = 1)\\), but cannot run an additional, third experiment.\n\n\nfrom sklearn import linear_model\nX = np.array([[0], [2]])\ny = np.array([0.5, 2.5])\nS_lm = linear_model.LinearRegression()\nS_lm = S_lm.fit(X, y)\nX0 = np.array([[1]])\ny0 = S_lm.predict(X0)\nprint(y0)\n\n[1.5]\n\n\n\nCentral Idea:\n\nEvaluation of the surrogate model S_lm is much cheaper (or / and much faster) than running the real-world experiment \\(f\\)."
  },
  {
    "objectID": "07_spot_ei.html#gaussian-processes-regression-basic-introductory-example",
    "href": "07_spot_ei.html#gaussian-processes-regression-basic-introductory-example",
    "title": "12  Expected Improvement",
    "section": "12.5 Gaussian Processes regression: basic introductory example",
    "text": "12.5 Gaussian Processes regression: basic introductory example\nThis example was taken from scikit-learn. After fitting our model, we see that the hyperparameters of the kernel have been optimized. Now, we will use our kernel to compute the mean prediction of the full dataset and plot the 95% confidence interval.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math as m\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF\n\nX = np.linspace(start=0, stop=10, num=1_000).reshape(-1, 1)\ny = np.squeeze(X * np.sin(X))\nrng = np.random.RandomState(1)\ntraining_indices = rng.choice(np.arange(y.size), size=6, replace=False)\nX_train, y_train = X[training_indices], y[training_indices]\n\nkernel = 1 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2))\ngaussian_process = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)\ngaussian_process.fit(X_train, y_train)\ngaussian_process.kernel_\n\nmean_prediction, std_prediction = gaussian_process.predict(X, return_std=True)\n\nplt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, mean_prediction, label=\"Mean prediction\")\nplt.fill_between(\n    X.ravel(),\n    mean_prediction - 1.96 * std_prediction,\n    mean_prediction + 1.96 * std_prediction,\n    alpha=0.5,\n    label=r\"95% confidence interval\",\n)\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"sk-learn Version: Gaussian process regression on noise-free dataset\")\n\n\n\n\n\nfrom spotPython.build.kriging import Kriging\nimport numpy as np\nimport matplotlib.pyplot as plt\nrng = np.random.RandomState(1)\nX = np.linspace(start=0, stop=10, num=1_000).reshape(-1, 1)\ny = np.squeeze(X * np.sin(X))\ntraining_indices = rng.choice(np.arange(y.size), size=6, replace=False)\nX_train, y_train = X[training_indices], y[training_indices]\n\n\nS = Kriging(name='kriging',  seed=123, log_level=50, cod_type=\"norm\")\nS.fit(X_train, y_train)\n\nmean_prediction, std_prediction, ei = S.predict(X, return_val=\"all\")\n\nstd_prediction\n\nplt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, mean_prediction, label=\"Mean prediction\")\nplt.fill_between(\n    X.ravel(),\n    mean_prediction - 1.96 * std_prediction,\n    mean_prediction + 1.96 * std_prediction,\n    alpha=0.5,\n    label=r\"95% confidence interval\",\n)\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"spotPython Version: Gaussian process regression on noise-free dataset\")"
  },
  {
    "objectID": "07_spot_ei.html#the-surrogate-using-scikit-learn-models",
    "href": "07_spot_ei.html#the-surrogate-using-scikit-learn-models",
    "title": "12  Expected Improvement",
    "section": "12.6 The Surrogate: Using scikit-learn models",
    "text": "12.6 The Surrogate: Using scikit-learn models\nDefault is the internal kriging surrogate.\n\nS_0 = Kriging(name='kriging', seed=123)\n\nModels from scikit-learn can be selected, e.g., Gaussian Process:\n\n# Needed for the sklearn surrogates:\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn import linear_model\nfrom sklearn import tree\nimport pandas as pd\n\n\nkernel = 1 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2))\nS_GP = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)\n\n\nand many more:\n\n\nS_Tree = DecisionTreeRegressor(random_state=0)\nS_LM = linear_model.LinearRegression()\nS_Ridge = linear_model.Ridge()\nS_RF = RandomForestRegressor(max_depth=2, random_state=0) \n\n\nThe scikit-learn GP model S_GP is selected.\n\n\nS = S_GP\n\n\nisinstance(S, GaussianProcessRegressor)\n\nTrue\n\n\n\nfrom spotPython.fun.objectivefunctions import analytical\nfun = analytical().fun_branin\nlower = np.array([-5,-0])\nupper = np.array([10,15])\ndesign_control={\"init_size\": 5}\nsurrogate_control={\n            \"infill_criterion\": None,\n            \"n_points\": 1,\n        }\nspot_GP = spot.Spot(fun=fun, lower = lower, upper= upper, surrogate=S, \n                    fun_evals = 15, noise = False, log_level = 50,\n                    design_control=design_control,\n                    surrogate_control=surrogate_control)\n\nspot_GP.run()\n\nspotPython tuning: 24.51465459019188 [####------] 40.00% \n\n\nspotPython tuning: 11.003078163486554 [#####-----] 46.67% \n\n\nspotPython tuning: 10.960665185123245 [#####-----] 53.33% \n\n\nspotPython tuning: 10.960665185123245 [######----] 60.00% \n\n\nspotPython tuning: 10.960665185123245 [#######---] 66.67% \n\n\nspotPython tuning: 4.0894841491438765 [#######---] 73.33% \n\n\nspotPython tuning: 1.4230377508791392 [########--] 80.00% \n\n\nspotPython tuning: 1.4230377508791392 [#########-] 86.67% \n\n\nspotPython tuning: 1.4230377508791392 [#########-] 93.33% \n\n\nspotPython tuning: 0.6989341031319167 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2b8ffb250&gt;\n\n\n\nspot_GP.y\n\narray([ 69.32459936, 152.38491454, 107.92560483,  24.51465459,\n        76.73500031,  86.304256  ,  11.00307816,  10.96066519,\n        16.06668258,  24.08432082,   4.08948415,   1.42303775,\n         1.47359526,  16.04703294,   0.6989341 ])\n\n\n\nspot_GP.plot_progress()\n\n\n\n\n\nspot_GP.print_results()\n\nmin y: 0.6989341031319167\nx0: 3.358292789592623\nx1: 2.3886120108545597\n\n\n[['x0', 3.358292789592623], ['x1', 2.3886120108545597]]"
  },
  {
    "objectID": "07_spot_ei.html#additional-examples",
    "href": "07_spot_ei.html#additional-examples",
    "title": "12  Expected Improvement",
    "section": "12.7 Additional Examples",
    "text": "12.7 Additional Examples\n\n# Needed for the sklearn surrogates:\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn import linear_model\nfrom sklearn import tree\nimport pandas as pd\n\n\nkernel = 1 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2))\nS_GP = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)\n\n\nfrom spotPython.build.kriging import Kriging\nimport numpy as np\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\n\nS_K = Kriging(name='kriging',\n              seed=123,\n              log_level=50,\n              infill_criterion = \"y\",\n              n_theta=1,\n              noise=False,\n              cod_type=\"norm\")\nfun = analytical().fun_sphere\nlower = np.array([-1,-1])\nupper = np.array([1,1])\n\ndesign_control={\"init_size\": 10}\nsurrogate_control={\n            \"n_points\": 1,\n        }\nspot_S_K = spot.Spot(fun=fun,\n                     lower = lower,\n                     upper= upper,\n                     surrogate=S_K,\n                     fun_evals = 25,\n                     noise = False,\n                     log_level = 50,\n                     design_control=design_control,\n                     surrogate_control=surrogate_control)\n\nspot_S_K.run()\n\nspotPython tuning: 2.1370719642847402e-05 [####------] 44.00% \n\n\nspotPython tuning: 2.1370719642847402e-05 [#####-----] 48.00% \n\n\nspotPython tuning: 2.1370719642847402e-05 [#####-----] 52.00% \n\n\nspotPython tuning: 2.1370719642847402e-05 [######----] 56.00% \n\n\nspotPython tuning: 2.1370719642847402e-05 [######----] 60.00% \n\n\nspotPython tuning: 1.2590483826517302e-05 [######----] 64.00% \n\n\nspotPython tuning: 3.930538349742746e-06 [#######---] 68.00% \n\n\nspotPython tuning: 3.3191760809461184e-06 [#######---] 72.00% \n\n\nspotPython tuning: 2.4684282727935e-06 [########--] 76.00% \n\n\nspotPython tuning: 1.8279736801432919e-06 [########--] 80.00% \n\n\nspotPython tuning: 1.809224307539433e-06 [########--] 84.00% \n\n\nspotPython tuning: 1.809224307539433e-06 [#########-] 88.00% \n\n\nspotPython tuning: 1.809224307539433e-06 [#########-] 92.00% \n\n\nspotPython tuning: 1.809224307539433e-06 [##########] 96.00% \n\n\nspotPython tuning: 1.809224307539433e-06 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2c0cef150&gt;\n\n\n\nspot_S_K.plot_progress(log_y=True)\n\n\n\n\n\nspot_S_K.surrogate.plot()\n\n\n\n\n\nspot_S_K.print_results()\n\nmin y: 1.809224307539433e-06\nx0: -0.001330101474082372\nx1: 0.0002001358942901893\n\n\n[['x0', -0.001330101474082372], ['x1', 0.0002001358942901893]]\n\n\n\n12.7.1 Optimize on Surrogate\n\n\n12.7.2 Evaluate on Real Objective\n\n\n12.7.3 Impute / Infill new Points"
  },
  {
    "objectID": "07_spot_ei.html#tests",
    "href": "07_spot_ei.html#tests",
    "title": "12  Expected Improvement",
    "section": "12.8 Tests",
    "text": "12.8 Tests\n\nimport numpy as np\nfrom spotPython.spot import spot\nfrom spotPython.fun.objectivefunctions import analytical\n\nfun_sphere = analytical().fun_sphere\nspot_1 = spot.Spot(\n    fun=fun_sphere,\n    lower=np.array([-1, -1]),\n    upper=np.array([1, 1]),\n    n_points = 2\n)\n\n# (S-2) Initial Design:\nspot_1.X = spot_1.design.scipy_lhd(\n    spot_1.design_control[\"init_size\"], lower=spot_1.lower, upper=spot_1.upper\n)\nprint(spot_1.X)\n\n# (S-3): Eval initial design:\nspot_1.y = spot_1.fun(spot_1.X)\nprint(spot_1.y)\n\nspot_1.surrogate.fit(spot_1.X, spot_1.y)\nX0 = spot_1.suggest_new_X()\nprint(X0)\nassert X0.size == spot_1.n_points * spot_1.k\n\n[[ 0.86352963  0.7892358 ]\n [-0.24407197 -0.83687436]\n [ 0.36481882  0.8375811 ]\n [ 0.415331    0.54468512]\n [-0.56395091 -0.77797854]\n [-0.90259409 -0.04899292]\n [-0.16484832  0.35724741]\n [ 0.05170659  0.07401196]\n [-0.78548145 -0.44638164]\n [ 0.64017497 -0.30363301]]\n[1.36857656 0.75992983 0.83463487 0.46918172 0.92329124 0.8170764\n 0.15480068 0.00815134 0.81623768 0.502017  ]\n[[0.00151305 0.00405727]\n [0.00151305 0.00405727]]"
  },
  {
    "objectID": "07_spot_ei.html#ei-the-famous-schonlau-example",
    "href": "07_spot_ei.html#ei-the-famous-schonlau-example",
    "title": "12  Expected Improvement",
    "section": "12.9 EI: The Famous Schonlau Example",
    "text": "12.9 EI: The Famous Schonlau Example\n\nX_train0 = np.array([1, 2, 3, 4, 12]).reshape(-1,1)\nX_train = np.linspace(start=0, stop=10, num=5).reshape(-1, 1)\n\n\nfrom spotPython.build.kriging import Kriging\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nX_train = np.array([1., 2., 3., 4., 12.]).reshape(-1,1)\ny_train = np.array([0., -1.75, -2, -0.5, 5.])\n\nS = Kriging(name='kriging',  seed=123, log_level=50, n_theta=1, noise=False, cod_type=\"norm\")\nS.fit(X_train, y_train)\n\nX = np.linspace(start=0, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, mean_prediction, label=\"Mean prediction\")\nif True:\n    plt.fill_between(\n        X.ravel(),\n        mean_prediction - 2 * std_prediction,\n        mean_prediction + 2 * std_prediction,\n        alpha=0.5,\n        label=r\"95% confidence interval\",\n    )\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Gaussian process regression on noise-free dataset\")\n\n\n\n\n\n#plt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\n# plt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, -ei, label=\"Expected Improvement\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Gaussian process regression on noise-free dataset\")\n\n\n\n\n\nS.log\n\n{'negLnLike': array([1.20788205]),\n 'theta': array([1.09275997]),\n 'p': [],\n 'Lambda': []}"
  },
  {
    "objectID": "07_spot_ei.html#ei-the-forrester-example",
    "href": "07_spot_ei.html#ei-the-forrester-example",
    "title": "12  Expected Improvement",
    "section": "12.10 EI: The Forrester Example",
    "text": "12.10 EI: The Forrester Example\n\nfrom spotPython.build.kriging import Kriging\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\n\n# exact x locations are unknown:\nX_train = np.array([0.0, 0.175, 0.225, 0.3, 0.35, 0.375, 0.5,1]).reshape(-1,1)\n\nfun = analytical().fun_forrester\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    sigma=1.0,\n    seed=123,)\ny_train = fun(X_train, fun_control=fun_control)\n\nS = Kriging(name='kriging',  seed=123, log_level=50, n_theta=1, noise=False, cod_type=\"norm\")\nS.fit(X_train, y_train)\n\nX = np.linspace(start=0, stop=1, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, mean_prediction, label=\"Mean prediction\")\nif True:\n    plt.fill_between(\n        X.ravel(),\n        mean_prediction - 2 * std_prediction,\n        mean_prediction + 2 * std_prediction,\n        alpha=0.5,\n        label=r\"95% confidence interval\",\n    )\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Gaussian process regression on noise-free dataset\")\n\n\n\n\n\n#plt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\n# plt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, -ei, label=\"Expected Improvement\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Gaussian process regression on noise-free dataset\")"
  },
  {
    "objectID": "07_spot_ei.html#noise",
    "href": "07_spot_ei.html#noise",
    "title": "12  Expected Improvement",
    "section": "12.11 Noise",
    "text": "12.11 Noise\n\nimport numpy as np\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nimport matplotlib.pyplot as plt\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_sphere\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    sigma=2.0,\n    seed=123,)\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\nprint(X)\ny = fun(X, fun_control=fun_control)\nprint(y)\ny.shape\nX_train = X.reshape(-1,1)\ny_train = y\n\nS = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=False)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\n#plt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\n#plt.plot(X, ei, label=\"Expected Improvement\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Sphere: Gaussian process regression on noisy dataset\")\n\n[[ 0.63529627]\n [-4.10764204]\n [-0.44071975]\n [ 9.63125638]\n [-8.3518118 ]\n [-3.62418901]\n [ 4.15331   ]\n [ 3.4468512 ]\n [ 6.36049088]\n [-7.77978539]]\n[-1.57464135 16.13714981  2.77008442 93.14904827 71.59322218 14.28895359\n 15.9770567  12.96468767 39.82265329 59.88028242]\n\n\n\n\n\n\nS.log\n\n{'negLnLike': array([25.26601608]),\n 'theta': array([-1.98024606]),\n 'p': [],\n 'Lambda': []}\n\n\n\nS = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=True)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\n#plt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\n#plt.plot(X, ei, label=\"Expected Improvement\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Sphere: Gaussian process regression with nugget on noisy dataset\")\n\n\n\n\n\nS.log\n\n{'negLnLike': array([21.82530943]),\n 'theta': array([-0.41935831]),\n 'p': [],\n 'Lambda': array([5.20850895e-05])}"
  },
  {
    "objectID": "07_spot_ei.html#cubic-function",
    "href": "07_spot_ei.html#cubic-function",
    "title": "12  Expected Improvement",
    "section": "12.12 Cubic Function",
    "text": "12.12 Cubic Function\n\nimport numpy as np\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nimport matplotlib.pyplot as plt\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_cubed\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    sigma=10.0,\n    seed=123,)\n\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\nprint(X)\ny = fun(X, fun_control=fun_control)\nprint(y)\ny.shape\nX_train = X.reshape(-1,1)\ny_train = y\n\nS = Kriging(name='kriging',  seed=123, log_level=50, n_theta=1, noise=False)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\n#plt.plot(X, ei, label=\"Expected Improvement\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Cubed: Gaussian process regression on noisy dataset\")\n\n[[ 0.63529627]\n [-4.10764204]\n [-0.44071975]\n [ 9.63125638]\n [-8.3518118 ]\n [-3.62418901]\n [ 4.15331   ]\n [ 3.4468512 ]\n [ 6.36049088]\n [-7.77978539]]\n[  -9.63480707  -72.98497325   12.7936499   895.34567477 -573.35961837\n  -41.83176425   65.27989461   46.37081417  254.1530734  -474.09587355]\n\n\n\n\n\n\nS = Kriging(name='kriging',  seed=123, log_level=0, n_theta=1, noise=True)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\n#plt.plot(X, ei, label=\"Expected Improvement\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Cubed: Gaussian process with nugget regression on noisy dataset\")\n\n\n\n\n\nimport numpy as np\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nimport matplotlib.pyplot as plt\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_runge\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    sigma=0.25,\n    seed=123,)\n\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\nprint(X)\ny = fun(X, fun_control=fun_control)\nprint(y)\ny.shape\nX_train = X.reshape(-1,1)\ny_train = y\n\nS = Kriging(name='kriging',  seed=123, log_level=50, n_theta=1, noise=False)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\n#plt.plot(X, ei, label=\"Expected Improvement\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Gaussian process regression on noisy dataset\")\n\n[[ 0.63529627]\n [-4.10764204]\n [-0.44071975]\n [ 9.63125638]\n [-8.3518118 ]\n [-3.62418901]\n [ 4.15331   ]\n [ 3.4468512 ]\n [ 6.36049088]\n [-7.77978539]]\n[0.712453   0.05595118 0.83735691 0.0106654  0.01413372 0.07074765\n 0.05479457 0.07763503 0.02412205 0.01625354]\n\n\n\n\n\n\nS = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=True)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\n#plt.plot(X, ei, label=\"Expected Improvement\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Gaussian process regression with nugget on noisy dataset\")"
  },
  {
    "objectID": "07_spot_ei.html#factors",
    "href": "07_spot_ei.html#factors",
    "title": "12  Expected Improvement",
    "section": "12.13 Factors",
    "text": "12.13 Factors\n\n[\"num\"] * 3\n\n['num', 'num', 'num']\n\n\n\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nfrom spotPython.fun.objectivefunctions import analytical\nimport numpy as np\n\n\ngen = spacefilling(2)\nn = 30\nrng = np.random.RandomState(1)\nlower = np.array([-5,-0])\nupper = np.array([10,15])\nfun = analytical().fun_branin_factor\n#fun = analytical(sigma=0).fun_sphere\n\nX0 = gen.scipy_lhd(n, lower=lower, upper = upper)\nX1 = np.random.randint(low=1, high=3, size=(n,))\nX = np.c_[X0, X1]\ny = fun(X)\nS = Kriging(name='kriging',  seed=123, log_level=50, n_theta=3, noise=False, var_type=[\"num\", \"num\", \"num\"])\nS.fit(X, y)\nSf = Kriging(name='kriging',  seed=123, log_level=50, n_theta=3, noise=False, var_type=[\"num\", \"num\", \"factor\"])\nSf.fit(X, y)\nn = 50\nX0 = gen.scipy_lhd(n, lower=lower, upper = upper)\nX1 = np.random.randint(low=1, high=3, size=(n,))\nX = np.c_[X0, X1]\ny = fun(X)\ns=np.sum(np.abs(S.predict(X)[0] - y))\nsf=np.sum(np.abs(Sf.predict(X)[0] - y))\nsf - s\n\n-40.513457642582125\n\n\n\n# vars(S)\n\n\n# vars(Sf)"
  },
  {
    "objectID": "08_spot_noisy.html#example-spot-and-the-noisy-sphere-function",
    "href": "08_spot_noisy.html#example-spot-and-the-noisy-sphere-function",
    "title": "13  Handling Noise",
    "section": "13.1 Example: Spot and the Noisy Sphere Function",
    "text": "13.1 Example: Spot and the Noisy Sphere Function\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nimport matplotlib.pyplot as plt\nfrom spotPython.utils.file import get_experiment_name\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_spot_tensorboard_path\n\nPREFIX = \"08\"\nexperiment_name = get_experiment_name(prefix=PREFIX)\nprint(experiment_name)\n\n08_bartz09_2023-11-04_15-48-53\n\n\n\n13.1.1 The Objective Function: Noisy Sphere\n\nThe spotPython package provides several classes of objective functions.\nWe will use an analytical objective function with noise, i.e., a function that can be described by a (closed) formula: \\[f(x) = x^2 + \\epsilon\\]\nSince sigma is set to 0.1, noise is added to the function:\n\n\nfun = analytical().fun_sphere\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    sigma=0.02,\n    seed=123,)\n\n\nA plot illustrates the noise:\n\n\nx = np.linspace(-1,1,100).reshape(-1,1)\ny = fun(x, fun_control=fun_control)\nplt.figure()\nplt.plot(x,y, \"k\")\nplt.show()\n\n\n\n\nSpot is adopted as follows to cope with noisy functions:\n\nfun_repeats is set to a value larger than 1 (here: 2)\nnoise is set to true. Therefore, a nugget (Lambda) term is added to the correlation matrix\ninit size (of the design_control dictionary) is set to a value larger than 1 (here: 2)\n\n\nspot_1_noisy = spot.Spot(fun=fun,\n                   lower = np.array([-1]),\n                   upper = np.array([1]),\n                   fun_evals = 20,\n                   fun_repeats = 2,\n                   noise = True,\n                   seed=123,\n                   show_models=True,\n                   design_control={\"init_size\": 3,\n                                   \"repeats\": 2},\n                   surrogate_control={\"noise\": True},\n                   fun_control=fun_control,)\n\n\nspot_1_noisy.run()\n\n\n\n\n\n\n\nspotPython tuning: 0.01497250376483504 [####------] 40.00% \n\n\n\n\n\nspotPython tuning: 0.014972272755587455 [#####-----] 50.00% \n\n\n\n\n\nspotPython tuning: 0.014966273462465166 [######----] 60.00% \n\n\n\n\n\nspotPython tuning: 0.01480994923420837 [#######---] 70.00% \n\n\n\n\n\nspotPython tuning: 0.011665893638594611 [########--] 80.00% \n\n\n\n\n\nspotPython tuning: -0.012922167154961792 [#########-] 90.00% \n\n\n\n\n\nspotPython tuning: -0.015064679263867698 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x103844910&gt;"
  },
  {
    "objectID": "08_spot_noisy.html#print-the-results",
    "href": "08_spot_noisy.html#print-the-results",
    "title": "13  Handling Noise",
    "section": "13.2 Print the Results",
    "text": "13.2 Print the Results\n\nspot_1_noisy.print_results()\n\nmin y: -0.015064679263867698\nx0: 0.0686858627600274\nmin mean y: -0.008851332275068022\nx0: 0.0686858627600274\n\n\n[['x0', 0.0686858627600274], ['x0', 0.0686858627600274]]\n\n\n\nspot_1_noisy.plot_progress(log_y=False,\n    filename=\"./figures/\" + experiment_name+\"_progress.png\")\n\n\n\n\nProgress plot. Black dots denote results from the initial design. Red dots illustrate the improvement found by the surrogate model based optimization."
  },
  {
    "objectID": "08_spot_noisy.html#noise-and-surrogates-the-nugget-effect",
    "href": "08_spot_noisy.html#noise-and-surrogates-the-nugget-effect",
    "title": "13  Handling Noise",
    "section": "13.3 Noise and Surrogates: The Nugget Effect",
    "text": "13.3 Noise and Surrogates: The Nugget Effect\n\n13.3.1 The Noisy Sphere\n\n13.3.1.1 The Data\n\nWe prepare some data first:\n\n\nimport numpy as np\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nimport matplotlib.pyplot as plt\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_sphere\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    sigma=2,\n    seed=123,)\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\ny = fun(X, fun_control=fun_control)\nX_train = X.reshape(-1,1)\ny_train = y\n\n\nA surrogate without nugget is fitted to these data:\n\n\nS = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=False)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Sphere: Gaussian process regression on noisy dataset\")\n\n\n\n\n\nIn comparison to the surrogate without nugget, we fit a surrogate with nugget to the data:\n\n\nS_nug = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=True)\nS_nug.fit(X_train, y_train)\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S_nug.predict(X_axis, return_val=\"all\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Sphere: Gaussian process regression with nugget on noisy dataset\")\n\n\n\n\n\nThe value of the nugget term can be extracted from the model as follows:\n\n\nS.Lambda\n\n\nS_nug.Lambda\n\n5.208508947162493e-05\n\n\n\nWe see:\n\nthe first model S has no nugget,\nwhereas the second model has a nugget value (Lambda) larger than zero."
  },
  {
    "objectID": "08_spot_noisy.html#exercises",
    "href": "08_spot_noisy.html#exercises",
    "title": "13  Handling Noise",
    "section": "13.4 Exercises",
    "text": "13.4 Exercises\n\n13.4.1 Noisy fun_cubed\n\nAnalyse the effect of noise on the fun_cubed function with the following settings:\n\n\nfun = analytical().fun_cubed\nfun_control = fun_control_init(\n    sigma=10,\n    seed=123,)\nlower = np.array([-10])\nupper = np.array([10])\n\n\n\n13.4.2 fun_runge\n\nAnalyse the effect of noise on the fun_runge function with the following settings:\n\n\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_runge\nfun_control = fun_control_init(\n    sigma=0.25,\n    seed=123,)\n\n\n\n13.4.3 fun_forrester\n\nAnalyse the effect of noise on the fun_forrester function with the following settings:\n\n\nlower = np.array([0])\nupper = np.array([1])\nfun = analytical().fun_forrester\nfun_control = fun_control_init(\n    sigma=5,\n    seed=123,)\n\n\n\n13.4.4 fun_xsin\n\nAnalyse the effect of noise on the fun_xsin function with the following settings:\n\n\nlower = np.array([-1.])\nupper = np.array([1.])\nfun = analytical().fun_xsin\nfun_control = fun_control_init(    \n    sigma=0.5,\n    seed=123,)"
  },
  {
    "objectID": "09_spot_ocba.html#example-spot-ocba-and-the-noisy-sphere-function",
    "href": "09_spot_ocba.html#example-spot-ocba-and-the-noisy-sphere-function",
    "title": "14  Optimal Computational Budget Allocation in Spot",
    "section": "14.1 Example: Spot, OCBA, and the Noisy Sphere Function",
    "text": "14.1 Example: Spot, OCBA, and the Noisy Sphere Function\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nimport matplotlib.pyplot as plt\nfrom spotPython.utils.file import get_experiment_name\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_spot_tensorboard_path\n\nPREFIX = \"09\"\nexperiment_name = get_experiment_name(prefix=PREFIX)\nprint(experiment_name)\n\n09_bartz09_2023-11-04_15-49-38\n\n\n\n14.1.1 The Objective Function: Noisy Sphere\nThe spotPython package provides several classes of objective functions. We will use an analytical objective function with noise, i.e., a function that can be described by a (closed) formula: \\[f(x) = x^2 + \\epsilon\\]\nSince sigma is set to 0.1, noise is added to the function:\n\nfun = analytical().fun_sphere\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    sigma=0.1,\n    seed=123,)\n\nA plot illustrates the noise:\n\nx = np.linspace(-1,1,100).reshape(-1,1)\ny = fun(x, fun_control=fun_control)\nplt.figure()\nplt.plot(x,y, \"k\")\nplt.show()\n\n\n\n\nSpot is adopted as follows to cope with noisy functions:\n\nfun_repeats is set to a value larger than 1 (here: 2)\nnoise is set to true. Therefore, a nugget (Lambda) term is added to the correlation matrix\ninit size (of the design_control dictionary) is set to a value larger than 1 (here: 2)\n\n\nspot_1_noisy = spot.Spot(fun=fun,\n                   lower = np.array([-1]),\n                   upper = np.array([1]),\n                   fun_evals = 20,\n                   fun_repeats = 2,\n                   infill_criterion=\"ei\",\n                   noise = True,\n                   tolerance_x=0.0,\n                   ocba_delta = 1,\n                   seed=123,\n                   show_models=True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": 3,\n                                   \"repeats\": 2},\n                   surrogate_control={\"noise\": True})\n\n\nspot_1_noisy.run()\n\n\n\n\n\n\n\nspotPython tuning: -0.0641572013655628 [####------] 45.00% \n\n\n\n\n\nspotPython tuning: -0.08106318979737473 [######----] 60.00% \n\n\n\n\n\nspotPython tuning: -0.08106318979737473 [########--] 75.00% \n\n\n\n\n\nspotPython tuning: -0.08106318979737473 [#########-] 90.00% \n\n\n\n\n\nspotPython tuning: -0.08106318979737473 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2b5d9f390&gt;"
  },
  {
    "objectID": "09_spot_ocba.html#print-the-results",
    "href": "09_spot_ocba.html#print-the-results",
    "title": "14  Optimal Computational Budget Allocation in Spot",
    "section": "14.2 Print the Results",
    "text": "14.2 Print the Results\n\nspot_1_noisy.print_results()\n\nmin y: -0.08106318979737473\nx0: 0.13359994475077583\nmin mean y: -0.03275683462209028\nx0: 0.13359994475077583\n\n\n[['x0', 0.13359994475077583], ['x0', 0.13359994475077583]]\n\n\n\nspot_1_noisy.plot_progress(log_y=False)"
  },
  {
    "objectID": "09_spot_ocba.html#noise-and-surrogates-the-nugget-effect",
    "href": "09_spot_ocba.html#noise-and-surrogates-the-nugget-effect",
    "title": "14  Optimal Computational Budget Allocation in Spot",
    "section": "14.3 Noise and Surrogates: The Nugget Effect",
    "text": "14.3 Noise and Surrogates: The Nugget Effect\n\n14.3.1 The Noisy Sphere\n\n14.3.1.1 The Data\nWe prepare some data first:\n\nimport numpy as np\nimport spotPython\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nimport matplotlib.pyplot as plt\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_sphere\nfun_control = fun_control_init(    \n    sigma=2,\n    seed=125)\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\ny = fun(X, fun_control=fun_control)\nX_train = X.reshape(-1,1)\ny_train = y\n\nA surrogate without nugget is fitted to these data:\n\nS = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=False)\nS.fit(X_train, y_train)\n\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S.predict(X_axis, return_val=\"all\")\n\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Sphere: Gaussian process regression on noisy dataset\")\n\n\n\n\nIn comparison to the surrogate without nugget, we fit a surrogate with nugget to the data:\n\nS_nug = Kriging(name='kriging',\n            seed=123,\n            log_level=50,\n            n_theta=1,\n            noise=True)\nS_nug.fit(X_train, y_train)\nX_axis = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\nmean_prediction, std_prediction, ei = S_nug.predict(X_axis, return_val=\"all\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X_axis, mean_prediction, label=\"mue\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Sphere: Gaussian process regression with nugget on noisy dataset\")\n\n\n\n\nThe value of the nugget term can be extracted from the model as follows:\n\nS.Lambda\n\n\nS_nug.Lambda\n\n9.088149959982792e-05\n\n\nWe see:\n\nthe first model S has no nugget,\nwhereas the second model has a nugget value (Lambda) larger than zero."
  },
  {
    "objectID": "09_spot_ocba.html#exercises",
    "href": "09_spot_ocba.html#exercises",
    "title": "14  Optimal Computational Budget Allocation in Spot",
    "section": "14.4 Exercises",
    "text": "14.4 Exercises\n\n14.4.1 Noisy fun_cubed\nAnalyse the effect of noise on the fun_cubed function with the following settings:\n\nfun = analytical().fun_cubed\nfun_control = fun_control_init(    \n    sigma=10,\n    seed=123)\nlower = np.array([-10])\nupper = np.array([10])\n\n\n\n14.4.2 fun_runge\nAnalyse the effect of noise on the fun_runge function with the following settings:\n\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_runge\nfun_control = fun_control_init(    \n    sigma=0.25,\n    seed=123)\n\n\n\n14.4.3 fun_forrester\nAnalyse the effect of noise on the fun_forrester function with the following settings:\n\nlower = np.array([0])\nupper = np.array([1])\nfun = analytical().fun_forrester\nfun_control = {\"sigma\": 5,\n               \"seed\": 123}\n\n\n\n14.4.4 fun_xsin\nAnalyse the effect of noise on the fun_xsin function with the following settings:\n\nlower = np.array([-1.])\nupper = np.array([1.])\nfun = analytical().fun_xsin\nfun_control = fun_control_init(    \n    sigma=0.5,\n    seed=123)"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#sec-setup-10",
    "href": "10_spot_hpt_sklearn_classification.html#sec-setup-10",
    "title": "14  HPT: sklearn SVC on Moons Data",
    "section": "14.1 Step 1: Setup",
    "text": "14.1 Step 1: Setup\nBefore we consider the detailed experimental setup, we select the parameters that affect run time, initial design size and the device that is used.\n\n\n\n\n\n\nCaution: Run time and initial design size should be increased for real experiments\n\n\n\n\nMAX_TIME is set to one minute for demonstration purposes. For real experiments, this should be increased to at least 1 hour.\nINIT_SIZE is set to 5 for demonstration purposes. For real experiments, this should be increased to at least 10.\n\n\n\n\nMAX_TIME = 1\nINIT_SIZE = 10\nPREFIX = \"10\""
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#step-2-initialization-of-the-empty-fun_control-dictionary",
    "href": "10_spot_hpt_sklearn_classification.html#step-2-initialization-of-the-empty-fun_control-dictionary",
    "title": "14  HPT: sklearn SVC on Moons Data",
    "section": "14.2 Step 2: Initialization of the Empty fun_control Dictionary",
    "text": "14.2 Step 2: Initialization of the Empty fun_control Dictionary\nThe fun_control dictionary is the central data structure that is used to control the optimization process. It is initialized as follows:\n\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_experiment_name, get_spot_tensorboard_path\nfrom spotPython.utils.device import getDevice\n\nexperiment_name = get_experiment_name(prefix=PREFIX)\n\nfun_control = fun_control_init(\n    task=\"classification\",\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    TENSORBOARD_CLEAN=True)"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#sec-data-loading-10",
    "href": "10_spot_hpt_sklearn_classification.html#sec-data-loading-10",
    "title": "14  HPT: sklearn SVC on Moons Data",
    "section": "14.3 Step 3: SKlearn Load Data (Classification)",
    "text": "14.3 Step 3: SKlearn Load Data (Classification)\nRandomly generate classification data.\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.datasets import make_moons, make_circles, make_classification\nn_features = 2\nn_samples = 500\ntarget_column = \"y\"\nds =  make_moons(n_samples, noise=0.5, random_state=0)\nX, y = ds\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.3, random_state=42\n)\ntrain = pd.DataFrame(np.hstack((X_train, y_train.reshape(-1, 1))))\ntest = pd.DataFrame(np.hstack((X_test, y_test.reshape(-1, 1))))\ntrain.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\ntest.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\ntrain.head()\n\n\n\n\n\n\n\n\nx1\nx2\ny\n\n\n\n\n0\n1.960101\n0.383172\n0.0\n\n\n1\n2.354420\n-0.536942\n1.0\n\n\n2\n1.682186\n-0.332108\n0.0\n\n\n3\n1.856507\n0.687220\n1.0\n\n\n4\n1.925524\n0.427413\n1.0\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\n\nx_min, x_max = X[:, 0].min() - 0.5, X[:, 0].max() + 0.5\ny_min, y_max = X[:, 1].min() - 0.5, X[:, 1].max() + 0.5\ncm = plt.cm.RdBu\ncm_bright = ListedColormap([\"#FF0000\", \"#0000FF\"])\nax = plt.subplot(1, 1, 1)\nax.set_title(\"Input data\")\n# Plot the training points\nax.scatter(X_train[:, 0], X_train[:, 1], c=y_train, cmap=cm_bright, edgecolors=\"k\")\n# Plot the testing points\nax.scatter(\n    X_test[:, 0], X_test[:, 1], c=y_test, cmap=cm_bright, alpha=0.6, edgecolors=\"k\"\n)\nax.set_xlim(x_min, x_max)\nax.set_ylim(y_min, y_max)\nax.set_xticks(())\nax.set_yticks(())\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nn_samples = len(train)\n# add the dataset to the fun_control\nfun_control.update({\"data\": None, # dataset,\n               \"train\": train,\n               \"test\": test,\n               \"n_samples\": n_samples,\n               \"target_column\": target_column})"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#sec-specification-of-preprocessing-model-10",
    "href": "10_spot_hpt_sklearn_classification.html#sec-specification-of-preprocessing-model-10",
    "title": "14  HPT: sklearn SVC on Moons Data",
    "section": "14.4 Step 4: Specification of the Preprocessing Model",
    "text": "14.4 Step 4: Specification of the Preprocessing Model\nData preprocesssing can be very simple, e.g., you can ignore it. Then you would choose the prep_model “None”:\n\nprep_model = None\nfun_control.update({\"prep_model\": prep_model})\n\nA default approach for numerical data is the StandardScaler (mean 0, variance 1). This can be selected as follows:\n\nfrom sklearn.preprocessing import StandardScaler\nprep_model = StandardScaler()\nfun_control.update({\"prep_model\": prep_model})\n\nEven more complicated pre-processing steps are possible, e.g., the follwing pipeline:\ncategorical_columns = []\none_hot_encoder = OneHotEncoder(handle_unknown=\"ignore\", sparse_output=False)\nprep_model = ColumnTransformer(\n         transformers=[\n             (\"categorical\", one_hot_encoder, categorical_columns),\n         ],\n         remainder=StandardScaler(),\n     )"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#step-5-select-model-algorithm-and-core_model_hyper_dict",
    "href": "10_spot_hpt_sklearn_classification.html#step-5-select-model-algorithm-and-core_model_hyper_dict",
    "title": "14  HPT: sklearn SVC on Moons Data",
    "section": "14.5 Step 5: Select Model (algorithm) and core_model_hyper_dict",
    "text": "14.5 Step 5: Select Model (algorithm) and core_model_hyper_dict\nThe selection of the algorithm (ML model) that should be tuned is done by specifying the its name from the sklearn implementation. For example, the SVC support vector machine classifier is selected as follows:\n\nfrom spotPython.hyperparameters.values import add_core_model_to_fun_control\nfrom spotPython.data.sklearn_hyper_dict import SklearnHyperDict\nfrom sklearn.svm import SVC\nadd_core_model_to_fun_control(core_model=SVC,\n                              fun_control=fun_control,\n                              hyper_dict=SklearnHyperDict,\n                              filename=None)\n\nNow fun_control has the information from the JSON file. The corresponding entries for the core_model class are shown below.\n\nfun_control['core_model_hyper_dict']\n\n{'C': {'type': 'float',\n  'default': 1.0,\n  'transform': 'None',\n  'lower': 0.1,\n  'upper': 10.0},\n 'kernel': {'levels': ['linear', 'poly', 'rbf', 'sigmoid'],\n  'type': 'factor',\n  'default': 'rbf',\n  'transform': 'None',\n  'core_model_parameter_type': 'str',\n  'lower': 0,\n  'upper': 3},\n 'degree': {'type': 'int',\n  'default': 3,\n  'transform': 'None',\n  'lower': 3,\n  'upper': 3},\n 'gamma': {'levels': ['scale', 'auto'],\n  'type': 'factor',\n  'default': 'scale',\n  'transform': 'None',\n  'core_model_parameter_type': 'str',\n  'lower': 0,\n  'upper': 1},\n 'coef0': {'type': 'float',\n  'default': 0.0,\n  'transform': 'None',\n  'lower': 0.0,\n  'upper': 0.0},\n 'shrinking': {'levels': [0, 1],\n  'type': 'factor',\n  'default': 0,\n  'transform': 'None',\n  'core_model_parameter_type': 'bool',\n  'lower': 0,\n  'upper': 1},\n 'probability': {'levels': [0, 1],\n  'type': 'factor',\n  'default': 0,\n  'transform': 'None',\n  'core_model_parameter_type': 'bool',\n  'lower': 0,\n  'upper': 1},\n 'tol': {'type': 'float',\n  'default': 0.001,\n  'transform': 'None',\n  'lower': 0.0001,\n  'upper': 0.01},\n 'cache_size': {'type': 'float',\n  'default': 200,\n  'transform': 'None',\n  'lower': 100,\n  'upper': 400},\n 'break_ties': {'levels': [0, 1],\n  'type': 'factor',\n  'default': 0,\n  'transform': 'None',\n  'core_model_parameter_type': 'bool',\n  'lower': 0,\n  'upper': 1}}\n\n\n\n\n\n\n\n\nsklearn Model Selection\n\n\n\nThe following sklearn models are supported by default:\n\nRidgeCV\nRandomForestClassifier\nSVC\nLogisticRegression\nKNeighborsClassifier\nGradientBoostingClassifier\nGradientBoostingRegressor\nElasticNet\n\nThey can be imported as follows:\nfrom sklearn.linear_model import RidgeCV\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.linear_model import ElasticNet"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#step-6-modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "href": "10_spot_hpt_sklearn_classification.html#step-6-modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "title": "14  HPT: sklearn SVC on Moons Data",
    "section": "14.6 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model",
    "text": "14.6 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\nspotPython provides functions for modifying the hyperparameters, their bounds and factors as well as for activating and de-activating hyperparameters without re-compilation of the Python source code. These functions were described in Section 23.6.\n\n14.6.1 Modify hyperparameter of type numeric and integer (boolean)\nNumeric and boolean values can be modified using the modify_hyper_parameter_bounds method.\n\n\n\n\n\n\nsklearn Model Hyperparameters\n\n\n\nThe hyperparameters of the sklearn SVC model are described in the sklearn documentation.\n\n\n\nFor example, to change the tol hyperparameter of the SVC model to the interval [1e-5, 1e-3], the following code can be used:\n\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_bounds\nmodify_hyper_parameter_bounds(fun_control, \"tol\", bounds=[1e-5, 1e-3])\nmodify_hyper_parameter_bounds(fun_control, \"probability\", bounds=[0, 0])\nfun_control[\"core_model_hyper_dict\"][\"tol\"]\n\n{'type': 'float',\n 'default': 0.001,\n 'transform': 'None',\n 'lower': 1e-05,\n 'upper': 0.001}\n\n\n\n\n14.6.2 Modify hyperparameter of type factor\nFactors can be modified with the modify_hyper_parameter_levels function. For example, to exclude the sigmoid kernel from the tuning, the kernel hyperparameter of the SVC model can be modified as follows:\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_levels\nmodify_hyper_parameter_levels(fun_control, \"kernel\", [\"poly\", \"rbf\"])\nfun_control[\"core_model_hyper_dict\"][\"kernel\"]\n\n{'levels': ['poly', 'rbf'],\n 'type': 'factor',\n 'default': 'rbf',\n 'transform': 'None',\n 'core_model_parameter_type': 'str',\n 'lower': 0,\n 'upper': 1}\n\n\n\n\n14.6.3 Optimizers\nOptimizers are described in Section 23.6.1."
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#step-7-selection-of-the-objective-loss-function",
    "href": "10_spot_hpt_sklearn_classification.html#step-7-selection-of-the-objective-loss-function",
    "title": "14  HPT: sklearn SVC on Moons Data",
    "section": "14.7 Step 7: Selection of the Objective (Loss) Function",
    "text": "14.7 Step 7: Selection of the Objective (Loss) Function\nThere are two metrics:\n\nmetric_river is used for the river based evaluation via eval_oml_iter_progressive.\nmetric_sklearn is used for the sklearn based evaluation.\n\n\nfrom sklearn.metrics import mean_absolute_error, accuracy_score, roc_curve, roc_auc_score, log_loss, mean_squared_error\nfun_control.update({\n               \"metric_sklearn\": log_loss,\n               \"weights\": 1.0,\n               })\n\n\n\n\n\n\n\nmetric_sklearn: Minimization and Maximization\n\n\n\n\nBecause the metric_sklearn is used for the sklearn based evaluation, it is important to know whether the metric should be minimized or maximized.\nThe weights parameter is used to indicate whether the metric should be minimized or maximized.\nIf weights is set to -1.0, the metric is maximized.\nIf weights is set to 1.0, the metric is minimized, e.g., weights = 1.0 for mean_absolute_error, or weights = -1.0 for roc_auc_score.\n\n\n\n\n14.7.1 Predict Classes or Class Probabilities\nIf the key \"predict_proba\" is set to True, the class probabilities are predicted. False is the default, i.e., the classes are predicted.\n\nfun_control.update({\n               \"predict_proba\": False,\n               })"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#step-8-calling-the-spot-function",
    "href": "10_spot_hpt_sklearn_classification.html#step-8-calling-the-spot-function",
    "title": "14  HPT: sklearn SVC on Moons Data",
    "section": "14.8 Step 8: Calling the SPOT Function",
    "text": "14.8 Step 8: Calling the SPOT Function\n\n14.8.1 Preparing the SPOT Call\nThe following code passes the information about the parameter ranges and bounds to spot.\n\n# extract the variable types, names, and bounds\nfrom spotPython.hyperparameters.values import (    \n    get_var_name,\n    get_var_type,\n    get_bound_values\n    )\nvar_type = get_var_type(fun_control)\nvar_name = get_var_name(fun_control)\nlower = get_bound_values(fun_control, \"lower\")\nupper = get_bound_values(fun_control, \"upper\")\n\n\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control))\n\n| name        | type   | default   |   lower |   upper | transform   |\n|-------------|--------|-----------|---------|---------|-------------|\n| C           | float  | 1.0       |   0.1   |  10     | None        |\n| kernel      | factor | rbf       |   0     |   1     | None        |\n| degree      | int    | 3         |   3     |   3     | None        |\n| gamma       | factor | scale     |   0     |   1     | None        |\n| coef0       | float  | 0.0       |   0     |   0     | None        |\n| shrinking   | factor | 0         |   0     |   1     | None        |\n| probability | factor | 0         |   0     |   0     | None        |\n| tol         | float  | 0.001     |   1e-05 |   0.001 | None        |\n| cache_size  | float  | 200.0     | 100     | 400     | None        |\n| break_ties  | factor | 0         |   0     |   1     | None        |\n\n\n\n\n14.8.2 The Objective Function\nThe objective function is selected next. It implements an interface from sklearn’s training, validation, and testing methods to spotPython.\n\nfrom spotPython.fun.hypersklearn import HyperSklearn\nfun = HyperSklearn().fun_sklearn\n\n\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\n# X_start = get_default_hyperparameters_as_array(fun_control)\n\n\n\n14.8.3 Run the Spot Optimizer\n\nRun SPOT for approx. x mins (max_time).\nNote: the run takes longer, because the evaluation time of initial design (here: initi_size, 20 points) is not considered.\n\n\n\n14.8.4 Starting the Hyperparameter Tuning\n\nimport numpy as np\nfrom spotPython.spot import spot\nfrom math import inf\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   fun_repeats = 1,\n                   max_time = MAX_TIME,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   infill_criterion = \"y\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models= False,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": True,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_fun_evals\": 10_000,\n                                      \"log_level\": 50\n                                      })\nspot_tuner.run()\n\nspotPython tuning: 5.734217584632275 [----------] 1.84% \n\n\nspotPython tuning: 5.734217584632275 [----------] 4.15% \n\n\nspotPython tuning: 5.734217584632275 [#---------] 7.17% \n\n\nspotPython tuning: 5.734217584632275 [#---------] 10.11% \n\n\nspotPython tuning: 5.734217584632275 [#---------] 12.52% \n\n\nspotPython tuning: 5.734217584632275 [#---------] 14.97% \n\n\nspotPython tuning: 5.734217584632275 [##--------] 16.99% \n\n\nspotPython tuning: 5.734217584632275 [#####-----] 51.13% \n\n\nspotPython tuning: 5.734217584632275 [#########-] 90.78% \n\n\nspotPython tuning: 5.734217584632275 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2be46ff10&gt;"
  },
  {
    "objectID": "10_spot_hpt_sklearn_classification.html#sec-results-tuning-10",
    "href": "10_spot_hpt_sklearn_classification.html#sec-results-tuning-10",
    "title": "14  HPT: sklearn SVC on Moons Data",
    "section": "14.9 Step 9: Results",
    "text": "14.9 Step 9: Results\n\nfrom spotPython.utils.file import save_pickle\nsave_pickle(spot_tuner, experiment_name)\n\n\nfrom spotPython.utils.file import load_pickle\nspot_tuner = load_pickle(experiment_name)\n\n\nShow the Progress of the hyperparameter tuning:\n\nAfter the hyperparameter tuning run is finished, the progress of the hyperparameter tuning can be visualized.\n\nspot_tuner.plot_progress(log_y=False,\n    filename=\"./figures/\" + experiment_name+\"_progress.png\")\n\n\n\n\nProgress plot. Black dots denote results from the initial design. Red dots illustrate the improvement found by the surrogate model based optimization.\n\n\n\n\n\nPrint the results\n\n\nprint(gen_design_table(fun_control=fun_control,\n    spot=spot_tuner))\n\n| name        | type   | default   |   lower |   upper |                tuned | transform   |   importance | stars   |\n|-------------|--------|-----------|---------|---------|----------------------|-------------|--------------|---------|\n| C           | float  | 1.0       |     0.1 |    10.0 |    2.394471655384338 | None        |         0.41 | .       |\n| kernel      | factor | rbf       |     0.0 |     1.0 |                  1.0 | None        |       100.00 | ***     |\n| degree      | int    | 3         |     3.0 |     3.0 |                  3.0 | None        |         0.00 |         |\n| gamma       | factor | scale     |     0.0 |     1.0 |                  0.0 | None        |         0.00 |         |\n| coef0       | float  | 0.0       |     0.0 |     0.0 |                  0.0 | None        |         0.00 |         |\n| shrinking   | factor | 0         |     0.0 |     1.0 |                  0.0 | None        |         0.00 |         |\n| probability | factor | 0         |     0.0 |     0.0 |                  0.0 | None        |         0.00 |         |\n| tol         | float  | 0.001     |   1e-05 |   0.001 | 0.000982585315792582 | None        |         0.00 |         |\n| cache_size  | float  | 200.0     |   100.0 |   400.0 |    375.6371648003268 | None        |         0.00 |         |\n| break_ties  | factor | 0         |     0.0 |     1.0 |                  0.0 | None        |         0.00 |         |\n\n\n\n14.9.1 Show variable importance\n\nspot_tuner.plot_importance(threshold=0.025, filename=\"./figures/\" + experiment_name+\"_importance.png\")\n\n\n\n\nVariable importance plot, threshold 0.025.\n\n\n\n\n\n\n14.9.2 Get Default Hyperparameters\n\nfrom spotPython.hyperparameters.values import get_default_values, transform_hyper_parameter_values\nvalues_default = get_default_values(fun_control)\nvalues_default = transform_hyper_parameter_values(fun_control=fun_control, hyper_parameter_values=values_default)\nvalues_default\n\n{'C': 1.0,\n 'kernel': 'rbf',\n 'degree': 3,\n 'gamma': 'scale',\n 'coef0': 0.0,\n 'shrinking': 0,\n 'probability': 0,\n 'tol': 0.001,\n 'cache_size': 200.0,\n 'break_ties': 0}\n\n\n\nfrom sklearn.pipeline import make_pipeline\nmodel_default = make_pipeline(fun_control[\"prep_model\"], fun_control[\"core_model\"](**values_default))\nmodel_default\n\nPipeline(steps=[('standardscaler', StandardScaler()),\n                ('svc',\n                 SVC(break_ties=0, cache_size=200.0, probability=0,\n                     shrinking=0))])In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.PipelinePipeline(steps=[('standardscaler', StandardScaler()),\n                ('svc',\n                 SVC(break_ties=0, cache_size=200.0, probability=0,\n                     shrinking=0))])StandardScalerStandardScaler()SVCSVC(break_ties=0, cache_size=200.0, probability=0, shrinking=0)\n\n\n\n\n14.9.3 Get SPOT Results\n\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nprint(X)\n\n[[2.39447166e+00 1.00000000e+00 3.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 9.82585316e-04\n  3.75637165e+02 0.00000000e+00]]\n\n\n\nfrom spotPython.hyperparameters.values import assign_values, return_conf_list_from_var_dict\nv_dict = assign_values(X, fun_control[\"var_name\"])\nreturn_conf_list_from_var_dict(var_dict=v_dict, fun_control=fun_control)\n\n[{'C': 2.394471655384338,\n  'kernel': 'rbf',\n  'degree': 3,\n  'gamma': 'scale',\n  'coef0': 0.0,\n  'shrinking': 0,\n  'probability': 0,\n  'tol': 0.000982585315792582,\n  'cache_size': 375.6371648003268,\n  'break_ties': 0}]\n\n\n\nfrom spotPython.hyperparameters.values import get_one_sklearn_model_from_X\nmodel_spot = get_one_sklearn_model_from_X(X, fun_control)\nmodel_spot\n\nPipeline(steps=[('standardscaler', StandardScaler()),\n                ('svc',\n                 SVC(C=2.394471655384338, break_ties=0,\n                     cache_size=375.6371648003268, probability=0, shrinking=0,\n                     tol=0.000982585315792582))])In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.PipelinePipeline(steps=[('standardscaler', StandardScaler()),\n                ('svc',\n                 SVC(C=2.394471655384338, break_ties=0,\n                     cache_size=375.6371648003268, probability=0, shrinking=0,\n                     tol=0.000982585315792582))])StandardScalerStandardScaler()SVCSVC(C=2.394471655384338, break_ties=0, cache_size=375.6371648003268,\n    probability=0, shrinking=0, tol=0.000982585315792582)\n\n\n\n\n14.9.4 Plot: Compare Predictions\n\nfrom spotPython.plot.validation import plot_roc\nplot_roc(model_list=[model_default, model_spot], fun_control= fun_control, model_names=[\"Default\", \"Spot\"])\n\n\n\n\n\nfrom spotPython.plot.validation import plot_confusion_matrix\nplot_confusion_matrix(model=model_default, fun_control=fun_control, title = \"Default\")\n\n\n\n\n\nplot_confusion_matrix(model=model_spot, fun_control=fun_control, title=\"SPOT\")\n\n\n\n\n\nmin(spot_tuner.y), max(spot_tuner.y)\n\n(5.734217584632275, 7.782152436286657)\n\n\n\n\n14.9.5 Detailed Hyperparameter Plots\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)\n\nC:  0.4098353450189059\nkernel:  100.0\n\n\n\n\n\n\n\n14.9.6 Parallel Coordinates Plot\n\nspot_tuner.parallel_plot()\n\n\n                                                \n\n\n\n\n14.9.7 Plot all Combinations of Hyperparameters\n\nWarning: this may take a while.\n\n\nPLOT_ALL = False\nif PLOT_ALL:\n    n = spot_tuner.k\n    for i in range(n-1):\n        for j in range(i+1, n):\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z)"
  },
  {
    "objectID": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#sec-setup-16",
    "href": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#sec-setup-16",
    "title": "15  HPT: sklearn RandomForestClassifier VBDP Data",
    "section": "15.1 Step 1: Setup",
    "text": "15.1 Step 1: Setup\nBefore we consider the detailed experimental setup, we select the parameters that affect run time and the initial design size.\n\nMAX_TIME = 1\nINIT_SIZE = 5\nORIGINAL = True\nPREFIX = \"16\"\n\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")"
  },
  {
    "objectID": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#step-2-initialization-of-the-empty-fun_control-dictionary",
    "href": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#step-2-initialization-of-the-empty-fun_control-dictionary",
    "title": "15  HPT: sklearn RandomForestClassifier VBDP Data",
    "section": "15.2 Step 2: Initialization of the Empty fun_control Dictionary",
    "text": "15.2 Step 2: Initialization of the Empty fun_control Dictionary\n\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_experiment_name, get_spot_tensorboard_path\nfrom spotPython.utils.device import getDevice\n\nexperiment_name = get_experiment_name(prefix=PREFIX)\n\nfun_control = fun_control_init(\n    task=\"classification\",\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name))"
  },
  {
    "objectID": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#step-3-pytorch-data-loading",
    "href": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#step-3-pytorch-data-loading",
    "title": "15  HPT: sklearn RandomForestClassifier VBDP Data",
    "section": "15.3 Step 3: PyTorch Data Loading",
    "text": "15.3 Step 3: PyTorch Data Loading\n\n15.3.1 Load Data: Classification VBDP\n\nimport pandas as pd\nif ORIGINAL == True:\n    train_df = pd.read_csv('./data/VBDP/trainn.csv')\n    test_df = pd.read_csv('./data/VBDP/testt.csv')\nelse:\n    train_df = pd.read_csv('./data/VBDP/train.csv')\n    # remove the id column\n    train_df = train_df.drop(columns=['id'])\n\n\nfrom sklearn.preprocessing import OrdinalEncoder\nn_samples = train_df.shape[0]\nn_features = train_df.shape[1] - 1\ntarget_column = \"prognosis\"\n# Encoder our prognosis labels as integers for easier decoding later\nenc = OrdinalEncoder()\ntrain_df[target_column] = enc.fit_transform(train_df[[target_column]])\ntrain_df.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\nprint(train_df.shape)\ntrain_df.head()\n\n(252, 65)\n\n\n\n\n\n\n\n\n\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n...\nx56\nx57\nx58\nx59\nx60\nx61\nx62\nx63\nx64\nprognosis\n\n\n\n\n0\n0\n1\n1\n1\n1\n0\n1\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n1\n1\n1\n1\n1\n1\n0\n1\n1\n1\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n2\n0\n1\n0\n1\n0\n0\n1\n1\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n3\n0\n0\n0\n0\n0\n1\n1\n1\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n4\n1\n0\n0\n0\n1\n1\n1\n1\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n\n\n5 rows × 65 columns\n\n\n\nThe full data set train_df 64 features. The target column is labeled as prognosis.\n\n\n15.3.2 Holdout Train and Test Data\nWe split out a hold-out test set (25% of the data) so we can calculate an example MAP@K\n\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(train_df.drop(target_column, axis=1), train_df[target_column],\n                                                    random_state=42,\n                                                    test_size=0.25,\n                                                    stratify=train_df[target_column])\ntrain = pd.DataFrame(np.hstack((X_train, np.array(y_train).reshape(-1, 1))))\ntest = pd.DataFrame(np.hstack((X_test, np.array(y_test).reshape(-1, 1))))\ntrain.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\ntest.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\nprint(train.shape)\nprint(test.shape)\ntrain.head()\n\n(189, 65)\n(63, 65)\n\n\n\n\n\n\n\n\n\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n...\nx56\nx57\nx58\nx59\nx60\nx61\nx62\nx63\nx64\nprognosis\n\n\n\n\n0\n1.0\n0.0\n0.0\n1.0\n0.0\n1.0\n0.0\n0.0\n0.0\n1.0\n...\n0.0\n0.0\n0.0\n0.0\n1.0\n1.0\n1.0\n0.0\n0.0\n7.0\n\n\n1\n1.0\n0.0\n1.0\n1.0\n1.0\n1.0\n1.0\n0.0\n1.0\n1.0\n...\n0.0\n1.0\n1.0\n1.0\n1.0\n0.0\n1.0\n1.0\n1.0\n3.0\n\n\n2\n0.0\n0.0\n1.0\n0.0\n1.0\n0.0\n0.0\n0.0\n0.0\n0.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n10.0\n\n\n3\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n0.0\n0.0\n1.0\n1.0\n...\n1.0\n0.0\n1.0\n1.0\n1.0\n0.0\n0.0\n1.0\n1.0\n3.0\n\n\n4\n1.0\n1.0\n1.0\n0.0\n1.0\n1.0\n0.0\n1.0\n1.0\n0.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n8.0\n\n\n\n\n5 rows × 65 columns\n\n\n\n\n# add the dataset to the fun_control\nfun_control.update({\"data\": train_df, # full dataset,\n               \"train\": train,\n               \"test\": test,\n               \"n_samples\": n_samples,\n               \"target_column\": target_column})"
  },
  {
    "objectID": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#sec-specification-of-preprocessing-model-16",
    "href": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#sec-specification-of-preprocessing-model-16",
    "title": "15  HPT: sklearn RandomForestClassifier VBDP Data",
    "section": "15.4 Step 4: Specification of the Preprocessing Model",
    "text": "15.4 Step 4: Specification of the Preprocessing Model\nData preprocesssing can be very simple, e.g., you can ignore it. Then you would choose the prep_model “None”:\n\nprep_model = None\nfun_control.update({\"prep_model\": prep_model})\n\nA default approach for numerical data is the StandardScaler (mean 0, variance 1). This can be selected as follows:\n\n# prep_model = StandardScaler()\n# fun_control.update({\"prep_model\": prep_model})\n\nEven more complicated pre-processing steps are possible, e.g., the follwing pipeline:\n\n# categorical_columns = []\n# one_hot_encoder = OneHotEncoder(handle_unknown=\"ignore\", sparse_output=False)\n# prep_model = ColumnTransformer(\n#         transformers=[\n#             (\"categorical\", one_hot_encoder, categorical_columns),\n#         ],\n#         remainder=StandardScaler(),\n#     )"
  },
  {
    "objectID": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#step-5-select-model-algorithm-and-core_model_hyper_dict",
    "href": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#step-5-select-model-algorithm-and-core_model_hyper_dict",
    "title": "15  HPT: sklearn RandomForestClassifier VBDP Data",
    "section": "15.5 Step 5: Select Model (algorithm) and core_model_hyper_dict",
    "text": "15.5 Step 5: Select Model (algorithm) and core_model_hyper_dict\nThe selection of the algorithm (ML model) that should be tuned is done by specifying the its name from the sklearn implementation. For example, the SVC support vector machine classifier is selected as follows:\nadd_core_model_to_fun_control(SVC, fun_control, SklearnHyperDict)\nOther core_models are, e.g.,:\n\nRidgeCV\nGradientBoostingRegressor\nElasticNet\nRandomForestClassifier\nLogisticRegression\nKNeighborsClassifier\nRandomForestClassifier\nGradientBoostingClassifier\nHistGradientBoostingClassifier\n\nWe will use the RandomForestClassifier classifier in this example.\n\nfrom sklearn.linear_model import RidgeCV\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.linear_model import ElasticNet\nfrom spotPython.hyperparameters.values import add_core_model_to_fun_control\nfrom spotPython.data.sklearn_hyper_dict import SklearnHyperDict\nfrom spotPython.fun.hypersklearn import HyperSklearn\n\n\n# core_model  = RidgeCV\n# core_model = GradientBoostingRegressor\n# core_model = ElasticNet\ncore_model = RandomForestClassifier\n# core_model = SVC\n# core_model = LogisticRegression\n# core_model = KNeighborsClassifier\n# core_model = GradientBoostingClassifier\nadd_core_model_to_fun_control(core_model=core_model,\n                              fun_control=fun_control,\n                              hyper_dict=SklearnHyperDict,\n                              filename=None)\n\nNow fun_control has the information from the JSON file. The available hyperparameters are:\n\nprint(*fun_control[\"core_model_hyper_dict\"].keys(), sep=\"\\n\")\n\nn_estimators\ncriterion\nmax_depth\nmin_samples_split\nmin_samples_leaf\nmin_weight_fraction_leaf\nmax_features\nmax_leaf_nodes\nmin_impurity_decrease\nbootstrap\noob_score"
  },
  {
    "objectID": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#step-6-modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "href": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#step-6-modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "title": "15  HPT: sklearn RandomForestClassifier VBDP Data",
    "section": "15.6 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model",
    "text": "15.6 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\n\n15.6.1 Modify hyperparameter of type numeric and integer (boolean)\nNumeric and boolean values can be modified using the modify_hyper_parameter_bounds method. For example, to change the tol hyperparameter of the SVC model to the interval [1e-3, 1e-2], the following code can be used:\nmodify_hyper_parameter_bounds(fun_control, \"tol\", bounds=[1e-3, 1e-2])\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_bounds\n# modify_hyper_parameter_bounds(fun_control, \"tol\", bounds=[1e-3, 1e-2])\n\n\n\n15.6.2 Modify hyperparameter of type factor\nspotPython provides functions for modifying the hyperparameters, their bounds and factors as well as for activating and de-activating hyperparameters without re-compilation of the Python source code. These functions were described in Section 23.6.\nFactors can be modified with the modify_hyper_parameter_levels function. For example, to exclude the sigmoid kernel from the tuning, the kernel hyperparameter of the SVC model can be modified as follows:\nmodify_hyper_parameter_levels(fun_control, \"kernel\", [\"linear\", \"rbf\"])\nThe new setting can be controlled via:\nfun_control[\"core_model_hyper_dict\"][\"kernel\"]\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_levels\n# XGBoost:\n# modify_hyper_parameter_levels(fun_control, \"loss\", [\"log_loss\"])\n\n\n\n\n\n\n\nNote: RandomForestClassifier and Out-of-bag Estimation\n\n\n\nSince oob_score requires the bootstrap hyperparameter to True, we set the oob_score parameter to False. The oob_score is later discussed in Section 15.7.3.\n\n\n\nmodify_hyper_parameter_bounds(fun_control, \"bootstrap\", bounds=[0, 1])\nmodify_hyper_parameter_bounds(fun_control, \"oob_score\", bounds=[0, 0])\n\n\n\n15.6.3 Optimizers\nOptimizers are described in Section 23.6.1.\n\n\n15.6.4 Selection of the Objective: Metric and Loss Functions\n\nMachine learning models are optimized with respect to a metric, for example, the accuracy function.\nDeep learning, e.g., neural networks are optimized with respect to a loss function, for example, the cross_entropy function and evaluated with respect to a metric, for example, the accuracy function."
  },
  {
    "objectID": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#step-7-selection-of-the-objective-loss-function",
    "href": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#step-7-selection-of-the-objective-loss-function",
    "title": "15  HPT: sklearn RandomForestClassifier VBDP Data",
    "section": "15.7 Step 7: Selection of the Objective (Loss) Function",
    "text": "15.7 Step 7: Selection of the Objective (Loss) Function\nThe loss function, that is usually used in deep learning for optimizing the weights of the net, is stored in the fun_control dictionary as \"loss_function\".\n\n15.7.1 Metric Function\nThere are two different types of metrics in spotPython:\n\n\"metric_river\" is used for the river based evaluation via eval_oml_iter_progressive.\n\"metric_sklearn\" is used for the sklearn based evaluation.\n\nWe will consider multi-class classification metrics, e.g., mapk_score and top_k_accuracy_score.\n\n\n\n\n\n\nPredict Probabilities\n\n\n\nIn this multi-class classification example the machine learning algorithm should return the probabilities of the specific classes (\"predict_proba\") instead of the predicted values.\n\n\nWe set \"predict_proba\" to True in the fun_control dictionary.\n\n15.7.1.1 The MAPK Metric\nTo select the MAPK metric, the following two entries can be added to the fun_control dictionary:\n\"metric_sklearn\": mapk_score\"\n\"metric_params\": {\"k\": 3}.\n\n\n15.7.1.2 Other Metrics\nAlternatively, other metrics for multi-class classification can be used, e.g.,: * top_k_accuracy_score or * roc_auc_score\nThe metric roc_auc_score requires the parameter \"multi_class\", e.g.,\n\"multi_class\": \"ovr\".\nThis is set in the fun_control dictionary.\n\n\n\n\n\n\nWeights\n\n\n\nspotPython performs a minimization, therefore, metrics that should be maximized have to be multiplied by -1. This is done by setting \"weights\" to -1.\n\n\n\nThe complete setup for the metric in our example is:\n\n\nfrom spotPython.utils.metrics import mapk_score\nfun_control.update({\n               \"weights\": -1,\n               \"metric_sklearn\": mapk_score,\n               \"predict_proba\": True,\n               \"metric_params\": {\"k\": 3},\n               })\n\n\n\n\n15.7.2 Evaluation on Hold-out Data\n\nThe default method for computing the performance is \"eval_holdout\".\nAlternatively, cross-validation can be used for every machine learning model.\nSpecifically for RandomForests, the OOB-score can be used.\n\n\nfun_control.update({\n    \"eval\": \"train_hold_out\",\n})\n\n\n\n15.7.3 OOB Score\nUsing the OOB-Score is a very efficient way to estimate the performance of a random forest classifier. The OOB-Score is calculated on the training data and does not require a hold-out test set. If the OOB-Score is used, the key “eval” in the fun_control dictionary should be set to \"oob_score\" as shown below.\n\n\n\n\n\n\nOOB-Score\n\n\n\nIn addition to setting the key \"eval\" in the fun_control dictionary to \"oob_score\", the keys \"oob_score\" and \"bootstrap\" have to be set to True, because the OOB-Score requires the bootstrap method.\n\n\n\nUncomment the following lines to use the OOB-Score:\n\n\nfun_control.update({\n    \"eval\": \"eval_oob_score\",\n})\nmodify_hyper_parameter_bounds(fun_control, \"bootstrap\", bounds=[1, 1])\nmodify_hyper_parameter_bounds(fun_control, \"oob_score\", bounds=[1, 1])\n\n\n15.7.3.1 Cross Validation\nInstead of using the OOB-score, the classical cross validation can be used. The number of folds is set by the key \"k_folds\". For example, to use 5-fold cross validation, the key \"k_folds\" is set to 5. Uncomment the following line to use cross validation:\n\n# fun_control.update({\n#      \"eval\": \"train_cv\",\n#      \"k_folds\": 10,\n# })"
  },
  {
    "objectID": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#step-8-calling-the-spot-function",
    "href": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#step-8-calling-the-spot-function",
    "title": "15  HPT: sklearn RandomForestClassifier VBDP Data",
    "section": "15.8 Step 8: Calling the SPOT Function",
    "text": "15.8 Step 8: Calling the SPOT Function\n\n15.8.1 Preparing the SPOT Call\n\nGet types and variable names as well as lower and upper bounds for the hyperparameters.\n\n\n# extract the variable types, names, and bounds\nfrom spotPython.hyperparameters.values import (get_bound_values,\n    get_var_name,\n    get_var_type,)\nvar_type = get_var_type(fun_control)\nvar_name = get_var_name(fun_control)\nlower = get_bound_values(fun_control, \"lower\")\nupper = get_bound_values(fun_control, \"upper\")\n\n\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control))\n\n| name                     | type   | default   |   lower |   upper | transform              |\n|--------------------------|--------|-----------|---------|---------|------------------------|\n| n_estimators             | int    | 7         |       5 |   10    | transform_power_2_int  |\n| criterion                | factor | gini      |       0 |    2    | None                   |\n| max_depth                | int    | 10        |       1 |   20    | transform_power_2_int  |\n| min_samples_split        | int    | 2         |       2 |  100    | None                   |\n| min_samples_leaf         | int    | 1         |       1 |   25    | None                   |\n| min_weight_fraction_leaf | float  | 0.0       |       0 |    0.01 | None                   |\n| max_features             | factor | sqrt      |       0 |    1    | transform_none_to_None |\n| max_leaf_nodes           | int    | 10        |       7 |   12    | transform_power_2_int  |\n| min_impurity_decrease    | float  | 0.0       |       0 |    0.01 | None                   |\n| bootstrap                | factor | 1         |       1 |    1    | None                   |\n| oob_score                | factor | 0         |       1 |    1    | None                   |\n\n\n\n\n15.8.2 The Objective Function\nThe objective function is selected next. It implements an interface from sklearn’s training, validation, and testing methods to spotPython.\n\nfrom spotPython.fun.hypersklearn import HyperSklearn\nfun = HyperSklearn().fun_sklearn\n\n\n\n15.8.3 Run the Spot Optimizer\n\nRun SPOT for approx. x mins (max_time).\nNote: the run takes longer, because the evaluation time of initial design (here: initi_size, 20 points) is not considered.\n\n\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nX_start = get_default_hyperparameters_as_array(fun_control)\nX_start\n\narray([[ 7.,  0., 10.,  2.,  1.,  0.,  0., 10.,  0.,  1.,  0.]])\n\n\n\nimport numpy as np\nfrom spotPython.spot import spot\nfrom math import inf\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   fun_repeats = 1,\n                   max_time = MAX_TIME,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   infill_criterion = \"y\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models= False,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": True,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_fun_evals\": 10_000,\n                                      \"log_level\": 50\n                                      })\nspot_tuner.run(X_start=X_start)\n\nspotPython tuning: -0.8544973544973545 [----------] 1.55% \n\n\nspotPython tuning: -0.8544973544973545 [----------] 2.57% \n\n\nspotPython tuning: -0.8544973544973545 [----------] 3.75% \n\n\nspotPython tuning: -0.8544973544973545 [#---------] 5.45% \n\n\nspotPython tuning: -0.8544973544973545 [#---------] 7.39% \n\n\nspotPython tuning: -0.8544973544973545 [#---------] 9.22% \n\n\nspotPython tuning: -0.8544973544973545 [#---------] 11.09% \n\n\nspotPython tuning: -0.8544973544973545 [#---------] 13.47% \n\n\nspotPython tuning: -0.8544973544973545 [##--------] 15.53% \n\n\nspotPython tuning: -0.8544973544973545 [##--------] 18.11% \n\n\nspotPython tuning: -0.8544973544973545 [##--------] 19.84% \n\n\nspotPython tuning: -0.8544973544973545 [##--------] 21.67% \n\n\nspotPython tuning: -0.8544973544973545 [####------] 38.95% \n\n\nspotPython tuning: -0.8544973544973545 [######----] 59.83% \n\n\nspotPython tuning: -0.8544973544973545 [#######---] 73.81% \n\n\nspotPython tuning: -0.8544973544973545 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x177a4eb90&gt;"
  },
  {
    "objectID": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#sec-tensorboard-16",
    "href": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#sec-tensorboard-16",
    "title": "15  HPT: sklearn RandomForestClassifier VBDP Data",
    "section": "15.9 Step 9: Tensorboard",
    "text": "15.9 Step 9: Tensorboard\nThe textual output shown in the console (or code cell) can be visualized with Tensorboard as described in Section 23.9, see also the description in the documentation: Tensorboard."
  },
  {
    "objectID": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#sec-results-tuning-16",
    "href": "16_spot_hpt_sklearn_multiclass_classification_randomforest.html#sec-results-tuning-16",
    "title": "15  HPT: sklearn RandomForestClassifier VBDP Data",
    "section": "15.10 Step 10: Results",
    "text": "15.10 Step 10: Results\nAfter the hyperparameter tuning run is finished, the progress of the hyperparameter tuning can be visualized. The following code generates the progress plot from ?fig-progress.\n\nspot_tuner.plot_progress(log_y=False,\n    filename=\"./figures/\" + experiment_name+\"_progress.png\")\n\n\n\n\nProgress plot. Black dots denote results from the initial design. Red dots illustrate the improvement found by the surrogate model based optimization.\n\n\n\n\n\nPrint the results\n\n\nprint(gen_design_table(fun_control=fun_control,\n    spot=spot_tuner))\n\n| name                     | type   | default   |   lower |   upper |                tuned | transform              |   importance | stars   |\n|--------------------------|--------|-----------|---------|---------|----------------------|------------------------|--------------|---------|\n| n_estimators             | int    | 7         |     5.0 |    10.0 |                  7.0 | transform_power_2_int  |         5.07 | *       |\n| criterion                | factor | gini      |     0.0 |     2.0 |                  2.0 | None                   |       100.00 | ***     |\n| max_depth                | int    | 10        |     1.0 |    20.0 |                  5.0 | transform_power_2_int  |         0.00 |         |\n| min_samples_split        | int    | 2         |     2.0 |   100.0 |                  2.0 | None                   |        37.55 | *       |\n| min_samples_leaf         | int    | 1         |     1.0 |    25.0 |                  4.0 | None                   |         9.81 | *       |\n| min_weight_fraction_leaf | float  | 0.0       |     0.0 |    0.01 |  0.00810023391935861 | None                   |         0.10 |         |\n| max_features             | factor | sqrt      |     0.0 |     1.0 |                  0.0 | transform_none_to_None |         0.00 |         |\n| max_leaf_nodes           | int    | 10        |     7.0 |    12.0 |                 10.0 | transform_power_2_int  |         0.04 |         |\n| min_impurity_decrease    | float  | 0.0       |     0.0 |    0.01 | 0.005725169307667725 | None                   |        12.04 | *       |\n| bootstrap                | factor | 1         |     1.0 |     1.0 |                  1.0 | None                   |         0.00 |         |\n| oob_score                | factor | 0         |     1.0 |     1.0 |                  1.0 | None                   |         0.00 |         |\n\n\n\n15.10.1 Show variable importance\n\nspot_tuner.plot_importance(threshold=0.025, filename=\"./figures/\" + experiment_name+\"_importance.png\")\n\n\n\n\nVariable importance plot, threshold 0.025.\n\n\n\n\n\n\n15.10.2 Get Default Hyperparameters\n\nfrom spotPython.hyperparameters.values import get_default_values, transform_hyper_parameter_values\nvalues_default = get_default_values(fun_control)\nvalues_default = transform_hyper_parameter_values(fun_control=fun_control, hyper_parameter_values=values_default)\nvalues_default\n\n{'n_estimators': 128,\n 'criterion': 'gini',\n 'max_depth': 1024,\n 'min_samples_split': 2,\n 'min_samples_leaf': 1,\n 'min_weight_fraction_leaf': 0.0,\n 'max_features': 'sqrt',\n 'max_leaf_nodes': 1024,\n 'min_impurity_decrease': 0.0,\n 'bootstrap': 1,\n 'oob_score': 0}\n\n\n\nfrom sklearn.pipeline import make_pipeline\nmodel_default = make_pipeline(fun_control[\"prep_model\"], fun_control[\"core_model\"](**values_default))\nmodel_default\n\nPipeline(steps=[('nonetype', None),\n                ('randomforestclassifier',\n                 RandomForestClassifier(bootstrap=1, max_depth=1024,\n                                        max_leaf_nodes=1024, n_estimators=128,\n                                        oob_score=0))])In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.PipelinePipeline(steps=[('nonetype', None),\n                ('randomforestclassifier',\n                 RandomForestClassifier(bootstrap=1, max_depth=1024,\n                                        max_leaf_nodes=1024, n_estimators=128,\n                                        oob_score=0))])NoneNoneRandomForestClassifierRandomForestClassifier(bootstrap=1, max_depth=1024, max_leaf_nodes=1024,\n                       n_estimators=128, oob_score=0)\n\n\n\n\n15.10.3 Get SPOT Results\n\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nprint(X)\n\n[[7.00000000e+00 2.00000000e+00 5.00000000e+00 2.00000000e+00\n  4.00000000e+00 8.10023392e-03 0.00000000e+00 1.00000000e+01\n  5.72516931e-03 1.00000000e+00 1.00000000e+00]]\n\n\n\nfrom spotPython.hyperparameters.values import assign_values, return_conf_list_from_var_dict\nv_dict = assign_values(X, fun_control[\"var_name\"])\nreturn_conf_list_from_var_dict(var_dict=v_dict, fun_control=fun_control)\n\n[{'n_estimators': 128,\n  'criterion': 'log_loss',\n  'max_depth': 32,\n  'min_samples_split': 2,\n  'min_samples_leaf': 4,\n  'min_weight_fraction_leaf': 0.00810023391935861,\n  'max_features': 'sqrt',\n  'max_leaf_nodes': 1024,\n  'min_impurity_decrease': 0.005725169307667725,\n  'bootstrap': 1,\n  'oob_score': 1}]\n\n\n\nfrom spotPython.hyperparameters.values import get_one_sklearn_model_from_X\nmodel_spot = get_one_sklearn_model_from_X(X, fun_control)\nmodel_spot\n\nRandomForestClassifier(bootstrap=1, criterion='log_loss', max_depth=32,\n                       max_leaf_nodes=1024,\n                       min_impurity_decrease=0.005725169307667725,\n                       min_samples_leaf=4,\n                       min_weight_fraction_leaf=0.00810023391935861,\n                       n_estimators=128, oob_score=1)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.RandomForestClassifierRandomForestClassifier(bootstrap=1, criterion='log_loss', max_depth=32,\n                       max_leaf_nodes=1024,\n                       min_impurity_decrease=0.005725169307667725,\n                       min_samples_leaf=4,\n                       min_weight_fraction_leaf=0.00810023391935861,\n                       n_estimators=128, oob_score=1)\n\n\n\n\n15.10.4 Evaluate SPOT Results\n\nFetch the data.\n\n\nfrom spotPython.utils.convert import get_Xy_from_df\nX_train, y_train = get_Xy_from_df(fun_control[\"train\"], fun_control[\"target_column\"])\nX_test, y_test = get_Xy_from_df(fun_control[\"test\"], fun_control[\"target_column\"])\nX_test.shape, y_test.shape\n\n((63, 64), (63,))\n\n\n\nFit the model with the tuned hyperparameters. This gives one result:\n\n\nmodel_spot.fit(X_train, y_train)\ny_pred = model_spot.predict_proba(X_test)\nres = mapk_score(y_true=y_test, y_pred=y_pred, k=3)\nres\n\n0.8227513227513227\n\n\n\ndef repeated_eval(n, model):\n    res_values = []\n    for i in range(n):\n        model.fit(X_train, y_train)\n        y_pred = model.predict_proba(X_test)\n        res = mapk_score(y_true=y_test, y_pred=y_pred, k=3)\n        res_values.append(res)\n    mean_res = np.mean(res_values)\n    print(f\"mean_res: {mean_res}\")\n    std_res = np.std(res_values)\n    print(f\"std_res: {std_res}\")\n    min_res = np.min(res_values)\n    print(f\"min_res: {min_res}\")\n    max_res = np.max(res_values)\n    print(f\"max_res: {max_res}\")\n    median_res = np.median(res_values)\n    print(f\"median_res: {median_res}\")\n    return mean_res, std_res, min_res, max_res, median_res\n\n\n\n15.10.5 Handling Non-deterministic Results\n\nBecause the model is non-determinstic, we perform \\(n=30\\) runs and calculate the mean and standard deviation of the performance metric.\n\n\n_ = repeated_eval(30, model_spot)\n\nmean_res: 0.8322751322751322\nstd_res: 0.011960481011065938\nmin_res: 0.8121693121693121\nmax_res: 0.8544973544973544\nmedian_res: 0.8306878306878306\n\n\n\n\n15.10.6 Evalution of the Default Hyperparameters\n\nmodel_default.fit(X_train, y_train)[\"randomforestclassifier\"]\n\nRandomForestClassifier(bootstrap=1, max_depth=1024, max_leaf_nodes=1024,\n                       n_estimators=128, oob_score=0)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.RandomForestClassifierRandomForestClassifier(bootstrap=1, max_depth=1024, max_leaf_nodes=1024,\n                       n_estimators=128, oob_score=0)\n\n\n\nOne evaluation of the default hyperparameters is performed on the hold-out test set.\n\n\ny_pred = model_default.predict_proba(X_test)\nmapk_score(y_true=y_test, y_pred=y_pred, k=3)\n\n0.8571428571428571\n\n\nSince one single evaluation is not meaningful, we perform, similar to the evaluation of the SPOT results, \\(n=30\\) runs of the default setting and and calculate the mean and standard deviation of the performance metric.\n\n_ = repeated_eval(30, model_default)\n\nmean_res: 0.855026455026455\nstd_res: 0.010480109006522452\nmin_res: 0.8333333333333334\nmax_res: 0.8783068783068784\nmedian_res: 0.8544973544973544\n\n\n\n\n15.10.7 Plot: Compare Predictions\n\nfrom spotPython.plot.validation import plot_confusion_matrix\nplot_confusion_matrix(model=model_default, fun_control=fun_control, title = \"Default\")\n\n\n\n\n\nplot_confusion_matrix(model=model_spot, fun_control=fun_control, title=\"SPOT\")\n\n\n\n\n\nmin(spot_tuner.y), max(spot_tuner.y)\n\n(-0.8544973544973545, -0.6155202821869489)\n\n\n\n\n15.10.8 Cross-validated Evaluations\n\nfrom spotPython.sklearn.traintest import evaluate_cv\nfun_control.update({\n     \"eval\": \"train_cv\",\n     \"k_folds\": 10,\n})\nevaluate_cv(model=model_spot, fun_control=fun_control, verbose=0)\n\n(0.84995126705653, None)\n\n\n\nfun_control.update({\n     \"eval\": \"test_cv\",\n     \"k_folds\": 10,\n})\nevaluate_cv(model=model_spot, fun_control=fun_control, verbose=0)\n\nError in fun_sklearn(). Call to evaluate_cv failed. err=ValueError('n_splits=10 cannot be greater than the number of members in each class.'), type(err)=&lt;class 'ValueError'&gt;\n\n\n(nan, None)\n\n\n\nThis is the evaluation that will be used in the comparison:\n\n\nfun_control.update({\n     \"eval\": \"data_cv\",\n     \"k_folds\": 10,\n})\nevaluate_cv(model=model_spot, fun_control=fun_control, verbose=0)\n\n(0.856076923076923, None)\n\n\n\n\n15.10.9 Detailed Hyperparameter Plots\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)\n\nn_estimators:  5.07340164554753\ncriterion:  100.0\nmin_samples_split:  37.54599979171609\nmin_samples_leaf:  9.809878759779284\nmin_weight_fraction_leaf:  0.09557271898186322\nmax_leaf_nodes:  0.0411017212371884\nmin_impurity_decrease:  12.040980881141223\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n15.10.10 Parallel Coordinates Plot\n\nspot_tuner.parallel_plot()\n\n\n                                                \n\n\n\n\n15.10.11 Plot all Combinations of Hyperparameters\n\nWarning: this may take a while.\n\n\nPLOT_ALL = False\nif PLOT_ALL:\n    n = spot_tuner.k\n    for i in range(n-1):\n        for j in range(i+1, n):\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z)"
  },
  {
    "objectID": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#sec-setup-17",
    "href": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#sec-setup-17",
    "title": "16  HPT: sklearn XGB Classifier VBDP Data",
    "section": "16.1 Step 1: Setup",
    "text": "16.1 Step 1: Setup\nBefore we consider the detailed experimental setup, we select the parameters that affect run time and the initial design size.\n\nMAX_TIME = 1\nINIT_SIZE = 5\nORIGINAL = True\nPREFIX = \"17\"\n\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")"
  },
  {
    "objectID": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#step-2-initialization-of-the-empty-fun_control-dictionary",
    "href": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#step-2-initialization-of-the-empty-fun_control-dictionary",
    "title": "16  HPT: sklearn XGB Classifier VBDP Data",
    "section": "16.2 Step 2: Initialization of the Empty fun_control Dictionary",
    "text": "16.2 Step 2: Initialization of the Empty fun_control Dictionary\n\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_experiment_name, get_spot_tensorboard_path\nfrom spotPython.utils.device import getDevice\n\nexperiment_name = get_experiment_name(prefix=PREFIX)\n\nfun_control = fun_control_init(\n    task=\"classification\",\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name))"
  },
  {
    "objectID": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#sec-data-loading-17",
    "href": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#sec-data-loading-17",
    "title": "16  HPT: sklearn XGB Classifier VBDP Data",
    "section": "16.3 Step 3: PyTorch Data Loading",
    "text": "16.3 Step 3: PyTorch Data Loading\n\n16.3.1 1. Load Data: Classification VBDP\n\nimport pandas as pd\nif ORIGINAL == True:\n    train_df = pd.read_csv('./data/VBDP/trainn.csv')\n    test_df = pd.read_csv('./data/VBDP/testt.csv')\nelse:\n    train_df = pd.read_csv('./data/VBDP/train.csv')\n    # remove the id column\n    train_df = train_df.drop(columns=['id'])\n\n\nfrom sklearn.preprocessing import OrdinalEncoder\nn_samples = train_df.shape[0]\nn_features = train_df.shape[1] - 1\ntarget_column = \"prognosis\"\n# Encoder our prognosis labels as integers for easier decoding later\nenc = OrdinalEncoder()\ntrain_df[target_column] = enc.fit_transform(train_df[[target_column]])\ntrain_df.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\nprint(train_df.shape)\ntrain_df.head()\n\n(252, 65)\n\n\n\n\n\n\n\n\n\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n...\nx56\nx57\nx58\nx59\nx60\nx61\nx62\nx63\nx64\nprognosis\n\n\n\n\n0\n0\n1\n1\n1\n1\n0\n1\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n1\n1\n1\n1\n1\n1\n0\n1\n1\n1\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n2\n0\n1\n0\n1\n0\n0\n1\n1\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n3\n0\n0\n0\n0\n0\n1\n1\n1\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n4\n1\n0\n0\n0\n1\n1\n1\n1\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n\n\n5 rows × 65 columns\n\n\n\nThe full data set train_df 64 features. The target column is labeled as prognosis.\n\n\n16.3.2 Holdout Train and Test Data\nWe split out a hold-out test set (25% of the data) so we can calculate an example MAP@K\n\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(train_df.drop(target_column, axis=1), train_df[target_column],\n                                                    random_state=42,\n                                                    test_size=0.25,\n                                                    stratify=train_df[target_column])\ntrain = pd.DataFrame(np.hstack((X_train, np.array(y_train).reshape(-1, 1))))\ntest = pd.DataFrame(np.hstack((X_test, np.array(y_test).reshape(-1, 1))))\ntrain.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\ntest.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\nprint(train.shape)\nprint(test.shape)\ntrain.head()\n\n(189, 65)\n(63, 65)\n\n\n\n\n\n\n\n\n\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n...\nx56\nx57\nx58\nx59\nx60\nx61\nx62\nx63\nx64\nprognosis\n\n\n\n\n0\n1.0\n0.0\n0.0\n1.0\n0.0\n1.0\n0.0\n0.0\n0.0\n1.0\n...\n0.0\n0.0\n0.0\n0.0\n1.0\n1.0\n1.0\n0.0\n0.0\n7.0\n\n\n1\n1.0\n0.0\n1.0\n1.0\n1.0\n1.0\n1.0\n0.0\n1.0\n1.0\n...\n0.0\n1.0\n1.0\n1.0\n1.0\n0.0\n1.0\n1.0\n1.0\n3.0\n\n\n2\n0.0\n0.0\n1.0\n0.0\n1.0\n0.0\n0.0\n0.0\n0.0\n0.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n10.0\n\n\n3\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n0.0\n0.0\n1.0\n1.0\n...\n1.0\n0.0\n1.0\n1.0\n1.0\n0.0\n0.0\n1.0\n1.0\n3.0\n\n\n4\n1.0\n1.0\n1.0\n0.0\n1.0\n1.0\n0.0\n1.0\n1.0\n0.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n8.0\n\n\n\n\n5 rows × 65 columns\n\n\n\n\n# add the dataset to the fun_control\nfun_control.update({\"data\": train_df, # full dataset,\n               \"train\": train,\n               \"test\": test,\n               \"n_samples\": n_samples,\n               \"target_column\": target_column})"
  },
  {
    "objectID": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#sec-specification-of-preprocessing-model-17",
    "href": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#sec-specification-of-preprocessing-model-17",
    "title": "16  HPT: sklearn XGB Classifier VBDP Data",
    "section": "16.4 Step 4: Specification of the Preprocessing Model",
    "text": "16.4 Step 4: Specification of the Preprocessing Model\nData preprocesssing can be very simple, e.g., you can ignore it. Then you would choose the prep_model “None”:\n\nprep_model = None\nfun_control.update({\"prep_model\": prep_model})\n\nA default approach for numerical data is the StandardScaler (mean 0, variance 1). This can be selected as follows:\n\n# prep_model = StandardScaler()\n# fun_control.update({\"prep_model\": prep_model})\n\nEven more complicated pre-processing steps are possible, e.g., the follwing pipeline:\n\n# categorical_columns = []\n# one_hot_encoder = OneHotEncoder(handle_unknown=\"ignore\", sparse_output=False)\n# prep_model = ColumnTransformer(\n#         transformers=[\n#             (\"categorical\", one_hot_encoder, categorical_columns),\n#         ],\n#         remainder=StandardScaler(),\n#     )"
  },
  {
    "objectID": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#step-5-select-model-algorithm-and-core_model_hyper_dict",
    "href": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#step-5-select-model-algorithm-and-core_model_hyper_dict",
    "title": "16  HPT: sklearn XGB Classifier VBDP Data",
    "section": "16.5 Step 5: Select Model (algorithm) and core_model_hyper_dict",
    "text": "16.5 Step 5: Select Model (algorithm) and core_model_hyper_dict\nThe selection of the algorithm (ML model) that should be tuned is done by specifying the its name from the sklearn implementation. For example, the SVC support vector machine classifier is selected as follows:\nadd_core_model_to_fun_control(SVC, fun_control, SklearnHyperDict)\nOther core_models are, e.g.,:\n\nRidgeCV\nGradientBoostingRegressor\nElasticNet\nRandomForestClassifier\nLogisticRegression\nKNeighborsClassifier\nRandomForestClassifier\nGradientBoostingClassifier\nHistGradientBoostingClassifier\n\nWe will use the RandomForestClassifier classifier in this example.\n\nfrom sklearn.linear_model import RidgeCV\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.ensemble import HistGradientBoostingClassifier\nfrom sklearn.linear_model import ElasticNet\nfrom spotPython.hyperparameters.values import add_core_model_to_fun_control\nfrom spotPython.data.sklearn_hyper_dict import SklearnHyperDict\nfrom spotPython.fun.hypersklearn import HyperSklearn\n\n\n# core_model  = RidgeCV\n# core_model = GradientBoostingRegressor\n# core_model = ElasticNet\ncore_model = RandomForestClassifier\n# core_model = SVC\n# core_model = LogisticRegression\n# core_model = KNeighborsClassifier\n# core_model = GradientBoostingClassifier\ncore_model = HistGradientBoostingClassifier\nadd_core_model_to_fun_control(core_model=core_model,\n                              fun_control=fun_control,\n                              hyper_dict=SklearnHyperDict,\n                              filename=None)\n\nNow fun_control has the information from the JSON file. The available hyperparameters are:\n\nprint(*fun_control[\"core_model_hyper_dict\"].keys(), sep=\"\\n\")\n\nloss\nlearning_rate\nmax_iter\nmax_leaf_nodes\nmax_depth\nmin_samples_leaf\nl2_regularization\nmax_bins\nearly_stopping\nn_iter_no_change\ntol"
  },
  {
    "objectID": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#step-6-modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "href": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#step-6-modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "title": "16  HPT: sklearn XGB Classifier VBDP Data",
    "section": "16.6 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model",
    "text": "16.6 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\n\n16.6.1 Modify hyperparameter of type numeric and integer (boolean)\nNumeric and boolean values can be modified using the modify_hyper_parameter_bounds method. For example, to change the tol hyperparameter of the SVC model to the interval [1e-3, 1e-2], the following code can be used:\nmodify_hyper_parameter_bounds(fun_control, \"tol\", bounds=[1e-3, 1e-2])\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_bounds\n# modify_hyper_parameter_bounds(fun_control, \"tol\", bounds=[1e-3, 1e-2])\n# modify_hyper_parameter_bounds(fun_control, \"min_samples_split\", bounds=[3, 20])\n# modify_hyper_parameter_bounds(fun_control, \"dual\", bounds=[0, 0])\n# modify_hyper_parameter_bounds(fun_control, \"probability\", bounds=[1, 1])\n# fun_control[\"core_model_hyper_dict\"][\"tol\"]\n# modify_hyper_parameter_bounds(fun_control, \"min_samples_leaf\", bounds=[1, 25])\n# modify_hyper_parameter_bounds(fun_control, \"n_estimators\", bounds=[5, 10])\n\n\n\n16.6.2 Modify hyperparameter of type factor\nspotPython provides functions for modifying the hyperparameters, their bounds and factors as well as for activating and de-activating hyperparameters without re-compilation of the Python source code. These functions were described in Section 23.6.\nFactors can be modified with the modify_hyper_parameter_levels function. For example, to exclude the sigmoid kernel from the tuning, the kernel hyperparameter of the SVC model can be modified as follows:\nmodify_hyper_parameter_levels(fun_control, \"kernel\", [\"linear\", \"rbf\"])\nThe new setting can be controlled via:\nfun_control[\"core_model_hyper_dict\"][\"kernel\"]\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_levels\n# XGBoost:\nmodify_hyper_parameter_levels(fun_control, \"loss\", [\"log_loss\"])\n\n\n\n16.6.3 Optimizers\nOptimizers are described in Section 23.6.1."
  },
  {
    "objectID": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#step-7-selection-of-the-objective-loss-function",
    "href": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#step-7-selection-of-the-objective-loss-function",
    "title": "16  HPT: sklearn XGB Classifier VBDP Data",
    "section": "16.7 Step 7: Selection of the Objective (Loss) Function",
    "text": "16.7 Step 7: Selection of the Objective (Loss) Function\n\n16.7.1 Evaluation\nThe evaluation procedure requires the specification of two elements:\n\nthe way how the data is split into a train and a test set and\nthe loss function (and a metric).\n\n\n\n16.7.2 Selection of the Objective: Metric and Loss Functions\n\nMachine learning models are optimized with respect to a metric, for example, the accuracy function.\nDeep learning, e.g., neural networks are optimized with respect to a loss function, for example, the cross_entropy function and evaluated with respect to a metric, for example, the accuracy function.\n\n\n\n16.7.3 Loss Function\nThe loss function, that is usually used in deep learning for optimizing the weights of the net, is stored in the fun_control dictionary as \"loss_function\".\n\n\n16.7.4 Metric Function\nThere are two different types of metrics in spotPython:\n\n\"metric_river\" is used for the river based evaluation via eval_oml_iter_progressive.\n\"metric_sklearn\" is used for the sklearn based evaluation.\n\nWe will consider multi-class classification metrics, e.g., mapk_score and top_k_accuracy_score.\n\n\n\n\n\n\nPredict Probabilities\n\n\n\nIn this multi-class classification example the machine learning algorithm should return the probabilities of the specific classes (\"predict_proba\") instead of the predicted values.\n\n\nWe set \"predict_proba\" to True in the fun_control dictionary.\n\n16.7.4.1 The MAPK Metric\nTo select the MAPK metric, the following two entries can be added to the fun_control dictionary:\n\"metric_sklearn\": mapk_score\"\n\"metric_params\": {\"k\": 3}.\n\n\n16.7.4.2 Other Metrics\nAlternatively, other metrics for multi-class classification can be used, e.g.,: * top_k_accuracy_score or * roc_auc_score\nThe metric roc_auc_score requires the parameter \"multi_class\", e.g.,\n\"multi_class\": \"ovr\".\nThis is set in the fun_control dictionary.\n\n\n\n\n\n\nWeights\n\n\n\nspotPython performs a minimization, therefore, metrics that should be maximized have to be multiplied by -1. This is done by setting \"weights\" to -1.\n\n\n\nThe complete setup for the metric in our example is:\n\n\nfrom spotPython.utils.metrics import mapk_score\nfun_control.update({\n               \"weights\": -1,\n               \"metric_sklearn\": mapk_score,\n               \"predict_proba\": True,\n               \"metric_params\": {\"k\": 3},\n               })\n\n\n\n\n16.7.5 Evaluation on Hold-out Data\n\nThe default method for computing the performance is \"eval_holdout\".\nAlternatively, cross-validation can be used for every machine learning model.\nSpecifically for RandomForests, the OOB-score can be used.\n\n\nfun_control.update({\n    \"eval\": \"train_hold_out\",\n})\n\n\n16.7.5.1 Cross Validation\nInstead of using the OOB-score, the classical cross validation can be used. The number of folds is set by the key \"k_folds\". For example, to use 5-fold cross validation, the key \"k_folds\" is set to 5. Uncomment the following line to use cross validation:\n\n# fun_control.update({\n#      \"eval\": \"train_cv\",\n#      \"k_folds\": 10,\n# })"
  },
  {
    "objectID": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#step-8-calling-the-spot-function",
    "href": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#step-8-calling-the-spot-function",
    "title": "16  HPT: sklearn XGB Classifier VBDP Data",
    "section": "16.8 Step 8: Calling the SPOT Function",
    "text": "16.8 Step 8: Calling the SPOT Function\n\n16.8.1 Preparing the SPOT Call\n\nGet types and variable names as well as lower and upper bounds for the hyperparameters.\n\n\n# extract the variable types, names, and bounds\nfrom spotPython.hyperparameters.values import (get_bound_values,\n    get_var_name,\n    get_var_type,)\nvar_type = get_var_type(fun_control)\nvar_name = get_var_name(fun_control)\nlower = get_bound_values(fun_control, \"lower\")\nupper = get_bound_values(fun_control, \"upper\")\n\n\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control))\n\n| name              | type   | default   |   lower |   upper | transform             |\n|-------------------|--------|-----------|---------|---------|-----------------------|\n| loss              | factor | log_loss  |   0     |   0     | None                  |\n| learning_rate     | float  | -1.0      |  -5     |   0     | transform_power_10    |\n| max_iter          | int    | 7         |   3     |  10     | transform_power_2_int |\n| max_leaf_nodes    | int    | 5         |   1     |  12     | transform_power_2_int |\n| max_depth         | int    | 2         |   1     |  20     | transform_power_2_int |\n| min_samples_leaf  | int    | 4         |   2     |  10     | transform_power_2_int |\n| l2_regularization | float  | 0.0       |   0     |  10     | None                  |\n| max_bins          | int    | 255       | 127     | 255     | None                  |\n| early_stopping    | factor | 1         |   0     |   1     | None                  |\n| n_iter_no_change  | int    | 10        |   5     |  20     | None                  |\n| tol               | float  | 0.0001    |   1e-05 |   0.001 | None                  |\n\n\n\n\n16.8.2 The Objective Function\nThe objective function is selected next. It implements an interface from sklearn’s training, validation, and testing methods to spotPython.\n\nfrom spotPython.fun.hypersklearn import HyperSklearn\nfun = HyperSklearn().fun_sklearn\n\n\n\n16.8.3 Run the Spot Optimizer\n\nRun SPOT for approx. x mins (max_time).\nNote: the run takes longer, because the evaluation time of initial design (here: initi_size, 20 points) is not considered.\n\n\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nX_start = get_default_hyperparameters_as_array(fun_control)\nX_start\n\narray([[ 0.00e+00, -1.00e+00,  7.00e+00,  5.00e+00,  2.00e+00,  4.00e+00,\n         0.00e+00,  2.55e+02,  1.00e+00,  1.00e+01,  1.00e-04]])\n\n\n\nimport numpy as np\nfrom spotPython.spot import spot\nfrom math import inf\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   fun_repeats = 1,\n                   max_time = MAX_TIME,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   infill_criterion = \"y\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models= False,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": True,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_fun_evals\": 10_000,\n                                      \"log_level\": 50\n                                      })\nspot_tuner.run(X_start=X_start)\n\nspotPython tuning: -0.84375 [#---------] 6.00% \n\n\nspotPython tuning: -0.84375 [#---------] 11.75% \n\n\nspotPython tuning: -0.84375 [#---------] 13.67% \n\n\nspotPython tuning: -0.84375 [##--------] 17.32% \n\n\nspotPython tuning: -0.84375 [##--------] 24.19% \n\n\nspotPython tuning: -0.8645833333333334 [###-------] 29.40% \n\n\nspotPython tuning: -0.8645833333333334 [###-------] 32.20% \n\n\nspotPython tuning: -0.8645833333333334 [####------] 41.42% \n\n\nspotPython tuning: -0.8645833333333334 [#####-----] 45.28% \n\n\nspotPython tuning: -0.8645833333333334 [#####-----] 51.07% \n\n\nspotPython tuning: -0.8645833333333334 [######----] 58.24% \n\n\nspotPython tuning: -0.8645833333333334 [######----] 63.32% \n\n\nspotPython tuning: -0.8645833333333334 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2abe3b6d0&gt;"
  },
  {
    "objectID": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#sec-tensorboard-17",
    "href": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#sec-tensorboard-17",
    "title": "16  HPT: sklearn XGB Classifier VBDP Data",
    "section": "16.9 Step 9: Tensorboard",
    "text": "16.9 Step 9: Tensorboard\nThe textual output shown in the console (or code cell) can be visualized with Tensorboard as described in Section 23.9, see also the description in the documentation: Tensorboard."
  },
  {
    "objectID": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#sec-results-tuning-17",
    "href": "17_spot_hpt_sklearn_multiclass_classification_xgb.html#sec-results-tuning-17",
    "title": "16  HPT: sklearn XGB Classifier VBDP Data",
    "section": "16.10 Step 10: Results",
    "text": "16.10 Step 10: Results\nAfter the hyperparameter tuning run is finished, the progress of the hyperparameter tuning can be visualized. The following code generates the progress plot from ?fig-progress.\n\nspot_tuner.plot_progress(log_y=False,\n    filename=\"./figures/\" + experiment_name+\"_progress.png\")\n\n\n\n\nProgress plot. Black dots denote results from the initial design. Red dots illustrate the improvement found by the surrogate model based optimization.\n\n\n\n\n\nPrint the results\n\n\nprint(gen_design_table(fun_control=fun_control,\n    spot=spot_tuner))\n\n| name              | type   | default   |   lower |   upper |              tuned | transform             |   importance | stars   |\n|-------------------|--------|-----------|---------|---------|--------------------|-----------------------|--------------|---------|\n| loss              | factor | log_loss  |     0.0 |     0.0 |                0.0 | None                  |         0.00 |         |\n| learning_rate     | float  | -1.0      |    -5.0 |     0.0 | -0.744606058195489 | transform_power_10    |        27.45 | *       |\n| max_iter          | int    | 7         |     3.0 |    10.0 |                8.0 | transform_power_2_int |         0.00 |         |\n| max_leaf_nodes    | int    | 5         |     1.0 |    12.0 |               12.0 | transform_power_2_int |         5.87 | *       |\n| max_depth         | int    | 2         |     1.0 |    20.0 |                2.0 | transform_power_2_int |         0.00 |         |\n| min_samples_leaf  | int    | 4         |     2.0 |    10.0 |                2.0 | transform_power_2_int |       100.00 | ***     |\n| l2_regularization | float  | 0.0       |     0.0 |    10.0 |                0.0 | None                  |         0.00 |         |\n| max_bins          | int    | 255       |   127.0 |   255.0 |              204.0 | None                  |         0.00 |         |\n| early_stopping    | factor | 1         |     0.0 |     1.0 |                1.0 | None                  |         0.26 | .       |\n| n_iter_no_change  | int    | 10        |     5.0 |    20.0 |               20.0 | None                  |         0.00 |         |\n| tol               | float  | 0.0001    |   1e-05 |   0.001 |              0.001 | None                  |         0.00 |         |\n\n\n\n16.10.1 Show variable importance\n\nspot_tuner.plot_importance(threshold=0.025, filename=\"./figures/\" + experiment_name+\"_importance.png\")\n\n\n\n\nVariable importance plot, threshold 0.025.\n\n\n\n\n\n\n16.10.2 Get Default Hyperparameters\n\nfrom spotPython.hyperparameters.values import get_default_values, transform_hyper_parameter_values\nvalues_default = get_default_values(fun_control)\nvalues_default = transform_hyper_parameter_values(fun_control=fun_control, hyper_parameter_values=values_default)\nvalues_default\n\n{'loss': 'log_loss',\n 'learning_rate': 0.1,\n 'max_iter': 128,\n 'max_leaf_nodes': 32,\n 'max_depth': 4,\n 'min_samples_leaf': 16,\n 'l2_regularization': 0.0,\n 'max_bins': 255,\n 'early_stopping': 1,\n 'n_iter_no_change': 10,\n 'tol': 0.0001}\n\n\n\nfrom sklearn.pipeline import make_pipeline\nmodel_default = make_pipeline(fun_control[\"prep_model\"], fun_control[\"core_model\"](**values_default))\nmodel_default\n\nPipeline(steps=[('nonetype', None),\n                ('histgradientboostingclassifier',\n                 HistGradientBoostingClassifier(early_stopping=1, max_depth=4,\n                                                max_iter=128, max_leaf_nodes=32,\n                                                min_samples_leaf=16,\n                                                tol=0.0001))])In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.PipelinePipeline(steps=[('nonetype', None),\n                ('histgradientboostingclassifier',\n                 HistGradientBoostingClassifier(early_stopping=1, max_depth=4,\n                                                max_iter=128, max_leaf_nodes=32,\n                                                min_samples_leaf=16,\n                                                tol=0.0001))])NoneNoneHistGradientBoostingClassifierHistGradientBoostingClassifier(early_stopping=1, max_depth=4, max_iter=128,\n                               max_leaf_nodes=32, min_samples_leaf=16,\n                               tol=0.0001)\n\n\n\n\n16.10.3 Get SPOT Results\n\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nprint(X)\n\n[[ 0.00000000e+00 -7.44606058e-01  8.00000000e+00  1.20000000e+01\n   2.00000000e+00  2.00000000e+00  0.00000000e+00  2.04000000e+02\n   1.00000000e+00  2.00000000e+01  1.00000000e-03]]\n\n\n\nfrom spotPython.hyperparameters.values import assign_values, return_conf_list_from_var_dict\nv_dict = assign_values(X, fun_control[\"var_name\"])\nreturn_conf_list_from_var_dict(var_dict=v_dict, fun_control=fun_control)\n\n[{'loss': 'log_loss',\n  'learning_rate': 0.1800503383382619,\n  'max_iter': 256,\n  'max_leaf_nodes': 4096,\n  'max_depth': 4,\n  'min_samples_leaf': 4,\n  'l2_regularization': 0.0,\n  'max_bins': 204,\n  'early_stopping': 1,\n  'n_iter_no_change': 20,\n  'tol': 0.001}]\n\n\n\nfrom spotPython.hyperparameters.values import get_one_sklearn_model_from_X\nmodel_spot = get_one_sklearn_model_from_X(X, fun_control)\nmodel_spot\n\nHistGradientBoostingClassifier(early_stopping=1,\n                               learning_rate=0.1800503383382619, max_bins=204,\n                               max_depth=4, max_iter=256, max_leaf_nodes=4096,\n                               min_samples_leaf=4, n_iter_no_change=20,\n                               tol=0.001)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.HistGradientBoostingClassifierHistGradientBoostingClassifier(early_stopping=1,\n                               learning_rate=0.1800503383382619, max_bins=204,\n                               max_depth=4, max_iter=256, max_leaf_nodes=4096,\n                               min_samples_leaf=4, n_iter_no_change=20,\n                               tol=0.001)\n\n\n\n\n16.10.4 Evaluate SPOT Results\n\nFetch the data.\n\n\nfrom spotPython.utils.convert import get_Xy_from_df\nX_train, y_train = get_Xy_from_df(fun_control[\"train\"], fun_control[\"target_column\"])\nX_test, y_test = get_Xy_from_df(fun_control[\"test\"], fun_control[\"target_column\"])\nX_test.shape, y_test.shape\n\n((63, 64), (63,))\n\n\n\nFit the model with the tuned hyperparameters. This gives one result:\n\n\nmodel_spot.fit(X_train, y_train)\ny_pred = model_spot.predict_proba(X_test)\nres = mapk_score(y_true=y_test, y_pred=y_pred, k=3)\nres\n\n0.8042328042328042\n\n\n\ndef repeated_eval(n, model):\n    res_values = []\n    for i in range(n):\n        model.fit(X_train, y_train)\n        y_pred = model.predict_proba(X_test)\n        res = mapk_score(y_true=y_test, y_pred=y_pred, k=3)\n        res_values.append(res)\n    mean_res = np.mean(res_values)\n    print(f\"mean_res: {mean_res}\")\n    std_res = np.std(res_values)\n    print(f\"std_res: {std_res}\")\n    min_res = np.min(res_values)\n    print(f\"min_res: {min_res}\")\n    max_res = np.max(res_values)\n    print(f\"max_res: {max_res}\")\n    median_res = np.median(res_values)\n    print(f\"median_res: {median_res}\")\n    return mean_res, std_res, min_res, max_res, median_res\n\n\n\n16.10.5 Handling Non-deterministic Results\n\nBecause the model is non-determinstic, we perform \\(n=30\\) runs and calculate the mean and standard deviation of the performance metric.\n\n\n_ = repeated_eval(30, model_spot)\n\nmean_res: 0.7902998236331571\nstd_res: 0.013066628883239135\nmin_res: 0.7671957671957672\nmax_res: 0.8148148148148149\nmedian_res: 0.7910052910052909\n\n\n\n\n16.10.6 Evalution of the Default Hyperparameters\n\nmodel_default.fit(X_train, y_train)[\"histgradientboostingclassifier\"]\n\nHistGradientBoostingClassifier(early_stopping=1, max_depth=4, max_iter=128,\n                               max_leaf_nodes=32, min_samples_leaf=16,\n                               tol=0.0001)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.HistGradientBoostingClassifierHistGradientBoostingClassifier(early_stopping=1, max_depth=4, max_iter=128,\n                               max_leaf_nodes=32, min_samples_leaf=16,\n                               tol=0.0001)\n\n\n\nOne evaluation of the default hyperparameters is performed on the hold-out test set.\n\n\ny_pred = model_default.predict_proba(X_test)\nmapk_score(y_true=y_test, y_pred=y_pred, k=3)\n\n0.7989417989417988\n\n\nSince one single evaluation is not meaningful, we perform, similar to the evaluation of the SPOT results, \\(n=30\\) runs of the default setting and and calculate the mean and standard deviation of the performance metric.\n\n_ = repeated_eval(30, model_default)\n\nmean_res: 0.7944444444444444\nstd_res: 0.014873748991397446\nmin_res: 0.7592592592592592\nmax_res: 0.8253968253968255\nmedian_res: 0.7962962962962963\n\n\n\n\n16.10.7 Plot: Compare Predictions\n\nfrom spotPython.plot.validation import plot_confusion_matrix\nplot_confusion_matrix(model=model_default, fun_control=fun_control, title = \"Default\")\n\n\n\n\n\nplot_confusion_matrix(model=model_spot, fun_control=fun_control, title=\"SPOT\")\n\n\n\n\n\nmin(spot_tuner.y), max(spot_tuner.y)\n\n(-0.8645833333333334, -0.06944444444444443)\n\n\n\n\n16.10.8 Cross-validated Evaluations\n\nfrom spotPython.sklearn.traintest import evaluate_cv\nfun_control.update({\n     \"eval\": \"train_cv\",\n     \"k_folds\": 10,\n})\nevaluate_cv(model=model_spot, fun_control=fun_control, verbose=0)\n\n(0.8232456140350877, None)\n\n\n\nfun_control.update({\n     \"eval\": \"test_cv\",\n     \"k_folds\": 10,\n})\nevaluate_cv(model=model_spot, fun_control=fun_control, verbose=0)\n\nError in fun_sklearn(). Call to evaluate_cv failed. err=ValueError('n_splits=10 cannot be greater than the number of members in each class.'), type(err)=&lt;class 'ValueError'&gt;\n\n\n(nan, None)\n\n\n\nThis is the evaluation that will be used in the comparison:\n\n\nfun_control.update({\n     \"eval\": \"data_cv\",\n     \"k_folds\": 10,\n})\nevaluate_cv(model=model_spot, fun_control=fun_control, verbose=0)\n\n(0.833025641025641, None)\n\n\n\n\n16.10.9 Detailed Hyperparameter Plots\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)\n\nlearning_rate:  27.45172557028981\nmax_leaf_nodes:  5.871319807508677\nmin_samples_leaf:  99.99999999999999\nearly_stopping:  0.2573930368718061\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n16.10.10 Parallel Coordinates Plot\n\nspot_tuner.parallel_plot()\n\n\n                                                \n\n\n\n\n16.10.11 Plot all Combinations of Hyperparameters\n\nWarning: this may take a while.\n\n\nPLOT_ALL = False\nif PLOT_ALL:\n    n = spot_tuner.k\n    for i in range(n-1):\n        for j in range(i+1, n):\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z)"
  },
  {
    "objectID": "18_spot_hpt_sklearn_multiclass_classification_svc.html#sec-setup-18",
    "href": "18_spot_hpt_sklearn_multiclass_classification_svc.html#sec-setup-18",
    "title": "17  HPT: sklearn SVC VBDP Data",
    "section": "17.1 Step 1: Setup",
    "text": "17.1 Step 1: Setup\nBefore we consider the detailed experimental setup, we select the parameters that affect run time and the initial design size.\n\nMAX_TIME = 1\nINIT_SIZE = 5\nORIGINAL = True\nPREFIX = \"18\"\n\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")"
  },
  {
    "objectID": "18_spot_hpt_sklearn_multiclass_classification_svc.html#step-2-initialization-of-the-empty-fun_control-dictionary",
    "href": "18_spot_hpt_sklearn_multiclass_classification_svc.html#step-2-initialization-of-the-empty-fun_control-dictionary",
    "title": "17  HPT: sklearn SVC VBDP Data",
    "section": "17.2 Step 2: Initialization of the Empty fun_control Dictionary",
    "text": "17.2 Step 2: Initialization of the Empty fun_control Dictionary\n\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_experiment_name, get_spot_tensorboard_path\nfrom spotPython.utils.device import getDevice\n\nexperiment_name = get_experiment_name(prefix=PREFIX)\n\nfun_control = fun_control_init(\n    task=\"classification\",\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name))"
  },
  {
    "objectID": "18_spot_hpt_sklearn_multiclass_classification_svc.html#step-3-pytorch-data-loading",
    "href": "18_spot_hpt_sklearn_multiclass_classification_svc.html#step-3-pytorch-data-loading",
    "title": "17  HPT: sklearn SVC VBDP Data",
    "section": "17.3 Step 3: PyTorch Data Loading",
    "text": "17.3 Step 3: PyTorch Data Loading\n\n17.3.1 1. Load Data: Classification VBDP\n\nimport pandas as pd\nif ORIGINAL == True:\n    train_df = pd.read_csv('./data/VBDP/trainn.csv')\n    test_df = pd.read_csv('./data/VBDP/testt.csv')\nelse:\n    train_df = pd.read_csv('./data/VBDP/train.csv')\n    # remove the id column\n    train_df = train_df.drop(columns=['id'])\n\n\nfrom sklearn.preprocessing import OrdinalEncoder\nn_samples = train_df.shape[0]\nn_features = train_df.shape[1] - 1\ntarget_column = \"prognosis\"\n# Encoder our prognosis labels as integers for easier decoding later\nenc = OrdinalEncoder()\ntrain_df[target_column] = enc.fit_transform(train_df[[target_column]])\ntrain_df.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\nprint(train_df.shape)\ntrain_df.head()\n\n(252, 65)\n\n\n\n\n\n\n\n\n\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n...\nx56\nx57\nx58\nx59\nx60\nx61\nx62\nx63\nx64\nprognosis\n\n\n\n\n0\n0\n1\n1\n1\n1\n0\n1\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n1\n1\n1\n1\n1\n1\n0\n1\n1\n1\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n2\n0\n1\n0\n1\n0\n0\n1\n1\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n3\n0\n0\n0\n0\n0\n1\n1\n1\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n4\n1\n0\n0\n0\n1\n1\n1\n1\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n\n\n5 rows × 65 columns\n\n\n\nThe full data set train_df 64 features. The target column is labeled as prognosis.\n\n\n17.3.2 Holdout Train and Test Data\nWe split out a hold-out test set (25% of the data) so we can calculate an example MAP@K\n\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(train_df.drop(target_column, axis=1), train_df[target_column],\n                                                    random_state=42,\n                                                    test_size=0.25,\n                                                    stratify=train_df[target_column])\ntrain = pd.DataFrame(np.hstack((X_train, np.array(y_train).reshape(-1, 1))))\ntest = pd.DataFrame(np.hstack((X_test, np.array(y_test).reshape(-1, 1))))\ntrain.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\ntest.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\nprint(train.shape)\nprint(test.shape)\ntrain.head()\n\n(189, 65)\n(63, 65)\n\n\n\n\n\n\n\n\n\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n...\nx56\nx57\nx58\nx59\nx60\nx61\nx62\nx63\nx64\nprognosis\n\n\n\n\n0\n1.0\n0.0\n0.0\n1.0\n0.0\n1.0\n0.0\n0.0\n0.0\n1.0\n...\n0.0\n0.0\n0.0\n0.0\n1.0\n1.0\n1.0\n0.0\n0.0\n7.0\n\n\n1\n1.0\n0.0\n1.0\n1.0\n1.0\n1.0\n1.0\n0.0\n1.0\n1.0\n...\n0.0\n1.0\n1.0\n1.0\n1.0\n0.0\n1.0\n1.0\n1.0\n3.0\n\n\n2\n0.0\n0.0\n1.0\n0.0\n1.0\n0.0\n0.0\n0.0\n0.0\n0.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n10.0\n\n\n3\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n0.0\n0.0\n1.0\n1.0\n...\n1.0\n0.0\n1.0\n1.0\n1.0\n0.0\n0.0\n1.0\n1.0\n3.0\n\n\n4\n1.0\n1.0\n1.0\n0.0\n1.0\n1.0\n0.0\n1.0\n1.0\n0.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n8.0\n\n\n\n\n5 rows × 65 columns\n\n\n\n\n# add the dataset to the fun_control\nfun_control.update({\"data\": train_df, # full dataset,\n               \"train\": train,\n               \"test\": test,\n               \"n_samples\": n_samples,\n               \"target_column\": target_column})"
  },
  {
    "objectID": "18_spot_hpt_sklearn_multiclass_classification_svc.html#sec-specification-of-preprocessing-model-18",
    "href": "18_spot_hpt_sklearn_multiclass_classification_svc.html#sec-specification-of-preprocessing-model-18",
    "title": "17  HPT: sklearn SVC VBDP Data",
    "section": "17.4 Step 4: Specification of the Preprocessing Model",
    "text": "17.4 Step 4: Specification of the Preprocessing Model\nData preprocesssing can be very simple, e.g., you can ignore it. Then you would choose the prep_model “None”:\n\nprep_model = None\nfun_control.update({\"prep_model\": prep_model})\n\nA default approach for numerical data is the StandardScaler (mean 0, variance 1). This can be selected as follows:\n\n# prep_model = StandardScaler()\n# fun_control.update({\"prep_model\": prep_model})\n\nEven more complicated pre-processing steps are possible, e.g., the follwing pipeline:\n\n# categorical_columns = []\n# one_hot_encoder = OneHotEncoder(handle_unknown=\"ignore\", sparse_output=False)\n# prep_model = ColumnTransformer(\n#         transformers=[\n#             (\"categorical\", one_hot_encoder, categorical_columns),\n#         ],\n#         remainder=StandardScaler(),\n#     )"
  },
  {
    "objectID": "18_spot_hpt_sklearn_multiclass_classification_svc.html#step-5-select-model-algorithm-and-core_model_hyper_dict",
    "href": "18_spot_hpt_sklearn_multiclass_classification_svc.html#step-5-select-model-algorithm-and-core_model_hyper_dict",
    "title": "17  HPT: sklearn SVC VBDP Data",
    "section": "17.5 Step 5: Select Model (algorithm) and core_model_hyper_dict",
    "text": "17.5 Step 5: Select Model (algorithm) and core_model_hyper_dict\nThe selection of the algorithm (ML model) that should be tuned is done by specifying the its name from the sklearn implementation. For example, the SVC support vector machine classifier is selected as follows:\nadd_core_model_to_fun_control(SVC, fun_control, SklearnHyperDict)\nOther core_models are, e.g.,:\n\nRidgeCV\nGradientBoostingRegressor\nElasticNet\nRandomForestClassifier\nLogisticRegression\nKNeighborsClassifier\nRandomForestClassifier\nGradientBoostingClassifier\nHistGradientBoostingClassifier\n\nWe will use the RandomForestClassifier classifier in this example.\n\nfrom sklearn.linear_model import RidgeCV\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.ensemble import HistGradientBoostingClassifier\nfrom sklearn.linear_model import ElasticNet\nfrom spotPython.hyperparameters.values import add_core_model_to_fun_control\nfrom spotPython.data.sklearn_hyper_dict import SklearnHyperDict\nfrom spotPython.fun.hypersklearn import HyperSklearn\n\n\n# core_model  = RidgeCV\n# core_model = GradientBoostingRegressor\n# core_model = ElasticNet\n# core_model = RandomForestClassifier\ncore_model = SVC\n# core_model = LogisticRegression\n# core_model = KNeighborsClassifier\n# core_model = GradientBoostingClassifier\n# core_model = HistGradientBoostingClassifier\nadd_core_model_to_fun_control(core_model=core_model,\n                              fun_control=fun_control,\n                              hyper_dict=SklearnHyperDict,\n                              filename=None)\n\nNow fun_control has the information from the JSON file. The available hyperparameters are:\n\nprint(*fun_control[\"core_model_hyper_dict\"].keys(), sep=\"\\n\")\n\nC\nkernel\ndegree\ngamma\ncoef0\nshrinking\nprobability\ntol\ncache_size\nbreak_ties"
  },
  {
    "objectID": "18_spot_hpt_sklearn_multiclass_classification_svc.html#step-6-modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "href": "18_spot_hpt_sklearn_multiclass_classification_svc.html#step-6-modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "title": "17  HPT: sklearn SVC VBDP Data",
    "section": "17.6 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model",
    "text": "17.6 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\n\n17.6.1 Modify hyperparameter of type numeric and integer (boolean)\nNumeric and boolean values can be modified using the modify_hyper_parameter_bounds method. For example, to change the tol hyperparameter of the SVC model to the interval [1e-3, 1e-2], the following code can be used:\nmodify_hyper_parameter_bounds(fun_control, \"tol\", bounds=[1e-3, 1e-2])\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_bounds\nmodify_hyper_parameter_bounds(fun_control, \"probability\", bounds=[1, 1])\n\n\n\n17.6.2 Modify hyperparameter of type factor\nspotPython provides functions for modifying the hyperparameters, their bounds and factors as well as for activating and de-activating hyperparameters without re-compilation of the Python source code. These functions were described in Section 23.6.\nFactors can be modified with the modify_hyper_parameter_levels function. For example, to exclude the sigmoid kernel from the tuning, the kernel hyperparameter of the SVC model can be modified as follows:\nmodify_hyper_parameter_levels(fun_control, \"kernel\", [\"linear\", \"rbf\"])\nThe new setting can be controlled via:\nfun_control[\"core_model_hyper_dict\"][\"kernel\"]\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_levels\nmodify_hyper_parameter_levels(fun_control, \"kernel\", [\"rbf\"])\n\n\n\n17.6.3 Optimizers\nOptimizers are described in Section 23.6.1.\n\n\n17.6.4 Selection of the Objective: Metric and Loss Functions\n\nMachine learning models are optimized with respect to a metric, for example, the accuracy function.\nDeep learning, e.g., neural networks are optimized with respect to a loss function, for example, the cross_entropy function and evaluated with respect to a metric, for example, the accuracy function."
  },
  {
    "objectID": "18_spot_hpt_sklearn_multiclass_classification_svc.html#step-7-selection-of-the-objective-loss-function",
    "href": "18_spot_hpt_sklearn_multiclass_classification_svc.html#step-7-selection-of-the-objective-loss-function",
    "title": "17  HPT: sklearn SVC VBDP Data",
    "section": "17.7 Step 7: Selection of the Objective (Loss) Function",
    "text": "17.7 Step 7: Selection of the Objective (Loss) Function\nThe loss function, that is usually used in deep learning for optimizing the weights of the net, is stored in the fun_control dictionary as \"loss_function\".\n\n17.7.1 Metric Function\nThere are two different types of metrics in spotPython:\n\n\"metric_river\" is used for the river based evaluation via eval_oml_iter_progressive.\n\"metric_sklearn\" is used for the sklearn based evaluation.\n\nWe will consider multi-class classification metrics, e.g., mapk_score and top_k_accuracy_score.\n\n\n\n\n\n\nPredict Probabilities\n\n\n\nIn this multi-class classification example the machine learning algorithm should return the probabilities of the specific classes (\"predict_proba\") instead of the predicted values.\n\n\nWe set \"predict_proba\" to True in the fun_control dictionary.\n\n17.7.1.1 The MAPK Metric\nTo select the MAPK metric, the following two entries can be added to the fun_control dictionary:\n\"metric_sklearn\": mapk_score\"\n\"metric_params\": {\"k\": 3}.\n\n\n17.7.1.2 Other Metrics\nAlternatively, other metrics for multi-class classification can be used, e.g.,: * top_k_accuracy_score or * roc_auc_score\nThe metric roc_auc_score requires the parameter \"multi_class\", e.g.,\n\"multi_class\": \"ovr\".\nThis is set in the fun_control dictionary.\n\n\n\n\n\n\nWeights\n\n\n\nspotPython performs a minimization, therefore, metrics that should be maximized have to be multiplied by -1. This is done by setting \"weights\" to -1.\n\n\n\nThe complete setup for the metric in our example is:\n\n\nfrom spotPython.utils.metrics import mapk_score\nfun_control.update({\n               \"weights\": -1,\n               \"metric_sklearn\": mapk_score,\n               \"predict_proba\": True,\n               \"metric_params\": {\"k\": 3},\n               })\n\n\n\n\n17.7.2 Evaluation on Hold-out Data\n\nThe default method for computing the performance is \"eval_holdout\".\nAlternatively, cross-validation can be used for every machine learning model.\nSpecifically for RandomForests, the OOB-score can be used.\n\n\nfun_control.update({\n    \"eval\": \"train_hold_out\",\n})\n\n\n17.7.2.1 Cross Validation\nInstead of using the OOB-score, the classical cross validation can be used. The number of folds is set by the key \"k_folds\". For example, to use 5-fold cross validation, the key \"k_folds\" is set to 5. Uncomment the following line to use cross validation:\n\n# fun_control.update({\n#      \"eval\": \"train_cv\",\n#      \"k_folds\": 10,\n# })"
  },
  {
    "objectID": "18_spot_hpt_sklearn_multiclass_classification_svc.html#step-8-calling-the-spot-function",
    "href": "18_spot_hpt_sklearn_multiclass_classification_svc.html#step-8-calling-the-spot-function",
    "title": "17  HPT: sklearn SVC VBDP Data",
    "section": "17.8 Step 8: Calling the SPOT Function",
    "text": "17.8 Step 8: Calling the SPOT Function\n\n17.8.1 Preparing the SPOT Call\n\nGet types and variable names as well as lower and upper bounds for the hyperparameters.\n\n\n# extract the variable types, names, and bounds\nfrom spotPython.hyperparameters.values import (get_bound_values,\n    get_var_name,\n    get_var_type,)\nvar_type = get_var_type(fun_control)\nvar_name = get_var_name(fun_control)\nlower = get_bound_values(fun_control, \"lower\")\nupper = get_bound_values(fun_control, \"upper\")\n\n\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control))\n\n| name        | type   | default   |    lower |   upper | transform   |\n|-------------|--------|-----------|----------|---------|-------------|\n| C           | float  | 1.0       |   0.1    |   10    | None        |\n| kernel      | factor | rbf       |   0      |    0    | None        |\n| degree      | int    | 3         |   3      |    3    | None        |\n| gamma       | factor | scale     |   0      |    1    | None        |\n| coef0       | float  | 0.0       |   0      |    0    | None        |\n| shrinking   | factor | 0         |   0      |    1    | None        |\n| probability | factor | 0         |   1      |    1    | None        |\n| tol         | float  | 0.001     |   0.0001 |    0.01 | None        |\n| cache_size  | float  | 200.0     | 100      |  400    | None        |\n| break_ties  | factor | 0         |   0      |    1    | None        |\n\n\n\n\n17.8.2 The Objective Function\nThe objective function is selected next. It implements an interface from sklearn’s training, validation, and testing methods to spotPython.\n\nfrom spotPython.fun.hypersklearn import HyperSklearn\nfun = HyperSklearn().fun_sklearn\n\n\n\n17.8.3 Run the Spot Optimizer\n\nRun SPOT for approx. x mins (max_time).\nNote: the run takes longer, because the evaluation time of initial design (here: initi_size, 20 points) is not considered.\n\n\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nX_start = get_default_hyperparameters_as_array(fun_control)\nX_start\n\narray([[1.e+00, 0.e+00, 3.e+00, 0.e+00, 0.e+00, 0.e+00, 0.e+00, 1.e-03,\n        2.e+02, 0.e+00]])\n\n\n\nimport numpy as np\nfrom spotPython.spot import spot\nfrom math import inf\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   fun_repeats = 1,\n                   max_time = MAX_TIME,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   infill_criterion = \"y\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models= False,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": True,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_fun_evals\": 10_000,\n                                      \"log_level\": 50\n                                      })\nspot_tuner.run(X_start=X_start)\n\nspotPython tuning: -0.875 [----------] 0.56% \n\n\nspotPython tuning: -0.875 [----------] 1.12% \n\n\nspotPython tuning: -0.875 [----------] 1.56% \n\n\nspotPython tuning: -0.875 [----------] 1.96% \n\n\nspotPython tuning: -0.875 [----------] 2.83% \n\n\nspotPython tuning: -0.875 [----------] 3.40% \n\n\nspotPython tuning: -0.875 [----------] 4.19% \n\n\nspotPython tuning: -0.875 [#---------] 5.06% \n\n\nspotPython tuning: -0.875 [#---------] 5.92% \n\n\nspotPython tuning: -0.875 [#---------] 7.23% \n\n\nspotPython tuning: -0.875 [#---------] 8.65% \n\n\nspotPython tuning: -0.875 [#---------] 9.31% \n\n\nspotPython tuning: -0.875 [##--------] 21.34% \n\n\nspotPython tuning: -0.875 [###-------] 34.72% \n\n\nspotPython tuning: -0.875 [######----] 55.38% \n\n\nspotPython tuning: -0.875 [########--] 76.45% \n\n\nspotPython tuning: -0.875 [#########-] 86.55% \n\n\nspotPython tuning: -0.875 [#########-] 94.42% \n\n\nspotPython tuning: -0.875 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2b84e8490&gt;"
  },
  {
    "objectID": "18_spot_hpt_sklearn_multiclass_classification_svc.html#sec-tensorboard-18",
    "href": "18_spot_hpt_sklearn_multiclass_classification_svc.html#sec-tensorboard-18",
    "title": "17  HPT: sklearn SVC VBDP Data",
    "section": "17.9 Step 9: Tensorboard",
    "text": "17.9 Step 9: Tensorboard\nThe textual output shown in the console (or code cell) can be visualized with Tensorboard as described in Section 23.9, see also the description in the documentation: Tensorboard."
  },
  {
    "objectID": "18_spot_hpt_sklearn_multiclass_classification_svc.html#sec-results-tuning-18",
    "href": "18_spot_hpt_sklearn_multiclass_classification_svc.html#sec-results-tuning-18",
    "title": "17  HPT: sklearn SVC VBDP Data",
    "section": "17.10 Step 10: Results",
    "text": "17.10 Step 10: Results\nAfter the hyperparameter tuning run is finished, the progress of the hyperparameter tuning can be visualized. The following code generates the progress plot from ?fig-progress.\n\nspot_tuner.plot_progress(log_y=False,\n    filename=\"./figures/\" + experiment_name+\"_progress.png\")\n\n\n\n\nProgress plot. Black dots denote results from the initial design. Red dots illustrate the improvement found by the surrogate model based optimization.\n\n\n\n\n\nPrint the results\n\n\nprint(gen_design_table(fun_control=fun_control,\n    spot=spot_tuner))\n\n| name        | type   | default   |   lower |   upper |                 tuned | transform   |   importance | stars   |\n|-------------|--------|-----------|---------|---------|-----------------------|-------------|--------------|---------|\n| C           | float  | 1.0       |     0.1 |    10.0 |     8.648943310768674 | None        |         0.02 |         |\n| kernel      | factor | rbf       |     0.0 |     0.0 |                   0.0 | None        |         0.00 |         |\n| degree      | int    | 3         |     3.0 |     3.0 |                   3.0 | None        |         0.00 |         |\n| gamma       | factor | scale     |     0.0 |     1.0 |                   1.0 | None        |         0.05 |         |\n| coef0       | float  | 0.0       |     0.0 |     0.0 |                   0.0 | None        |         0.00 |         |\n| shrinking   | factor | 0         |     0.0 |     1.0 |                   0.0 | None        |         0.00 |         |\n| probability | factor | 0         |     1.0 |     1.0 |                   1.0 | None        |         0.00 |         |\n| tol         | float  | 0.001     |  0.0001 |    0.01 | 0.0036949438148166343 | None        |         0.18 | .       |\n| cache_size  | float  | 200.0     |   100.0 |   400.0 |    389.44564593489815 | None        |         0.00 |         |\n| break_ties  | factor | 0         |     0.0 |     1.0 |                   0.0 | None        |       100.00 | ***     |\n\n\n\n17.10.1 Show variable importance\n\nspot_tuner.plot_importance(threshold=0.025, filename=\"./figures/\" + experiment_name+\"_importance.png\")\n\n\n\n\nVariable importance plot, threshold 0.025.\n\n\n\n\n\n\n17.10.2 Get Default Hyperparameters\n\nfrom spotPython.hyperparameters.values import get_default_values, transform_hyper_parameter_values\nvalues_default = get_default_values(fun_control)\nvalues_default = transform_hyper_parameter_values(fun_control=fun_control, hyper_parameter_values=values_default)\nvalues_default\n\n{'C': 1.0,\n 'kernel': 'rbf',\n 'degree': 3,\n 'gamma': 'scale',\n 'coef0': 0.0,\n 'shrinking': 0,\n 'probability': 0,\n 'tol': 0.001,\n 'cache_size': 200.0,\n 'break_ties': 0}\n\n\n\nfrom sklearn.pipeline import make_pipeline\nmodel_default = make_pipeline(fun_control[\"prep_model\"], fun_control[\"core_model\"](**values_default))\nmodel_default\n\nPipeline(steps=[('nonetype', None),\n                ('svc',\n                 SVC(break_ties=0, cache_size=200.0, probability=0,\n                     shrinking=0))])In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.PipelinePipeline(steps=[('nonetype', None),\n                ('svc',\n                 SVC(break_ties=0, cache_size=200.0, probability=0,\n                     shrinking=0))])NoneNoneSVCSVC(break_ties=0, cache_size=200.0, probability=0, shrinking=0)\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nDefault value for “probability” is False, but we need it to be True for the metric “mapk_score”.\n\n\nvalues_default.update({\"probability\": 1})\n\n\n\n\n\n17.10.3 Get SPOT Results\n\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nprint(X)\n\n[[8.64894331e+00 0.00000000e+00 3.00000000e+00 1.00000000e+00\n  0.00000000e+00 0.00000000e+00 1.00000000e+00 3.69494381e-03\n  3.89445646e+02 0.00000000e+00]]\n\n\n\nfrom spotPython.hyperparameters.values import assign_values, return_conf_list_from_var_dict\nv_dict = assign_values(X, fun_control[\"var_name\"])\nreturn_conf_list_from_var_dict(var_dict=v_dict, fun_control=fun_control)\n\n[{'C': 8.648943310768674,\n  'kernel': 'rbf',\n  'degree': 3,\n  'gamma': 'auto',\n  'coef0': 0.0,\n  'shrinking': 0,\n  'probability': 1,\n  'tol': 0.0036949438148166343,\n  'cache_size': 389.44564593489815,\n  'break_ties': 0}]\n\n\n\nfrom spotPython.hyperparameters.values import get_one_sklearn_model_from_X\nmodel_spot = get_one_sklearn_model_from_X(X, fun_control)\nmodel_spot\n\nSVC(C=8.648943310768674, break_ties=0, cache_size=389.44564593489815,\n    gamma='auto', probability=1, shrinking=0, tol=0.0036949438148166343)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.SVCSVC(C=8.648943310768674, break_ties=0, cache_size=389.44564593489815,\n    gamma='auto', probability=1, shrinking=0, tol=0.0036949438148166343)\n\n\n\n\n17.10.4 Evaluate SPOT Results\n\nFetch the data.\n\n\nfrom spotPython.utils.convert import get_Xy_from_df\nX_train, y_train = get_Xy_from_df(fun_control[\"train\"], fun_control[\"target_column\"])\nX_test, y_test = get_Xy_from_df(fun_control[\"test\"], fun_control[\"target_column\"])\nX_test.shape, y_test.shape\n\n((63, 64), (63,))\n\n\n\nFit the model with the tuned hyperparameters. This gives one result:\n\n\nmodel_spot.fit(X_train, y_train)\ny_pred = model_spot.predict_proba(X_test)\nres = mapk_score(y_true=y_test, y_pred=y_pred, k=3)\nres\n\n0.8544973544973545\n\n\n\ndef repeated_eval(n, model):\n    res_values = []\n    for i in range(n):\n        model.fit(X_train, y_train)\n        y_pred = model.predict_proba(X_test)\n        res = mapk_score(y_true=y_test, y_pred=y_pred, k=3)\n        res_values.append(res)\n    mean_res = np.mean(res_values)\n    print(f\"mean_res: {mean_res}\")\n    std_res = np.std(res_values)\n    print(f\"std_res: {std_res}\")\n    min_res = np.min(res_values)\n    print(f\"min_res: {min_res}\")\n    max_res = np.max(res_values)\n    print(f\"max_res: {max_res}\")\n    median_res = np.median(res_values)\n    print(f\"median_res: {median_res}\")\n    return mean_res, std_res, min_res, max_res, median_res\n\n\n\n17.10.5 Handling Non-deterministic Results\n\nBecause the model is non-determinstic, we perform \\(n=30\\) runs and calculate the mean and standard deviation of the performance metric.\n\n\n_ = repeated_eval(30, model_spot)\n\nmean_res: 0.8485890652557321\nstd_res: 0.004667061242468859\nmin_res: 0.8386243386243385\nmax_res: 0.8571428571428571\nmedian_res: 0.8465608465608466\n\n\n\n\n17.10.6 Evalution of the Default Hyperparameters\n\nmodel_default[\"svc\"].probability = True\nmodel_default.fit(X_train, y_train)[\"svc\"]\n\nSVC(break_ties=0, cache_size=200.0, probability=True, shrinking=0)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.SVCSVC(break_ties=0, cache_size=200.0, probability=True, shrinking=0)\n\n\n\nOne evaluation of the default hyperparameters is performed on the hold-out test set.\n\n\ny_pred = model_default.predict_proba(X_test)\nmapk_score(y_true=y_test, y_pred=y_pred, k=3)\n\n0.8492063492063492\n\n\nSince one single evaluation is not meaningful, we perform, similar to the evaluation of the SPOT results, \\(n=30\\) runs of the default setting and and calculate the mean and standard deviation of the performance metric.\n\n_ = repeated_eval(30, model_default)\n\nmean_res: 0.8536155202821868\nstd_res: 0.004391498976362864\nmin_res: 0.8492063492063492\nmax_res: 0.8650793650793651\nmedian_res: 0.8558201058201058\n\n\n\n\n17.10.7 Plot: Compare Predictions\n\nfrom spotPython.plot.validation import plot_confusion_matrix\nplot_confusion_matrix(model=model_default, fun_control=fun_control, title = \"Default\")\n\n\n\n\n\nplot_confusion_matrix(model=model_spot, fun_control=fun_control, title=\"SPOT\")\n\n\n\n\n\nmin(spot_tuner.y), max(spot_tuner.y)\n\n(-0.875, -0.6631944444444444)\n\n\n\n\n17.10.8 Cross-validated Evaluations\n\nfrom spotPython.sklearn.traintest import evaluate_cv\nfun_control.update({\n     \"eval\": \"train_cv\",\n     \"k_folds\": 10,\n})\nevaluate_cv(model=model_spot, fun_control=fun_control, verbose=0)\n\n(0.8485867446393762, None)\n\n\n\nfun_control.update({\n     \"eval\": \"test_cv\",\n     \"k_folds\": 10,\n})\nevaluate_cv(model=model_spot, fun_control=fun_control, verbose=0)\n\nError in fun_sklearn(). Call to evaluate_cv failed. err=ValueError('n_splits=10 cannot be greater than the number of members in each class.'), type(err)=&lt;class 'ValueError'&gt;\n\n\n(nan, None)\n\n\n\nThis is the evaluation that will be used in the comparison:\n\n\nfun_control.update({\n     \"eval\": \"data_cv\",\n     \"k_folds\": 10,\n})\nevaluate_cv(model=model_spot, fun_control=fun_control, verbose=0)\n\n(0.8807179487179487, None)\n\n\n\n\n17.10.9 Detailed Hyperparameter Plots\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)\n\ngamma:  0.04915909690121998\ntol:  0.18198198209192173\nbreak_ties:  100.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n17.10.10 Parallel Coordinates Plot\n\nspot_tuner.parallel_plot(show=False)\n\n\n                                                \n\n\n\n\n17.10.11 Plot all Combinations of Hyperparameters\n\nWarning: this may take a while.\n\n\nPLOT_ALL = False\nif PLOT_ALL:\n    n = spot_tuner.k\n    for i in range(n-1):\n        for j in range(i+1, n):\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z)"
  },
  {
    "objectID": "19_spot_hpt_sklearn_multiclass_classification_knn.html#sec-setup-19",
    "href": "19_spot_hpt_sklearn_multiclass_classification_knn.html#sec-setup-19",
    "title": "18  HPT: sklearn KNN Classifier VBDP Data",
    "section": "18.1 Step 1: Setup",
    "text": "18.1 Step 1: Setup\nBefore we consider the detailed experimental setup, we select the parameters that affect run time and the initial design size.\n\nMAX_TIME = 1\nINIT_SIZE = 5\nORIGINAL = True\nPREFIX = \"19\"\n\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")"
  },
  {
    "objectID": "19_spot_hpt_sklearn_multiclass_classification_knn.html#step-2-initialization-of-the-empty-fun_control-dictionary",
    "href": "19_spot_hpt_sklearn_multiclass_classification_knn.html#step-2-initialization-of-the-empty-fun_control-dictionary",
    "title": "18  HPT: sklearn KNN Classifier VBDP Data",
    "section": "18.2 Step 2: Initialization of the Empty fun_control Dictionary",
    "text": "18.2 Step 2: Initialization of the Empty fun_control Dictionary\n\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_experiment_name, get_spot_tensorboard_path\nfrom spotPython.utils.device import getDevice\n\nexperiment_name = get_experiment_name(prefix=PREFIX)\n\nfun_control = fun_control_init(\n    task=\"classification\",\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name))\n\n\n18.2.1 Load Data: Classification VBDP\n\nimport pandas as pd\nif ORIGINAL == True:\n    train_df = pd.read_csv('./data/VBDP/trainn.csv')\n    test_df = pd.read_csv('./data/VBDP/testt.csv')\nelse:\n    train_df = pd.read_csv('./data/VBDP/train.csv')\n    # remove the id column\n    train_df = train_df.drop(columns=['id'])\n\n\nfrom sklearn.preprocessing import OrdinalEncoder\nn_samples = train_df.shape[0]\nn_features = train_df.shape[1] - 1\ntarget_column = \"prognosis\"\n# Encoder our prognosis labels as integers for easier decoding later\nenc = OrdinalEncoder()\ntrain_df[target_column] = enc.fit_transform(train_df[[target_column]])\ntrain_df.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\nprint(train_df.shape)\ntrain_df.head()\n\n(252, 65)\n\n\n\n\n\n\n\n\n\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n...\nx56\nx57\nx58\nx59\nx60\nx61\nx62\nx63\nx64\nprognosis\n\n\n\n\n0\n0\n1\n1\n1\n1\n0\n1\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n1\n1\n1\n1\n1\n1\n0\n1\n1\n1\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n2\n0\n1\n0\n1\n0\n0\n1\n1\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n3\n0\n0\n0\n0\n0\n1\n1\n1\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n4\n1\n0\n0\n0\n1\n1\n1\n1\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0.0\n\n\n\n\n5 rows × 65 columns\n\n\n\nThe full data set train_df 64 features. The target column is labeled as prognosis.\n\n\n18.2.2 Holdout Train and Test Data\nWe split out a hold-out test set (25% of the data) so we can calculate an example MAP@K\n\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(train_df.drop(target_column, axis=1), train_df[target_column],\n                                                    random_state=42,\n                                                    test_size=0.25,\n                                                    stratify=train_df[target_column])\ntrain = pd.DataFrame(np.hstack((X_train, np.array(y_train).reshape(-1, 1))))\ntest = pd.DataFrame(np.hstack((X_test, np.array(y_test).reshape(-1, 1))))\ntrain.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\ntest.columns = [f\"x{i}\" for i in range(1, n_features+1)] + [target_column]\nprint(train.shape)\nprint(test.shape)\ntrain.head()\n\n(189, 65)\n(63, 65)\n\n\n\n\n\n\n\n\n\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n...\nx56\nx57\nx58\nx59\nx60\nx61\nx62\nx63\nx64\nprognosis\n\n\n\n\n0\n1.0\n0.0\n0.0\n1.0\n0.0\n1.0\n0.0\n0.0\n0.0\n1.0\n...\n0.0\n0.0\n0.0\n0.0\n1.0\n1.0\n1.0\n0.0\n0.0\n7.0\n\n\n1\n1.0\n0.0\n1.0\n1.0\n1.0\n1.0\n1.0\n0.0\n1.0\n1.0\n...\n0.0\n1.0\n1.0\n1.0\n1.0\n0.0\n1.0\n1.0\n1.0\n3.0\n\n\n2\n0.0\n0.0\n1.0\n0.0\n1.0\n0.0\n0.0\n0.0\n0.0\n0.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n10.0\n\n\n3\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n0.0\n0.0\n1.0\n1.0\n...\n1.0\n0.0\n1.0\n1.0\n1.0\n0.0\n0.0\n1.0\n1.0\n3.0\n\n\n4\n1.0\n1.0\n1.0\n0.0\n1.0\n1.0\n0.0\n1.0\n1.0\n0.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n8.0\n\n\n\n\n5 rows × 65 columns\n\n\n\n\n# add the dataset to the fun_control\nfun_control.update({\"data\": train_df, # full dataset,\n               \"train\": train,\n               \"test\": test,\n               \"n_samples\": n_samples,\n               \"target_column\": target_column})"
  },
  {
    "objectID": "19_spot_hpt_sklearn_multiclass_classification_knn.html#sec-specification-of-preprocessing-model-19",
    "href": "19_spot_hpt_sklearn_multiclass_classification_knn.html#sec-specification-of-preprocessing-model-19",
    "title": "18  HPT: sklearn KNN Classifier VBDP Data",
    "section": "18.3 Step 4: Specification of the Preprocessing Model",
    "text": "18.3 Step 4: Specification of the Preprocessing Model\nData preprocesssing can be very simple, e.g., you can ignore it. Then you would choose the prep_model “None”:\n\nprep_model = None\nfun_control.update({\"prep_model\": prep_model})\n\nA default approach for numerical data is the StandardScaler (mean 0, variance 1). This can be selected as follows:\n\n# prep_model = StandardScaler()\n# fun_control.update({\"prep_model\": prep_model})\n\nEven more complicated pre-processing steps are possible, e.g., the follwing pipeline:\n\n# categorical_columns = []\n# one_hot_encoder = OneHotEncoder(handle_unknown=\"ignore\", sparse_output=False)\n# prep_model = ColumnTransformer(\n#         transformers=[\n#             (\"categorical\", one_hot_encoder, categorical_columns),\n#         ],\n#         remainder=StandardScaler(),\n#     )"
  },
  {
    "objectID": "19_spot_hpt_sklearn_multiclass_classification_knn.html#step-5-select-model-algorithm-and-core_model_hyper_dict",
    "href": "19_spot_hpt_sklearn_multiclass_classification_knn.html#step-5-select-model-algorithm-and-core_model_hyper_dict",
    "title": "18  HPT: sklearn KNN Classifier VBDP Data",
    "section": "18.4 Step 5: Select Model (algorithm) and core_model_hyper_dict",
    "text": "18.4 Step 5: Select Model (algorithm) and core_model_hyper_dict\nThe selection of the algorithm (ML model) that should be tuned is done by specifying the its name from the sklearn implementation. For example, the SVC support vector machine classifier is selected as follows:\nadd_core_model_to_fun_control(SVC, fun_control, SklearnHyperDict)\nOther core_models are, e.g.,:\n\nRidgeCV\nGradientBoostingRegressor\nElasticNet\nRandomForestClassifier\nLogisticRegression\nKNeighborsClassifier\nRandomForestClassifier\nGradientBoostingClassifier\nHistGradientBoostingClassifier\n\nWe will use the RandomForestClassifier classifier in this example.\n\nfrom sklearn.linear_model import RidgeCV\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.ensemble import HistGradientBoostingClassifier\nfrom sklearn.linear_model import ElasticNet\nfrom spotPython.hyperparameters.values import add_core_model_to_fun_control\nfrom spotPython.data.sklearn_hyper_dict import SklearnHyperDict\nfrom spotPython.fun.hypersklearn import HyperSklearn\n\n\n# core_model  = RidgeCV\n# core_model = GradientBoostingRegressor\n# core_model = ElasticNet\n# core_model = RandomForestClassifier\ncore_model = KNeighborsClassifier\n# core_model = LogisticRegression\n# core_model = KNeighborsClassifier\n# core_model = GradientBoostingClassifier\n# core_model = HistGradientBoostingClassifier\nadd_core_model_to_fun_control(core_model=core_model,\n                              fun_control=fun_control,\n                              hyper_dict=SklearnHyperDict,\n                              filename=None)\n\nNow fun_control has the information from the JSON file. The available hyperparameters are:\n\nprint(*fun_control[\"core_model_hyper_dict\"].keys(), sep=\"\\n\")\n\nn_neighbors\nweights\nalgorithm\nleaf_size\np"
  },
  {
    "objectID": "19_spot_hpt_sklearn_multiclass_classification_knn.html#step-6-modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "href": "19_spot_hpt_sklearn_multiclass_classification_knn.html#step-6-modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "title": "18  HPT: sklearn KNN Classifier VBDP Data",
    "section": "18.5 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model",
    "text": "18.5 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\n\n18.5.1 Modify hyperparameter of type numeric and integer (boolean)\nNumeric and boolean values can be modified using the modify_hyper_parameter_bounds method. For example, to change the tol hyperparameter of the SVC model to the interval [1e-3, 1e-2], the following code can be used:\nmodify_hyper_parameter_bounds(fun_control, \"tol\", bounds=[1e-3, 1e-2])\n\n# from spotPython.hyperparameters.values import modify_hyper_parameter_bounds\n# modify_hyper_parameter_bounds(fun_control, \"probability\", bounds=[1, 1])\n\n\n\n18.5.2 Modify hyperparameter of type factor\nspotPython provides functions for modifying the hyperparameters, their bounds and factors as well as for activating and de-activating hyperparameters without re-compilation of the Python source code. These functions were described in Section 23.6.\nFactors can be modified with the modify_hyper_parameter_levels function. For example, to exclude the sigmoid kernel from the tuning, the kernel hyperparameter of the SVC model can be modified as follows:\nmodify_hyper_parameter_levels(fun_control, \"kernel\", [\"linear\", \"rbf\"])\nThe new setting can be controlled via:\nfun_control[\"core_model_hyper_dict\"][\"kernel\"]\n\n# from spotPython.hyperparameters.values import modify_hyper_parameter_levels\n# modify_hyper_parameter_levels(fun_control, \"kernel\", [\"rbf\"])\n\n\n\n18.5.3 Optimizers\nOptimizers are described in Section 23.6.1.\n\n\n18.5.4 Selection of the Objective: Metric and Loss Functions\n\nMachine learning models are optimized with respect to a metric, for example, the accuracy function.\nDeep learning, e.g., neural networks are optimized with respect to a loss function, for example, the cross_entropy function and evaluated with respect to a metric, for example, the accuracy function."
  },
  {
    "objectID": "19_spot_hpt_sklearn_multiclass_classification_knn.html#step-7-selection-of-the-objective-loss-function",
    "href": "19_spot_hpt_sklearn_multiclass_classification_knn.html#step-7-selection-of-the-objective-loss-function",
    "title": "18  HPT: sklearn KNN Classifier VBDP Data",
    "section": "18.6 Step 7: Selection of the Objective (Loss) Function",
    "text": "18.6 Step 7: Selection of the Objective (Loss) Function\nThe loss function, that is usually used in deep learning for optimizing the weights of the net, is stored in the fun_control dictionary as \"loss_function\".\n\n18.6.1 Metric Function\nThere are two different types of metrics in spotPython:\n\n\"metric_river\" is used for the river based evaluation via eval_oml_iter_progressive.\n\"metric_sklearn\" is used for the sklearn based evaluation.\n\nWe will consider multi-class classification metrics, e.g., mapk_score and top_k_accuracy_score.\n\n\n\n\n\n\nPredict Probabilities\n\n\n\nIn this multi-class classification example the machine learning algorithm should return the probabilities of the specific classes (\"predict_proba\") instead of the predicted values.\n\n\nWe set \"predict_proba\" to True in the fun_control dictionary.\n\n18.6.1.1 The MAPK Metric\nTo select the MAPK metric, the following two entries can be added to the fun_control dictionary:\n\"metric_sklearn\": mapk_score\"\n\"metric_params\": {\"k\": 3}.\n\n\n18.6.1.2 Other Metrics\nAlternatively, other metrics for multi-class classification can be used, e.g.,: * top_k_accuracy_score or * roc_auc_score\nThe metric roc_auc_score requires the parameter \"multi_class\", e.g.,\n\"multi_class\": \"ovr\".\nThis is set in the fun_control dictionary.\n\n\n\n\n\n\nWeights\n\n\n\nspotPython performs a minimization, therefore, metrics that should be maximized have to be multiplied by -1. This is done by setting \"weights\" to -1.\n\n\n\nThe complete setup for the metric in our example is:\n\n\nfrom spotPython.utils.metrics import mapk_score\nfun_control.update({\n               \"weights\": -1,\n               \"metric_sklearn\": mapk_score,\n               \"predict_proba\": True,\n               \"metric_params\": {\"k\": 3},\n               })\n\n\n\n\n18.6.2 Evaluation on Hold-out Data\n\nThe default method for computing the performance is \"eval_holdout\".\nAlternatively, cross-validation can be used for every machine learning model.\nSpecifically for RandomForests, the OOB-score can be used.\n\n\nfun_control.update({\n    \"eval\": \"train_hold_out\",\n})\n\n\n18.6.2.1 Cross Validation\nInstead of using the OOB-score, the classical cross validation can be used. The number of folds is set by the key \"k_folds\". For example, to use 5-fold cross validation, the key \"k_folds\" is set to 5. Uncomment the following line to use cross validation:\n\n# fun_control.update({\n#      \"eval\": \"train_cv\",\n#      \"k_folds\": 10,\n# })"
  },
  {
    "objectID": "19_spot_hpt_sklearn_multiclass_classification_knn.html#step-8-calling-the-spot-function",
    "href": "19_spot_hpt_sklearn_multiclass_classification_knn.html#step-8-calling-the-spot-function",
    "title": "18  HPT: sklearn KNN Classifier VBDP Data",
    "section": "18.7 Step 8: Calling the SPOT Function",
    "text": "18.7 Step 8: Calling the SPOT Function\n\n18.7.1 Preparing the SPOT Call\n\nGet types and variable names as well as lower and upper bounds for the hyperparameters.\n\n\n# extract the variable types, names, and bounds\nfrom spotPython.hyperparameters.values import (get_bound_values,\n    get_var_name,\n    get_var_type,)\nvar_type = get_var_type(fun_control)\nvar_name = get_var_name(fun_control)\nlower = get_bound_values(fun_control, \"lower\")\nupper = get_bound_values(fun_control, \"upper\")\n\n\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control))\n\n| name        | type   | default   |   lower |   upper | transform             |\n|-------------|--------|-----------|---------|---------|-----------------------|\n| n_neighbors | int    | 2         |       1 |       7 | transform_power_2_int |\n| weights     | factor | uniform   |       0 |       1 | None                  |\n| algorithm   | factor | auto      |       0 |       3 | None                  |\n| leaf_size   | int    | 5         |       2 |       7 | transform_power_2_int |\n| p           | int    | 2         |       1 |       2 | None                  |\n\n\n\n\n18.7.2 The Objective Function\nThe objective function is selected next. It implements an interface from sklearn’s training, validation, and testing methods to spotPython.\n\nfrom spotPython.fun.hypersklearn import HyperSklearn\nfun = HyperSklearn().fun_sklearn\n\n\n\n18.7.3 Run the Spot Optimizer\n\nRun SPOT for approx. x mins (max_time).\nNote: the run takes longer, because the evaluation time of initial design (here: initi_size, 20 points) is not considered.\n\n\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nX_start = get_default_hyperparameters_as_array(fun_control)\nX_start\n\narray([[2, 0, 0, 5, 2]])\n\n\n\nimport numpy as np\nfrom spotPython.spot import spot\nfrom math import inf\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   fun_repeats = 1,\n                   max_time = MAX_TIME,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   infill_criterion = \"y\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models= False,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": True,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_fun_evals\": 10_000,\n                                      \"log_level\": 50\n                                      })\nspot_tuner.run(X_start=X_start)\n\nspotPython tuning: -0.71875 [----------] 0.75% \n\n\nspotPython tuning: -0.71875 [----------] 1.50% \n\n\nspotPython tuning: -0.7326388888888888 [----------] 2.36% \n\n\nspotPython tuning: -0.7326388888888888 [----------] 2.78% \n\n\nspotPython tuning: -0.7326388888888888 [----------] 3.31% \n\n\nspotPython tuning: -0.7326388888888888 [----------] 3.82% \n\n\nspotPython tuning: -0.7326388888888888 [----------] 4.42% \n\n\nspotPython tuning: -0.7326388888888888 [#---------] 5.08% \n\n\nspotPython tuning: -0.7326388888888888 [#---------] 5.61% \n\n\nspotPython tuning: -0.7326388888888888 [#---------] 6.07% \n\n\nspotPython tuning: -0.7326388888888888 [#---------] 6.63% \n\n\nspotPython tuning: -0.7326388888888888 [#---------] 14.67% \n\n\nspotPython tuning: -0.7326388888888888 [##--------] 23.39% \n\n\nspotPython tuning: -0.7326388888888888 [###-------] 31.92% \n\n\nspotPython tuning: -0.7326388888888888 [####------] 39.22% \n\n\nspotPython tuning: -0.7326388888888888 [#####-----] 47.45% \n\n\nspotPython tuning: -0.7326388888888888 [#####-----] 54.78% \n\n\nspotPython tuning: -0.7326388888888888 [######----] 60.71% \n\n\nspotPython tuning: -0.7326388888888888 [#######---] 68.99% \n\n\nspotPython tuning: -0.7465277777777777 [########--] 75.84% \n\n\nspotPython tuning: -0.7465277777777777 [########--] 83.15% \n\n\nspotPython tuning: -0.7465277777777777 [#########-] 89.54% \n\n\nspotPython tuning: -0.7465277777777777 [##########] 97.90% \n\n\nspotPython tuning: -0.7465277777777777 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2a44efa90&gt;"
  },
  {
    "objectID": "19_spot_hpt_sklearn_multiclass_classification_knn.html#sec-tensorboard-19",
    "href": "19_spot_hpt_sklearn_multiclass_classification_knn.html#sec-tensorboard-19",
    "title": "18  HPT: sklearn KNN Classifier VBDP Data",
    "section": "18.8 Step 9: Tensorboard",
    "text": "18.8 Step 9: Tensorboard\nThe textual output shown in the console (or code cell) can be visualized with Tensorboard as described in Section 23.9, see also the description in the documentation: Tensorboard."
  },
  {
    "objectID": "19_spot_hpt_sklearn_multiclass_classification_knn.html#sec-results-tuning-19",
    "href": "19_spot_hpt_sklearn_multiclass_classification_knn.html#sec-results-tuning-19",
    "title": "18  HPT: sklearn KNN Classifier VBDP Data",
    "section": "18.9 Step 10: Results",
    "text": "18.9 Step 10: Results\nAfter the hyperparameter tuning run is finished, the progress of the hyperparameter tuning can be visualized. The following code generates the progress plot from ?fig-progress.\n\nspot_tuner.plot_progress(log_y=False,\n    filename=\"./figures/\" + experiment_name+\"_progress.png\")\n\n\n\n\nProgress plot. Black dots denote results from the initial design. Red dots illustrate the improvement found by the surrogate model based optimization.\n\n\n\n\n\nPrint the results\n\n\nprint(gen_design_table(fun_control=fun_control,\n    spot=spot_tuner))\n\n| name        | type   | default   |   lower |   upper |   tuned | transform             |   importance | stars   |\n|-------------|--------|-----------|---------|---------|---------|-----------------------|--------------|---------|\n| n_neighbors | int    | 2         |       1 |       7 |     3.0 | transform_power_2_int |         6.91 | *       |\n| weights     | factor | uniform   |       0 |       1 |     0.0 | None                  |       100.00 | ***     |\n| algorithm   | factor | auto      |       0 |       3 |     1.0 | None                  |         0.00 |         |\n| leaf_size   | int    | 5         |       2 |       7 |     4.0 | transform_power_2_int |         0.00 |         |\n| p           | int    | 2         |       1 |       2 |     2.0 | None                  |         0.00 |         |\n\n\n\n18.9.1 Show variable importance\n\nspot_tuner.plot_importance(threshold=0.025, filename=\"./figures/\" + experiment_name+\"_importance.png\")\n\n\n\n\nVariable importance plot, threshold 0.025.\n\n\n\n\n\n\n18.9.2 Get Default Hyperparameters\n\nfrom spotPython.hyperparameters.values import get_default_values, transform_hyper_parameter_values\nvalues_default = get_default_values(fun_control)\nvalues_default = transform_hyper_parameter_values(fun_control=fun_control, hyper_parameter_values=values_default)\nvalues_default\n\n{'n_neighbors': 4,\n 'weights': 'uniform',\n 'algorithm': 'auto',\n 'leaf_size': 32,\n 'p': 2}\n\n\n\nfrom sklearn.pipeline import make_pipeline\nmodel_default = make_pipeline(fun_control[\"prep_model\"], fun_control[\"core_model\"](**values_default))\nmodel_default\n\nPipeline(steps=[('nonetype', None),\n                ('kneighborsclassifier',\n                 KNeighborsClassifier(leaf_size=32, n_neighbors=4))])In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.PipelinePipeline(steps=[('nonetype', None),\n                ('kneighborsclassifier',\n                 KNeighborsClassifier(leaf_size=32, n_neighbors=4))])NoneNoneKNeighborsClassifierKNeighborsClassifier(leaf_size=32, n_neighbors=4)\n\n\n\n\n18.9.3 Get SPOT Results\n\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nprint(X)\n\n[[3. 0. 1. 4. 2.]]\n\n\n\nfrom spotPython.hyperparameters.values import assign_values, return_conf_list_from_var_dict\nv_dict = assign_values(X, fun_control[\"var_name\"])\nreturn_conf_list_from_var_dict(var_dict=v_dict, fun_control=fun_control)\n\n[{'n_neighbors': 8,\n  'weights': 'uniform',\n  'algorithm': 'ball_tree',\n  'leaf_size': 16,\n  'p': 2}]\n\n\n\nfrom spotPython.hyperparameters.values import get_one_sklearn_model_from_X\nmodel_spot = get_one_sklearn_model_from_X(X, fun_control)\nmodel_spot\n\nKNeighborsClassifier(algorithm='ball_tree', leaf_size=16, n_neighbors=8)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.KNeighborsClassifierKNeighborsClassifier(algorithm='ball_tree', leaf_size=16, n_neighbors=8)\n\n\n\n\n18.9.4 Evaluate SPOT Results\n\nFetch the data.\n\n\nfrom spotPython.utils.convert import get_Xy_from_df\nX_train, y_train = get_Xy_from_df(fun_control[\"train\"], fun_control[\"target_column\"])\nX_test, y_test = get_Xy_from_df(fun_control[\"test\"], fun_control[\"target_column\"])\nX_test.shape, y_test.shape\n\n((63, 64), (63,))\n\n\n\nFit the model with the tuned hyperparameters. This gives one result:\n\n\nmodel_spot.fit(X_train, y_train)\ny_pred = model_spot.predict_proba(X_test)\nres = mapk_score(y_true=y_test, y_pred=y_pred, k=3)\nres\n\n0.7010582010582012\n\n\n\ndef repeated_eval(n, model):\n    res_values = []\n    for i in range(n):\n        model.fit(X_train, y_train)\n        y_pred = model.predict_proba(X_test)\n        res = mapk_score(y_true=y_test, y_pred=y_pred, k=3)\n        res_values.append(res)\n    mean_res = np.mean(res_values)\n    print(f\"mean_res: {mean_res}\")\n    std_res = np.std(res_values)\n    print(f\"std_res: {std_res}\")\n    min_res = np.min(res_values)\n    print(f\"min_res: {min_res}\")\n    max_res = np.max(res_values)\n    print(f\"max_res: {max_res}\")\n    median_res = np.median(res_values)\n    print(f\"median_res: {median_res}\")\n    return mean_res, std_res, min_res, max_res, median_res\n\n\n\n18.9.5 Handling Non-deterministic Results\n\nBecause the model is non-determinstic, we perform \\(n=30\\) runs and calculate the mean and standard deviation of the performance metric.\n\n\n_ = repeated_eval(30, model_spot)\n\nmean_res: 0.7010582010582015\nstd_res: 3.3306690738754696e-16\nmin_res: 0.7010582010582012\nmax_res: 0.7010582010582012\nmedian_res: 0.7010582010582012\n\n\n\n\n18.9.6 Evalution of the Default Hyperparameters\n\nmodel_default.fit(X_train, y_train)[\"kneighborsclassifier\"]\n\nKNeighborsClassifier(leaf_size=32, n_neighbors=4)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.KNeighborsClassifierKNeighborsClassifier(leaf_size=32, n_neighbors=4)\n\n\n\nOne evaluation of the default hyperparameters is performed on the hold-out test set.\n\n\ny_pred = model_default.predict_proba(X_test)\nmapk_score(y_true=y_test, y_pred=y_pred, k=3)\n\n0.6878306878306879\n\n\nSince one single evaluation is not meaningful, we perform, similar to the evaluation of the SPOT results, \\(n=30\\) runs of the default setting and and calculate the mean and standard deviation of the performance metric.\n\n_ = repeated_eval(30, model_default)\n\nmean_res: 0.6878306878306877\nstd_res: 2.220446049250313e-16\nmin_res: 0.6878306878306879\nmax_res: 0.6878306878306879\nmedian_res: 0.6878306878306879\n\n\n\n\n18.9.7 Plot: Compare Predictions\n\nfrom spotPython.plot.validation import plot_confusion_matrix\nplot_confusion_matrix(model=model_default, fun_control=fun_control, title = \"Default\")\n\n\n\n\n\nplot_confusion_matrix(model=model_spot, fun_control=fun_control, title=\"SPOT\")\n\n\n\n\n\nmin(spot_tuner.y), max(spot_tuner.y)\n\n(-0.7465277777777777, -0.59375)\n\n\n\n\n18.9.8 Cross-validated Evaluations\n\nfrom spotPython.sklearn.traintest import evaluate_cv\nfun_control.update({\n     \"eval\": \"train_cv\",\n     \"k_folds\": 10,\n})\nevaluate_cv(model=model_spot, fun_control=fun_control, verbose=0)\n\n(0.7156920077972708, None)\n\n\n\nfun_control.update({\n     \"eval\": \"test_cv\",\n     \"k_folds\": 10,\n})\nevaluate_cv(model=model_spot, fun_control=fun_control, verbose=0)\n\nError in fun_sklearn(). Call to evaluate_cv failed. err=ValueError('n_splits=10 cannot be greater than the number of members in each class.'), type(err)=&lt;class 'ValueError'&gt;\n\n\n(nan, None)\n\n\n\nThis is the evaluation that will be used in the comparison:\n\n\nfun_control.update({\n     \"eval\": \"data_cv\",\n     \"k_folds\": 10,\n})\nevaluate_cv(model=model_spot, fun_control=fun_control, verbose=0)\n\n(0.7089487179487179, None)\n\n\n\n\n18.9.9 Detailed Hyperparameter Plots\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)\n\nn_neighbors:  6.9119524672697565\nweights:  100.0\n\n\n\n\n\n\n\n18.9.10 Parallel Coordinates Plot\n\nspot_tuner.parallel_plot()\n\n\n                                                \n\n\n\n\n18.9.11 Plot all Combinations of Hyperparameters\n\nWarning: this may take a while.\n\n\nPLOT_ALL = False\nif PLOT_ALL:\n    n = spot_tuner.k\n    for i in range(n-1):\n        for j in range(i+1, n):\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z)"
  },
  {
    "objectID": "0000spot_river_gui.html#hyperparameter-tuning",
    "href": "0000spot_river_gui.html#hyperparameter-tuning",
    "title": "20  The spotriver GUI",
    "section": "20.1 Hyperparameter Tuning",
    "text": "20.1 Hyperparameter Tuning\nCalls run_spot_river_experiment from spotRiver.tuner.run.py with the following parameters:\n\nMAX_TIME,\nINIT_SIZE\nPREFIX\nhorizon\nn_total\nperc_train\noml_grace_period\ndata_set\nprepmodel\ncoremodel\n\n\n20.1.1 The run_spot_river_experiment Method\nrun_spot_river_experiment calls the tuner spot after processing the following steps:\n\nGenerate an experiment name.\nInitialize the fun_control dictionary.\nSelect the data set based on the data_set parameter and generate a data frame.\nSplits the data into training and test sets.\nSets the oml_grace_period parameter.\nSelect the preprocessing model based on the prepmodel parameter.\nSets the weights for the evaluation function and the weight coeffient.\nLoads the coremodel based on the coremodel parameter with hyperparameters set to the values specified in the RiverHyperDict dictionary.\nDetermines the default hyperparameters.\nSelects the evaluation function: HyperRiver.fun_oml_horizon.\nDetermines hyperparameter types, names, lower and upper bounds for the spot tuner.\nStarts tensorboard as a background process.\nStarts the spot tuner.\n\nWhen the tuner is finished, the following steps are performed:\n\nThe tensorboard process is terminated.\nThe spot_tuner object and the fun_control dictionary are returned.\n\nAfter the tuner is finished, the following information is available:\n\n\n20.1.2 Binary Classification"
  },
  {
    "objectID": "0000spot_river_gui.html#analysis",
    "href": "0000spot_river_gui.html#analysis",
    "title": "20  The spotriver GUI",
    "section": "20.2 Analysis",
    "text": "20.2 Analysis"
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#sec-setup-13",
    "href": "13_spot_hpt_river_friedman_hatr.html#sec-setup-13",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.1 Setup",
    "text": "21.1 Setup\nBefore we consider the detailed experimental setup, we select the parameters that affect run time, initial design size, size of the data set, and the experiment name.\n\nMAX_TIME: The maximum run time in seconds for the hyperparameter tuning process.\nINIT_SIZE: The initial design size for the hyperparameter tuning process.\nPREFIX: The prefix for the experiment name.\nK: The factor that determines the number of samples in the data set.\n\n\n\n\n\n\n\nCaution: Run time and initial design size should be increased for real experiments\n\n\n\n\nMAX_TIME is set to one minute for demonstration purposes. For real experiments, this should be increased to at least 1 hour.\nINIT_SIZE is set to 5 for demonstration purposes. For real experiments, this should be increased to at least 10.\nK is the multiplier for the number of samples. If it is set to 1, then 100_000samples are taken. It is set to 0.1 for demonstration purposes. For real experiments, this should be increased to at least 1.\n\n\n\n\nMAX_TIME = 1\nINIT_SIZE = 5\nPREFIX=\"13-river\"\nK = 0.1\n\n\nThis notebook exemplifies hyperparameter tuning with SPOT (spotPython and spotRiver).\nThe hyperparameter software SPOT is available in Python. It was developed in R (statistical programming language), see Open Access book “Hyperparameter Tuning for Machine and Deep Learning with R - A Practical Guide”, available here: https://link.springer.com/book/10.1007/978-981-19-5170-1.\nThis notebook demonstrates hyperparameter tuning for river. It is based on the notebook “Incremental decision trees in river: the Hoeffding Tree case”, see: https://riverml.xyz/0.15.0/recipes/on-hoeffding-trees/#42-regression-tree-splitters.\nHere we will use the river HTR and HATR functions as in “Incremental decision trees in river: the Hoeffding Tree case”, see: https://riverml.xyz/0.15.0/recipes/on-hoeffding-trees/#42-regression-tree-splitters."
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#initialization-of-the-fun_control-dictionary",
    "href": "13_spot_hpt_river_friedman_hatr.html#initialization-of-the-fun_control-dictionary",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.2 Initialization of the fun_control Dictionary",
    "text": "21.2 Initialization of the fun_control Dictionary\nspotPython supports the visualization of the hyperparameter tuning process with TensorBoard. The following example shows how to use TensorBoard with spotPython.\nFirst, we define an “experiment name” to identify the hyperparameter tuning process. The experiment name is also used to create a directory for the TensorBoard files.\n\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_spot_tensorboard_path\nimport os\nfrom spotPython.utils.file import get_experiment_name\nexperiment_name = get_experiment_name(prefix=PREFIX)\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    TENSORBOARD_CLEAN=True)\nprint(experiment_name)\n\n13-river_bartz09_2023-11-03_22-50-10\n\n\n\n\n\n\n\n\nTip: TensorBoard\n\n\n\n\nSince the spot_tensorboard_path argument is not None, which is the default, spotPython will log the optimization process in the TensorBoard folder.\nSection 22.8.4 describes how to start TensorBoard and access the TensorBoard dashboard.\nThe TENSORBOARD_CLEAN argument is set to True to archive the TensorBoard folder if it already exists. This is useful if you want to start a hyperparameter tuning process from scratch. If you want to continue a hyperparameter tuning process, set TENSORBOARD_CLEAN to False. Then the TensorBoard folder will not be archived and the old and new TensorBoard files will shown in the TensorBoard dashboard."
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#load-data-the-friedman-drift-data",
    "href": "13_spot_hpt_river_friedman_hatr.html#load-data-the-friedman-drift-data",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.3 Load Data: The Friedman Drift Data",
    "text": "21.3 Load Data: The Friedman Drift Data\nWe will use the Friedman synthetic dataset with concept drifts [SOURCE]. Each observation is composed of ten features. Each feature value is sampled uniformly in [0, 1]. Only the first five features are relevant. The target is defined by different functions depending on the type of the drift. Global Recurring Abrupt drift will be used, i.e., the concept drift appears over the whole instance space. There are two points of concept drift. At the second point of drift the old concept reoccurs.\nThe following parameters are used to generate and handle the data set:\n\nhorizon: The prediction horizon in hours.\nn_samples: The number of samples in the data set.\np_1: The position of the first concept drift.\np_2: The position of the second concept drift.\nposition: The position of the concept drifts.\nn_train: The number of samples used for training.\n\n\nhorizon = 7*24\nn_samples = int(K*100_000)\np_1 = int(K*25_000)\np_2 = int(K*50_000)\nposition=(p_1, p_2)\nn_train = 1_000\n\n\nfrom river.datasets import synth\nimport pandas as pd\ndataset = synth.FriedmanDrift(\n   drift_type='gra',\n   position=position,\n   seed=123\n)\n\n\nWe will use spotRiver’s convert_to_df function [SOURCE] to convert the river data set to a pandas data frame.\n\n\nfrom spotRiver.utils.data_conversion import convert_to_df\ntarget_column = \"y\"\ndf = convert_to_df(dataset, target_column=target_column, n_total=n_samples)\n\n\nAdd column names x1 until x10 to the first 10 columns of the dataframe and the column name y to the last column of the dataframe.\nThen split the data frame into a training and test data set. The train and test data sets are stored in the fun_control dictionary.\n\n\ndf.columns = [f\"x{i}\" for i in range(1, 11)] + [\"y\"]\nfun_control.update({\"train\":  df[:n_train],\n                    \"test\":  df[n_train:],\n                    \"n_samples\": n_samples,\n                    \"target_column\": target_column})"
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#specification-of-the-preprocessing-model",
    "href": "13_spot_hpt_river_friedman_hatr.html#specification-of-the-preprocessing-model",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.4 Specification of the Preprocessing Model",
    "text": "21.4 Specification of the Preprocessing Model\n\nWe use the StandardScaler [SOURCE] from river as the preprocessing model. The StandardScaler is used to standardize the data set, i.e., it has zero mean and unit variance.\n\n\nfrom river import preprocessing\nprep_model = preprocessing.StandardScaler()\nfun_control.update({\"prep_model\": prep_model})"
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#selectselect-model-algorithm-and-core_model_hyper_dict",
    "href": "13_spot_hpt_river_friedman_hatr.html#selectselect-model-algorithm-and-core_model_hyper_dict",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.5 SelectSelect Model (algorithm) and core_model_hyper_dict",
    "text": "21.5 SelectSelect Model (algorithm) and core_model_hyper_dict\nspotPython hyperparameter tuning approach uses two components:\n\na model (class) and\nan associated hyperparameter dictionary.\n\nHere, the river model class HoeffdingAdaptiveTreeRegressor [SOURCE] is selected.\nThe corresponding hyperparameters are loaded from the associated dictionary, which is stored as a JSON file [SOURCE]. The JSON file contains hyperparameter type information, names, and bounds.\nThe method add_core_model_to_fun_control adds the model and the hyperparameter dictionary to the fun_control dictionary.\nAlternatively, you can load a local hyper_dict. Simply set river_hyper_dict.json as the filename. If filenameis set to None, which is the default, the hyper_dict [SOURCE] is loaded from the spotRiver package.\n\nfrom river.tree import HoeffdingAdaptiveTreeRegressor\nfrom spotRiver.data.river_hyper_dict import RiverHyperDict\nfrom spotPython.hyperparameters.values import add_core_model_to_fun_control\nadd_core_model_to_fun_control(core_model=HoeffdingAdaptiveTreeRegressor,\n                              fun_control=fun_control,\n                              hyper_dict=RiverHyperDict,\n                              filename=None)"
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "href": "13_spot_hpt_river_friedman_hatr.html#modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.6 Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model",
    "text": "21.6 Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\nAfter the core_model and the core_model_hyper_dict are added to the fun_control dictionary, the hyperparameter tuning can be started. However, in some settings, the user wants to modify the hyperparameters of the core_model_hyper_dict. This can be done with the modify_hyper_parameter_bounds and modify_hyper_parameter_levels functions [SOURCE].\nThe following code shows how hyperparameter of type numeric and integer (boolean) can be modified. The modify_hyper_parameter_bounds function is used to modify the bounds of the hyperparameter delta and merit_preprune. Similar option exists for the modify_hyper_parameter_levels function to modify the levels of categorical hyperparameters.\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_bounds\nmodify_hyper_parameter_bounds(fun_control, \"delta\", bounds=[1e-10, 1e-6])\nmodify_hyper_parameter_bounds(fun_control, \"merit_preprune\", [0, 0])\n\n\n\n\n\n\n\nNote: Active and Inactive Hyperparameters\n\n\n\nHyperparameters can be excluded from the tuning procedure by selecting identical values for the lower and upper bounds. For example, the hyperparameter merit_preprune is excluded from the tuning procedure by setting the bounds to [0, 0].\n\n\nspotPython’s method gen_design_table summarizes the experimental design that is used for the hyperparameter tuning:\n\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control))\n\n| name                   | type   | default          |      lower |    upper | transform             |\n|------------------------|--------|------------------|------------|----------|-----------------------|\n| grace_period           | int    | 200              |     10     | 1000     | None                  |\n| max_depth              | int    | 20               |      2     |   20     | transform_power_2_int |\n| delta                  | float  | 1e-07            |      1e-10 |    1e-06 | None                  |\n| tau                    | float  | 0.05             |      0.01  |    0.1   | None                  |\n| leaf_prediction        | factor | mean             |      0     |    2     | None                  |\n| leaf_model             | factor | LinearRegression |      0     |    2     | None                  |\n| model_selector_decay   | float  | 0.95             |      0.9   |    0.99  | None                  |\n| splitter               | factor | EBSTSplitter     |      0     |    2     | None                  |\n| min_samples_split      | int    | 5                |      2     |   10     | None                  |\n| bootstrap_sampling     | factor | 0                |      0     |    1     | None                  |\n| drift_window_threshold | int    | 300              |    100     |  500     | None                  |\n| switch_significance    | float  | 0.05             |      0.01  |    0.1   | None                  |\n| binary_split           | factor | 0                |      0     |    1     | None                  |\n| max_size               | float  | 500.0            |    100     | 1000     | None                  |\n| memory_estimate_period | int    | 1000000          | 100000     |    1e+06 | None                  |\n| stop_mem_management    | factor | 0                |      0     |    1     | None                  |\n| remove_poor_attrs      | factor | 0                |      0     |    1     | None                  |\n| merit_preprune         | factor | 0                |      0     |    0     | None                  |"
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#selection-of-the-objective-loss-function",
    "href": "13_spot_hpt_river_friedman_hatr.html#selection-of-the-objective-loss-function",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.7 Selection of the Objective (Loss) Function",
    "text": "21.7 Selection of the Objective (Loss) Function\nThe metric_sklearn is used for the sklearn based evaluation via eval_oml_horizon [SOURCE]. Here we use the mean_absolute_error [SOURCE] as the objective function.\n\n\n\n\n\n\nNote: Additional metrics\n\n\n\nspotRiver also supports additional metrics. For example, the metric_river is used for the river based evaluation via eval_oml_iter_progressive [SOURCE]. The metric_river is implemented to simulate the behaviour of the “original” river metrics.\n\n\nspotRiver provides information about the model’ s score (metric), memory, and time. The hyperparamter tuner requires a single objective. Therefore, a weighted sum of the metric, memory, and time is computed. The weights are defined in the weights array.\n\n\n\n\n\n\nNote: Weights\n\n\n\nThe weights provide a flexible way to define specific requirements, e.g., if the memory is more important than the time, the weight for the memory can be increased.\n\n\nThe oml_grace_period defines the number of observations that are used for the initial training of the model. The step defines the iteration number at which to yield results. This only takes into account the predictions, and not the training steps. The weight_coeff defines a multiplier for the results: results are multiplied by (step/n_steps)**weight_coeff, where n_steps is the total number of iterations. Results from the beginning have a lower weight than results from the end if weight_coeff &gt; 1. If weight_coeff == 0, all results have equal weight. Note, that the weight_coeff is only used internally for the tuner and does not affect the results that are used for the evaluation or comparisons.\n\nimport numpy as np\nfrom sklearn.metrics import mean_absolute_error\n\nweights = np.array([1, 1/1000, 1/1000])*10_000.0\noml_grace_period = 2\nstep = 100\nweight_coeff = 1.0\n\nfun_control.update({\n               \"horizon\": horizon,\n               \"oml_grace_period\": oml_grace_period,\n               \"weights\": weights,\n               \"step\": step,\n               \"weight_coeff\": weight_coeff,\n               \"metric_sklearn\": mean_absolute_error\n               })"
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#calling-the-spot-function",
    "href": "13_spot_hpt_river_friedman_hatr.html#calling-the-spot-function",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.8 Calling the SPOT Function",
    "text": "21.8 Calling the SPOT Function\n\n21.8.1 Prepare the SPOT Parameters\nThe hyperparameter tuning configuration is stored in the fun_control dictionary. Since Spot can be used as an optimization algorithm with a similar interface as optimization algorithms from scipy.optimize [LINK], the bounds and variable types have to be specified explicitely. The get_var_type, get_var_name, and get_bound_values functions [SOURCE] implement the required functionality.\n\nGet types and variable names as well as lower and upper bounds for the hyperparameters, so that they can be passed to the Spot function.\n\n\nfrom spotPython.hyperparameters.values import (\n    get_var_type,\n    get_var_name,\n    get_bound_values\n    )\nvar_type = get_var_type(fun_control)\nvar_name = get_var_name(fun_control)\nlower = get_bound_values(fun_control, \"lower\")\nupper = get_bound_values(fun_control, \"upper\")\n\n\n\n21.8.2 The Objective Function\nThe objective function fun_oml_horizon [SOURCE] is selected next.\n\nfrom spotRiver.fun.hyperriver import HyperRiver\nfun = HyperRiver().fun_oml_horizon\n\nThe following code snippet shows how to get the default hyperparameters as an array, so that they can be passed to the Spot function.\n\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nX_start = get_default_hyperparameters_as_array(fun_control)\n\n\n\n21.8.3 Run the Spot Optimizer\nThe class Spot [SOURCE] is the hyperparameter tuning workhorse. It is initialized with the following parameters:\n\nfun: the objective function\nlower: lower bounds of the hyperparameters\nupper: upper bounds of the hyperparameters\nfun_evals: number of function evaluations\nmax_time: maximum time in seconds\ntolerance_x: tolerance for the hyperparameters\nvar_type: variable types of the hyperparameters\nvar_name: variable names of the hyperparameters\nshow_progress: show progress bar\nfun_control: dictionary with control parameters for the objective function\ndesign_control: dictionary with control parameters for the initial design\nsurrogate_control: dictionary with control parameters for the surrogate model\n\n\n\n\n\n\n\nNote: Total run time\n\n\n\nThe total run time may exceed the specified max_time, because the initial design (here: init_size = INIT_SIZE as specified above) is always evaluated, even if this takes longer than max_time.\n\n\n\nfrom spotPython.spot import spot\nfrom math import inf\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   max_time = MAX_TIME,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE},\n                   surrogate_control={\"noise\": False,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_fun_evals\": 10_000})\nspot_tuner.run(X_start=X_start)\n\nspotPython tuning: 2.145937179275767 [#---------] 14.44% \n\n\nspotPython tuning: 2.145937179275767 [####------] 42.97% \n\n\nspotPython tuning: 2.145937179275767 [######----] 57.79% \n\n\nspotPython tuning: 2.145937179275767 [#######---] 71.81% \n\n\nspotPython tuning: 2.145937179275767 [#########-] 85.17% \n\n\nspotPython tuning: 2.145937179275767 [##########] 98.47% \n\n\nspotPython tuning: 2.145937179275767 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x2bd4d8490&gt;\n\n\n\n\n21.8.4 TensorBoard\nNow we can start TensorBoard in the background with the following command, where ./runs is the default directory for the TensorBoard log files:\ntensorboard --logdir=\"./runs\"\n\n\n\n\n\n\nTip: TENSORBOARD_PATH\n\n\n\nThe TensorBoard path can be printed with the following command:\n\nfrom spotPython.utils.file import get_tensorboard_path\nget_tensorboard_path(fun_control)\n\n'runs/'\n\n\n\n\nWe can access the TensorBoard web server with the following URL:\nhttp://localhost:6006/\nThe TensorBoard plot illustrates how spotPython can be used as a microscope for the internal mechanisms of the surrogate-based optimization process. Here, one important parameter, the learning rate \\(\\theta\\) of the Kriging surrogate [SOURCE] is plotted against the number of optimization steps.\n\n\n\nTensorBoard visualization of the spotPython optimization process and the surrogate model.\n\n\n\n\n21.8.5 Results\nAfter the hyperparameter tuning run is finished, the results can be saved and reloaded with the following commands:\n\nfrom spotPython.utils.file import save_pickle\nsave_pickle(spot_tuner, experiment_name)\n\n\nfrom spotPython.utils.file import load_pickle\nspot_tuner = load_pickle(experiment_name)\n\nAfter the hyperparameter tuning run is finished, the progress of the hyperparameter tuning can be visualized. The black points represent the performace values (score or metric) of hyperparameter configurations from the initial design, whereas the red points represents the hyperparameter configurations found by the surrogate model based optimization.\n\nspot_tuner.plot_progress(log_y=True, filename=\"./figures/\" + experiment_name+\"_progress.pdf\")\n\n\n\n\nResults can also be printed in tabular form.\n\nprint(gen_design_table(fun_control=fun_control, spot=spot_tuner))\n\n| name                   | type   | default          |    lower |     upper |                 tuned | transform             |   importance | stars   |\n|------------------------|--------|------------------|----------|-----------|-----------------------|-----------------------|--------------|---------|\n| grace_period           | int    | 200              |     10.0 |    1000.0 |                 657.0 | None                  |         0.00 |         |\n| max_depth              | int    | 20               |      2.0 |      20.0 |                   8.0 | transform_power_2_int |         0.00 |         |\n| delta                  | float  | 1e-07            |    1e-10 |     1e-06 | 4.068723023437076e-08 | None                  |         0.00 |         |\n| tau                    | float  | 0.05             |     0.01 |       0.1 |   0.04842600916881275 | None                  |         0.00 |         |\n| leaf_prediction        | factor | mean             |      0.0 |       2.0 |                   2.0 | None                  |         0.00 |         |\n| leaf_model             | factor | LinearRegression |      0.0 |       2.0 |                   0.0 | None                  |         2.11 | *       |\n| model_selector_decay   | float  | 0.95             |      0.9 |      0.99 |    0.9707132374807789 | None                  |         0.00 |         |\n| splitter               | factor | EBSTSplitter     |      0.0 |       2.0 |                   2.0 | None                  |       100.00 | ***     |\n| min_samples_split      | int    | 5                |      2.0 |      10.0 |                   5.0 | None                  |         0.00 |         |\n| bootstrap_sampling     | factor | 0                |      0.0 |       1.0 |                   1.0 | None                  |         0.00 |         |\n| drift_window_threshold | int    | 300              |    100.0 |     500.0 |                 166.0 | None                  |         0.00 |         |\n| switch_significance    | float  | 0.05             |     0.01 |       0.1 |    0.0403706393874862 | None                  |         0.00 |         |\n| binary_split           | factor | 0                |      0.0 |       1.0 |                   0.0 | None                  |         0.00 |         |\n| max_size               | float  | 500.0            |    100.0 |    1000.0 |     454.1406541108139 | None                  |         0.01 |         |\n| memory_estimate_period | int    | 1000000          | 100000.0 | 1000000.0 |              910594.0 | None                  |         0.00 |         |\n| stop_mem_management    | factor | 0                |      0.0 |       1.0 |                   1.0 | None                  |         0.00 |         |\n| remove_poor_attrs      | factor | 0                |      0.0 |       1.0 |                   1.0 | None                  |         2.63 | *       |\n| merit_preprune         | factor | 0                |      0.0 |       0.0 |                   0.0 | None                  |         0.00 |         |\n\n\nA histogram can be used to visualize the most important hyperparameters.\n\nspot_tuner.plot_importance(threshold=0.0025, filename=\"./figures/\" + experiment_name+\"_importance.pdf\")"
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#the-larger-data-set",
    "href": "13_spot_hpt_river_friedman_hatr.html#the-larger-data-set",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.9 The Larger Data Set",
    "text": "21.9 The Larger Data Set\nAfter the hyperparamter were tuned on a small data set, we can now apply the hyperparameter configuration to a larger data set. The following code snippet shows how to generate the larger data set.\n\n\n\n\n\n\nCaution: Increased Friedman-Drift Data Set\n\n\n\n\nThe Friedman-Drift Data Set is increased by a factor of two to show the transferability of the hyperparameter tuning results.\nLarger values of K lead to a longer run time.\n\n\n\n\nK = 0.2\nn_samples = int(K*100_000)\np_1 = int(K*25_000)\np_2 = int(K*50_000)\nposition=(p_1, p_2)\n\n\ndataset = synth.FriedmanDrift(\n   drift_type='gra',\n   position=position,\n   seed=123\n)\n\nThe larger data set is converted to a Pandas data frame and passed to the fun_control dictionary.\n\ndf = convert_to_df(dataset, target_column=target_column, n_total=n_samples)\ndf.columns = [f\"x{i}\" for i in range(1, 11)] + [\"y\"]\nfun_control.update({\"train\": df[:n_train],\n                    \"test\": df[n_train:],\n                    \"n_samples\": n_samples,\n                    \"target_column\": target_column})"
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#get-default-hyperparameters",
    "href": "13_spot_hpt_river_friedman_hatr.html#get-default-hyperparameters",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.10 Get Default Hyperparameters",
    "text": "21.10 Get Default Hyperparameters\nThe default hyperparameters, whihc will be used for a comparion with the tuned hyperparameters, can be obtained with the following commands:\n\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nX_start = get_default_hyperparameters_as_array(fun_control)\nmodel_default = get_one_core_model_from_X(X_start, fun_control)\n\n\n\n\n\n\n\nNote: spotPython tunes numpy arrays\n\n\n\n\nspotPython tunes numpy arrays, i.e., the hyperparameters are stored in a numpy array.\n\n\n\nThe model with the default hyperparameters can be trained and evaluated with the following commands:\n\nfrom spotRiver.evaluation.eval_bml import eval_oml_horizon\n\ndf_eval_default, df_true_default = eval_oml_horizon(\n                    model=model_default,\n                    train=fun_control[\"train\"],\n                    test=fun_control[\"test\"],\n                    target_column=fun_control[\"target_column\"],\n                    horizon=fun_control[\"horizon\"],\n                    oml_grace_period=fun_control[\"oml_grace_period\"],\n                    metric=fun_control[\"metric_sklearn\"],\n                )\n\nThe three performance criteria, i.e., scaoe (metric), runtime, and memory consumption, can be visualized with the following commands:\n\nfrom spotRiver.evaluation.eval_bml import plot_bml_oml_horizon_metrics, plot_bml_oml_horizon_predictions\ndf_labels=[\"default\"]\nplot_bml_oml_horizon_metrics(df_eval = [df_eval_default], log_y=False, df_labels=df_labels, metric=fun_control[\"metric_sklearn\"])\n\n\n\n\n\n21.10.1 Show Predictions\n\nSelect a subset of the data set for the visualization of the predictions:\n\nWe use the mean, \\(m\\), of the data set as the center of the visualization.\nWe use 100 data points, i.e., \\(m \\pm 50\\) as the visualization window.\n\n\n\nm = fun_control[\"test\"].shape[0]\na = int(m/2)-50\nb = int(m/2)\n\n\nplot_bml_oml_horizon_predictions(df_true = [df_true_default[a:b]], target_column=target_column,  df_labels=df_labels)"
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#get-spot-results",
    "href": "13_spot_hpt_river_friedman_hatr.html#get-spot-results",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.11 Get SPOT Results",
    "text": "21.11 Get SPOT Results\nIn a similar way, we can obtain the hyperparameters found by spotPython.\n\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nmodel_spot = get_one_core_model_from_X(X, fun_control)\n\n\ndf_eval_spot, df_true_spot = eval_oml_horizon(\n                    model=model_spot,\n                    train=fun_control[\"train\"],\n                    test=fun_control[\"test\"],\n                    target_column=fun_control[\"target_column\"],\n                    horizon=fun_control[\"horizon\"],\n                    oml_grace_period=fun_control[\"oml_grace_period\"],\n                    metric=fun_control[\"metric_sklearn\"],\n                )\n\n\ndf_labels=[\"default\", \"spot\"]\nplot_bml_oml_horizon_metrics(df_eval = [df_eval_default, df_eval_spot], log_y=False, df_labels=df_labels, metric=fun_control[\"metric_sklearn\"], filename=\"./figures/\" + experiment_name+\"_metrics.pdf\")\n\n\n\n\n\nplot_bml_oml_horizon_predictions(df_true = [df_true_default[a:b], df_true_spot[a:b]], target_column=target_column,  df_labels=df_labels, filename=\"./figures/\" + experiment_name+\"_predictions.pdf\")\n\n\n\n\n\nfrom spotPython.plot.validation import plot_actual_vs_predicted\nplot_actual_vs_predicted(y_test=df_true_default[target_column], y_pred=df_true_default[\"Prediction\"], title=\"Default\")\nplot_actual_vs_predicted(y_test=df_true_spot[target_column], y_pred=df_true_spot[\"Prediction\"], title=\"SPOT\")"
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#visualize-regression-trees",
    "href": "13_spot_hpt_river_friedman_hatr.html#visualize-regression-trees",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.12 Visualize Regression Trees",
    "text": "21.12 Visualize Regression Trees\n\ndataset_f = dataset.take(n_samples)\nfor x, y in dataset_f:\n    model_default.learn_one(x, y)\n\n\n\n\n\n\n\nCaution: Large Trees\n\n\n\n\nSince the trees are large, the visualization is suppressed by default.\nTo visualize the trees, uncomment the following line.\n\n\n\n\n# model_default.draw()\n\n\nmodel_default.summary\n\n{'n_nodes': 35,\n 'n_branches': 17,\n 'n_leaves': 18,\n 'n_active_leaves': 96,\n 'n_inactive_leaves': 0,\n 'height': 6,\n 'total_observed_weight': 39002.0,\n 'n_alternate_trees': 21,\n 'n_pruned_alternate_trees': 6,\n 'n_switch_alternate_trees': 2}\n\n\n\n21.12.1 Spot Model\n\ndataset_f = dataset.take(n_samples)\nfor x, y in dataset_f:\n    model_spot.learn_one(x, y)\n\n\n\n\n\n\n\nCaution: Large Trees\n\n\n\n\nSince the trees are large, the visualization is suppressed by default.\nTo visualize the trees, uncomment the following line.\n\n\n\n\n# model_spot.draw()\n\n\nmodel_spot.summary\n\n{'n_nodes': 75,\n 'n_branches': 37,\n 'n_leaves': 38,\n 'n_active_leaves': 38,\n 'n_inactive_leaves': 0,\n 'height': 14,\n 'total_observed_weight': 39002.0,\n 'n_alternate_trees': 22,\n 'n_pruned_alternate_trees': 20,\n 'n_switch_alternate_trees': 1}\n\n\n\nfrom spotPython.utils.eda import compare_two_tree_models\nprint(compare_two_tree_models(model_default, model_spot))\n\n| Parameter                |   Default |   Spot |\n|--------------------------|-----------|--------|\n| n_nodes                  |        35 |     75 |\n| n_branches               |        17 |     37 |\n| n_leaves                 |        18 |     38 |\n| n_active_leaves          |        96 |     38 |\n| n_inactive_leaves        |         0 |      0 |\n| height                   |         6 |     14 |\n| total_observed_weight    |     39002 |  39002 |\n| n_alternate_trees        |        21 |     22 |\n| n_pruned_alternate_trees |         6 |     20 |\n| n_switch_alternate_trees |         2 |      1 |"
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#detailed-hyperparameter-plots",
    "href": "13_spot_hpt_river_friedman_hatr.html#detailed-hyperparameter-plots",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.13 Detailed Hyperparameter Plots",
    "text": "21.13 Detailed Hyperparameter Plots\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)\n\nleaf_model:  2.114884051763091\nsplitter:  100.0\nremove_poor_attrs:  2.6329440408566085"
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#parallel-coordinates-plots",
    "href": "13_spot_hpt_river_friedman_hatr.html#parallel-coordinates-plots",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.14 Parallel Coordinates Plots",
    "text": "21.14 Parallel Coordinates Plots\n\nspot_tuner.parallel_plot()"
  },
  {
    "objectID": "13_spot_hpt_river_friedman_hatr.html#plot-all-combinations-of-hyperparameters",
    "href": "13_spot_hpt_river_friedman_hatr.html#plot-all-combinations-of-hyperparameters",
    "title": "21  river Hyperparameter Tuning: Hoeffding Adaptive Tree Regressor with Friedman Drift Data",
    "section": "21.15 Plot all Combinations of Hyperparameters",
    "text": "21.15 Plot all Combinations of Hyperparameters\n\nWarning: this may take a while.\n\n\nPLOT_ALL = False\nif PLOT_ALL:\n    n = spot_tuner.k\n    for i in range(n-1):\n        for j in range(i+1, n):\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z)"
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#sec-setup-51",
    "href": "51_spot_hpt_river_friedman_amfr.html#sec-setup-51",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.1 Setup",
    "text": "23.1 Setup\nBefore we consider the detailed experimental setup, we select the parameters that affect run time, initial design size, size of the data set, and the experiment name.\n\nMAX_TIME: The maximum run time in seconds for the hyperparameter tuning process.\nINIT_SIZE: The initial design size for the hyperparameter tuning process.\nPREFIX: The prefix for the experiment name.\nK: The factor that determines the number of samples in the data set.\n\n\n\n\n\n\n\nCaution: Run time and initial design size should be increased for real experiments\n\n\n\n\nMAX_TIME is set to one minute for demonstration purposes. For real experiments, this should be increased to at least 1 hour.\nINIT_SIZE is set to 5 for demonstration purposes. For real experiments, this should be increased to at least 10.\nK is the multiplier for the number of samples. If it is set to 1, then 100_000samples are taken. It is set to 0.1 for demonstration purposes. For real experiments, this should be increased to at least 1.\n\n\n\n\nMAX_TIME = 1\nINIT_SIZE = 5\nPREFIX=\"51-river\"\nK = 0.1\n\n\nThis notebook exemplifies hyperparameter tuning with SPOT (spotPython and spotRiver).\nThe hyperparameter software SPOT is available in Python. It was developed in R (statistical programming language), see Open Access book “Hyperparameter Tuning for Machine and Deep Learning with R - A Practical Guide”, available here: https://link.springer.com/book/10.1007/978-981-19-5170-1.\nThis notebook demonstrates hyperparameter tuning for river. It is based on the notebook “Incremental decision trees in river: the Hoeffding Tree case”, see: https://riverml.xyz/0.15.0/recipes/on-hoeffding-trees/#42-regression-tree-splitters.\nHere we will use the river AMFRegressor functions, see: https://riverml.xyz/0.19.0/api/forest/AMFRegressor/."
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#initialization-of-the-fun_control-dictionary",
    "href": "51_spot_hpt_river_friedman_amfr.html#initialization-of-the-fun_control-dictionary",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.2 Initialization of the fun_control Dictionary",
    "text": "23.2 Initialization of the fun_control Dictionary\nspotPython supports the visualization of the hyperparameter tuning process with TensorBoard. The following example shows how to use TensorBoard with spotPython.\nFirst, we define an “experiment name” to identify the hyperparameter tuning process. The experiment name is also used to create a directory for the TensorBoard files.\n\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_spot_tensorboard_path\nimport os\nfrom spotPython.utils.file import get_experiment_name\nexperiment_name = get_experiment_name(prefix=PREFIX)\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    TENSORBOARD_CLEAN=True)\nprint(experiment_name)\n\n51-river_bartz09_2023-11-03_22-56-13\n\n\n\n\n\n\n\n\nTip: TensorBoard\n\n\n\n\nSince the spot_tensorboard_path argument is not None, which is the default, spotPython will log the optimization process in the TensorBoard folder.\nSection 22.8.4 describes how to start TensorBoard and access the TensorBoard dashboard.\nThe TENSORBOARD_CLEAN argument is set to True to archive the TensorBoard folder if it already exists. This is useful if you want to start a hyperparameter tuning process from scratch. If you want to continue a hyperparameter tuning process, set TENSORBOARD_CLEAN to False. Then the TensorBoard folder will not be archived and the old and new TensorBoard files will shown in the TensorBoard dashboard."
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#load-data-the-friedman-drift-data",
    "href": "51_spot_hpt_river_friedman_amfr.html#load-data-the-friedman-drift-data",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.3 Load Data: The Friedman Drift Data",
    "text": "23.3 Load Data: The Friedman Drift Data\nWe will use the Friedman synthetic dataset with concept drifts [SOURCE]. Each observation is composed of ten features. Each feature value is sampled uniformly in [0, 1]. Only the first five features are relevant. The target is defined by different functions depending on the type of the drift. Global Recurring Abrupt drift will be used, i.e., the concept drift appears over the whole instance space. There are two points of concept drift. At the second point of drift the old concept reoccurs.\nThe following parameters are used to generate and handle the data set:\n\nhorizon: The prediction horizon in hours.\nn_samples: The number of samples in the data set.\np_1: The position of the first concept drift.\np_2: The position of the second concept drift.\nposition: The position of the concept drifts.\nn_train: The number of samples used for training.\n\n\nhorizon = 7*24\nn_samples = int(K*100_000)\np_1 = int(K*25_000)\np_2 = int(K*50_000)\nposition=(p_1, p_2)\nn_train = 1_000\n\n\nfrom river.datasets import synth\nimport pandas as pd\ndataset = synth.FriedmanDrift(\n   drift_type='gra',\n   position=position,\n   seed=123\n)\n\n\nWe will use spotRiver’s convert_to_df function [SOURCE] to convert the river data set to a pandas data frame.\n\n\nfrom spotRiver.utils.data_conversion import convert_to_df\ntarget_column = \"y\"\ndf = convert_to_df(dataset, target_column=target_column, n_total=n_samples)\n\n\nAdd column names x1 until x10 to the first 10 columns of the dataframe and the column name y to the last column of the dataframe.\nThen split the data frame into a training and test data set. The train and test data sets are stored in the fun_control dictionary.\n\n\ndf.columns = [f\"x{i}\" for i in range(1, 11)] + [\"y\"]\nfun_control.update({\"train\":  df[:n_train],\n                    \"test\":  df[n_train:],\n                    \"n_samples\": n_samples,\n                    \"target_column\": target_column})"
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#specification-of-the-preprocessing-model",
    "href": "51_spot_hpt_river_friedman_amfr.html#specification-of-the-preprocessing-model",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.4 Specification of the Preprocessing Model",
    "text": "23.4 Specification of the Preprocessing Model\n\nWe use the StandardScaler [SOURCE] from river as the preprocessing model. The StandardScaler is used to standardize the data set, i.e., it has zero mean and unit variance.\n\n\nfrom river import preprocessing\nprep_model = preprocessing.StandardScaler()\nfun_control.update({\"prep_model\": prep_model})"
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#selectselect-model-algorithm-and-core_model_hyper_dict",
    "href": "51_spot_hpt_river_friedman_amfr.html#selectselect-model-algorithm-and-core_model_hyper_dict",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.5 SelectSelect Model (algorithm) and core_model_hyper_dict",
    "text": "23.5 SelectSelect Model (algorithm) and core_model_hyper_dict\nspotPython hyperparameter tuning approach uses two components:\n\na model (class) and\nan associated hyperparameter dictionary.\n\nThe corresponding hyperparameters are loaded from the associated dictionary, which is stored as a JSON file [SOURCE]. The JSON file contains hyperparameter type information, names, and bounds.\nThe method add_core_model_to_fun_control adds the model and the hyperparameter dictionary to the fun_control dictionary.\nAlternatively, you can load a local hyper_dict. Simply set river_hyper_dict.json as the filename. If filenameis set to None, which is the default, the hyper_dict [SOURCE] is loaded from the spotRiver package.\n\nfrom river.forest import AMFRegressor\nfrom spotRiver.data.river_hyper_dict import RiverHyperDict\nfrom spotPython.hyperparameters.values import add_core_model_to_fun_control\nadd_core_model_to_fun_control(core_model=AMFRegressor,\n                              fun_control=fun_control,\n                              hyper_dict=RiverHyperDict,\n                              filename=None)"
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "href": "51_spot_hpt_river_friedman_amfr.html#modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.6 Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model",
    "text": "23.6 Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\nAfter the core_model and the core_model_hyper_dict are added to the fun_control dictionary, the hyperparameter tuning can be started. However, in some settings, the user wants to modify the hyperparameters of the core_model_hyper_dict. This can be done with the modify_hyper_parameter_bounds and modify_hyper_parameter_levels functions [SOURCE].\nThe following code shows how hyperparameter of type numeric and integer (boolean) can be modified. The modify_hyper_parameter_bounds function is used to modify the bounds of the hyperparameter delta and merit_preprune. Similar option exists for the modify_hyper_parameter_levels function to modify the levels of categorical hyperparameters.\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_bounds\nmodify_hyper_parameter_bounds(fun_control, \"n_estimators\", bounds=[2,100])\n\n::: {.callout-note} #### Note: Active and Inactive Hyperparameters Hyperparameters can be excluded from the tuning procedure by selecting identical values for the lower and upper bounds.\n\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control))\n\n| name            | type   |   default |   lower |   upper | transform   |\n|-----------------|--------|-----------|---------|---------|-------------|\n| n_estimators    | int    |        10 |     2   |     100 | None        |\n| step            | float  |         1 |     0.1 |      10 | None        |\n| use_aggregation | factor |         1 |     0   |       1 | None        |"
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#selection-of-the-objective-loss-function",
    "href": "51_spot_hpt_river_friedman_amfr.html#selection-of-the-objective-loss-function",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.7 Selection of the Objective (Loss) Function",
    "text": "23.7 Selection of the Objective (Loss) Function\nThe metric_sklearn is used for the sklearn based evaluation via eval_oml_horizon [SOURCE]. Here we use the mean_absolute_error [SOURCE] as the objective function.\n\n\n\n\n\n\nNote: Additional metrics\n\n\n\nspotRiver also supports additional metrics. For example, the metric_river is used for the river based evaluation via eval_oml_iter_progressive [SOURCE]. The metric_river is implemented to simulate the behaviour of the “original” river metrics.\n\n\nspotRiver provides information about the model’ s score (metric), memory, and time. The hyperparamter tuner requires a single objective. Therefore, a weighted sum of the metric, memory, and time is computed. The weights are defined in the weights array.\n\n\n\n\n\n\nNote: Weights\n\n\n\nThe weights provide a flexible way to define specific requirements, e.g., if the memory is more important than the time, the weight for the memory can be increased.\n\n\nThe oml_grace_period defines the number of observations that are used for the initial training of the model. The step defines the iteration number at which to yield results. This only takes into account the predictions, and not the training steps. The weight_coeff defines a multiplier for the results: results are multiplied by (step/n_steps)**weight_coeff, where n_steps is the total number of iterations. Results from the beginning have a lower weight than results from the end if weight_coeff &gt; 1. If weight_coeff == 0, all results have equal weight. Note, that the weight_coeff is only used internally for the tuner and does not affect the results that are used for the evaluation or comparisons.\n\nimport numpy as np\nfrom sklearn.metrics import mean_absolute_error\n\nweights = np.array([1, 1/1000, 1/1000])*10_000.0\noml_grace_period = 2\nstep = 100\nweight_coeff = 1.0\n\nfun_control.update({\n               \"horizon\": horizon,\n               \"oml_grace_period\": oml_grace_period,\n               \"weights\": weights,\n               \"step\": step,\n               \"weight_coeff\": weight_coeff,\n               \"metric_sklearn\": mean_absolute_error\n               })"
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#calling-the-spot-function",
    "href": "51_spot_hpt_river_friedman_amfr.html#calling-the-spot-function",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.8 Calling the SPOT Function",
    "text": "23.8 Calling the SPOT Function\n\n23.8.1 Prepare the SPOT Parameters\nThe hyperparameter tuning configuration is stored in the fun_control dictionary. Since Spot can be used as an optimization algorithm with a similar interface as optimization algorithms from scipy.optimize [LINK], the bounds and variable types have to be specified explicitely. The get_var_type, get_var_name, and get_bound_values functions [SOURCE] implement the required functionality.\n\nGet types and variable names as well as lower and upper bounds for the hyperparameters, so that they can be passed to the Spot function.\n\n\nfrom spotPython.hyperparameters.values import (\n    get_var_type,\n    get_var_name,\n    get_bound_values\n    )\nvar_type = get_var_type(fun_control)\nvar_name = get_var_name(fun_control)\nlower = get_bound_values(fun_control, \"lower\")\nupper = get_bound_values(fun_control, \"upper\")\n\n\n\n23.8.2 The Objective Function\nThe objective function fun_oml_horizon [SOURCE] is selected next.\n\nfrom spotRiver.fun.hyperriver import HyperRiver\nfun = HyperRiver().fun_oml_horizon\n\nThe following code snippet shows how to get the default hyperparameters as an array, so that they can be passed to the Spot function.\n\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nX_start = get_default_hyperparameters_as_array(fun_control)\n\n\n\n23.8.3 Run the Spot Optimizer\nThe class Spot [SOURCE] is the hyperparameter tuning workhorse. It is initialized with the following parameters:\n\nfun: the objective function\nlower: lower bounds of the hyperparameters\nupper: upper bounds of the hyperparameters\nfun_evals: number of function evaluations\nmax_time: maximum time in seconds\ntolerance_x: tolerance for the hyperparameters\nvar_type: variable types of the hyperparameters\nvar_name: variable names of the hyperparameters\nshow_progress: show progress bar\nfun_control: dictionary with control parameters for the objective function\ndesign_control: dictionary with control parameters for the initial design\nsurrogate_control: dictionary with control parameters for the surrogate model\n\n\n\n\n\n\n\nNote: Total run time\n\n\n\nThe total run time may exceed the specified max_time, because the initial design (here: init_size = INIT_SIZE as specified above) is always evaluated, even if this takes longer than max_time.\n\n\n\nfrom spotPython.spot import spot\nfrom math import inf\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   max_time = MAX_TIME,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE},\n                   surrogate_control={\"noise\": False,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_fun_evals\": 10_000})\nspot_tuner.run(X_start=X_start)\n\nspotPython tuning: 2.6533633916568307 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x176cb9290&gt;\n\n\n\n\n23.8.4 TensorBoard\nNow we can start TensorBoard in the background with the following command, where ./runs is the default directory for the TensorBoard log files:\ntensorboard --logdir=\"./runs\"\n\n\n\n\n\n\nTip: TENSORBOARD_PATH\n\n\n\nThe TensorBoard path can be printed with the following command:\n\nfrom spotPython.utils.file import get_tensorboard_path\nget_tensorboard_path(fun_control)\n\n'runs/'\n\n\n\n\nWe can access the TensorBoard web server with the following URL:\nhttp://localhost:6006/\nThe TensorBoard plot illustrates how spotPython can be used as a microscope for the internal mechanisms of the surrogate-based optimization process. Here, one important parameter, the learning rate \\(\\theta\\) of the Kriging surrogate [SOURCE] is plotted against the number of optimization steps.\n\n\n\nTensorBoard visualization of the spotPython optimization process and the surrogate model.\n\n\n\n\n23.8.5 Results\nAfter the hyperparameter tuning run is finished, the results can be saved and reloaded with the following commands:\n\nfrom spotPython.utils.file import save_pickle\nsave_pickle(spot_tuner, experiment_name)\n\n\nfrom spotPython.utils.file import load_pickle\nspot_tuner = load_pickle(experiment_name)\n\nAfter the hyperparameter tuning run is finished, the progress of the hyperparameter tuning can be visualized. The black points represent the performace values (score or metric) of hyperparameter configurations from the initial design, whereas the red points represents the hyperparameter configurations found by the surrogate model based optimization.\n\nspot_tuner.plot_progress(log_y=True, filename=\"./figures/\" + experiment_name+\"_progress.pdf\")\n\n\n\n\nResults can also be printed in tabular form.\n\nprint(gen_design_table(fun_control=fun_control, spot=spot_tuner))\n\n| name            | type   |   default |   lower |   upper |             tuned | transform   |   importance | stars   |\n|-----------------|--------|-----------|---------|---------|-------------------|-------------|--------------|---------|\n| n_estimators    | int    |      10.0 |     2.0 |     100 |              63.0 | None        |       100.00 | ***     |\n| step            | float  |       1.0 |     0.1 |      10 | 7.004318498645526 | None        |         1.83 | *       |\n| use_aggregation | factor |       1.0 |     0.0 |       1 |               0.0 | None        |         0.24 | .       |\n\n\nA histogram can be used to visualize the most important hyperparameters.\n\nspot_tuner.plot_importance(threshold=0.0025, filename=\"./figures/\" + experiment_name+\"_importance.pdf\")"
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#the-larger-data-set",
    "href": "51_spot_hpt_river_friedman_amfr.html#the-larger-data-set",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.9 The Larger Data Set",
    "text": "23.9 The Larger Data Set\nAfter the hyperparameter were tuned on a small data set, we can now apply the hyperparameter configuration to a larger data set. The following code snippet shows how to generate the larger data set.\n\n\n\n\n\n\nCaution: Increased Friedman-Drift Data Set\n\n\n\n\nThe Friedman-Drift Data Set is increased by a factor of two to show the transferability of the hyperparameter tuning results.\nLarger values of K lead to a longer run time.\n\n\n\n\nK = 0.2\nn_samples = int(K*100_000)\np_1 = int(K*25_000)\np_2 = int(K*50_000)\nposition=(p_1, p_2)\n\n\ndataset = synth.FriedmanDrift(\n   drift_type='gra',\n   position=position,\n   seed=123\n)\n\nThe larger data set is converted to a Pandas data frame and passed to the fun_control dictionary.\n\ndf = convert_to_df(dataset, target_column=target_column, n_total=n_samples)\ndf.columns = [f\"x{i}\" for i in range(1, 11)] + [\"y\"]\nfun_control.update({\"train\": df[:n_train],\n                    \"test\": df[n_train:],\n                    \"n_samples\": n_samples,\n                    \"target_column\": target_column})"
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#get-default-hyperparameters",
    "href": "51_spot_hpt_river_friedman_amfr.html#get-default-hyperparameters",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.10 Get Default Hyperparameters",
    "text": "23.10 Get Default Hyperparameters\nThe default hyperparameters, whihc will be used for a comparion with the tuned hyperparameters, can be obtained with the following commands:\n\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nX_start = get_default_hyperparameters_as_array(fun_control)\nmodel_default = get_one_core_model_from_X(X_start, fun_control)\n\n\n\n\n\n\n\nNote: spotPython tunes numpy arrays\n\n\n\n\nspotPython tunes numpy arrays, i.e., the hyperparameters are stored in a numpy array.\n\n\n\nThe model with the default hyperparameters can be trained and evaluated with the following commands:\n\nfrom spotRiver.evaluation.eval_bml import eval_oml_horizon\n\ndf_eval_default, df_true_default = eval_oml_horizon(\n                    model=model_default,\n                    train=fun_control[\"train\"],\n                    test=fun_control[\"test\"],\n                    target_column=fun_control[\"target_column\"],\n                    horizon=fun_control[\"horizon\"],\n                    oml_grace_period=fun_control[\"oml_grace_period\"],\n                    metric=fun_control[\"metric_sklearn\"],\n                )\n\nThe three performance criteria, i.e., scaoe (metric), runtime, and memory consumption, can be visualized with the following commands:\n\nfrom spotRiver.evaluation.eval_bml import plot_bml_oml_horizon_metrics, plot_bml_oml_horizon_predictions\ndf_labels=[\"default\"]\nplot_bml_oml_horizon_metrics(df_eval = [df_eval_default], log_y=False, df_labels=df_labels, metric=fun_control[\"metric_sklearn\"])\n\n\n\n\n\n23.10.1 Show Predictions\n\nSelect a subset of the data set for the visualization of the predictions:\n\nWe use the mean, \\(m\\), of the data set as the center of the visualization.\nWe use 100 data points, i.e., \\(m \\pm 50\\) as the visualization window.\n\n\n\nm = fun_control[\"test\"].shape[0]\na = int(m/2)-50\nb = int(m/2)\n\n\nplot_bml_oml_horizon_predictions(df_true = [df_true_default[a:b]], target_column=target_column,  df_labels=df_labels)"
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#get-spot-results",
    "href": "51_spot_hpt_river_friedman_amfr.html#get-spot-results",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.11 Get SPOT Results",
    "text": "23.11 Get SPOT Results\nIn a similar way, we can obtain the hyperparameters found by spotPython.\n\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nmodel_spot = get_one_core_model_from_X(X, fun_control)\n\n\ndf_eval_spot, df_true_spot = eval_oml_horizon(\n                    model=model_spot,\n                    train=fun_control[\"train\"],\n                    test=fun_control[\"test\"],\n                    target_column=fun_control[\"target_column\"],\n                    horizon=fun_control[\"horizon\"],\n                    oml_grace_period=fun_control[\"oml_grace_period\"],\n                    metric=fun_control[\"metric_sklearn\"],\n                )\n\n\ndf_labels=[\"default\", \"spot\"]\nplot_bml_oml_horizon_metrics(df_eval = [df_eval_default, df_eval_spot], log_y=False, df_labels=df_labels, metric=fun_control[\"metric_sklearn\"], filename=\"./figures/\" + experiment_name+\"_metrics.pdf\")\n\n\n\n\n\nplot_bml_oml_horizon_predictions(df_true = [df_true_default[a:b], df_true_spot[a:b]], target_column=target_column,  df_labels=df_labels, filename=\"./figures/\" + experiment_name+\"_predictions.pdf\")\n\n\n\n\n\nfrom spotPython.plot.validation import plot_actual_vs_predicted\nplot_actual_vs_predicted(y_test=df_true_default[target_column], y_pred=df_true_default[\"Prediction\"], title=\"Default\")\nplot_actual_vs_predicted(y_test=df_true_spot[target_column], y_pred=df_true_spot[\"Prediction\"], title=\"SPOT\")"
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#detailed-hyperparameter-plots",
    "href": "51_spot_hpt_river_friedman_amfr.html#detailed-hyperparameter-plots",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.12 Detailed Hyperparameter Plots",
    "text": "23.12 Detailed Hyperparameter Plots\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)\n\nn_estimators:  100.0\nstep:  1.830769072677768\nuse_aggregation:  0.23767589645409623"
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#parallel-coordinates-plots",
    "href": "51_spot_hpt_river_friedman_amfr.html#parallel-coordinates-plots",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.13 Parallel Coordinates Plots",
    "text": "23.13 Parallel Coordinates Plots\n\nspot_tuner.parallel_plot()"
  },
  {
    "objectID": "51_spot_hpt_river_friedman_amfr.html#plot-all-combinations-of-hyperparameters",
    "href": "51_spot_hpt_river_friedman_amfr.html#plot-all-combinations-of-hyperparameters",
    "title": "23  river Hyperparameter Tuning: Mondrian Tree Regressor with Friedman Drift Data",
    "section": "23.14 Plot all Combinations of Hyperparameters",
    "text": "23.14 Plot all Combinations of Hyperparameters\n\nWarning: this may take a while.\n\n\nPLOT_ALL = False\nif PLOT_ALL:\n    n = spot_tuner.k\n    for i in range(n-1):\n        for j in range(i+1, n):\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z)"
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#sec-setup-13",
    "href": "52_spot_hpt_river_bananas_amfc.html#sec-setup-13",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.1 Setup",
    "text": "22.1 Setup\nBefore we consider the detailed experimental setup, we select the parameters that affect run time, initial design size, size of the data set, and the experiment name.\n\nMAX_TIME: The maximum run time in seconds for the hyperparameter tuning process.\nINIT_SIZE: The initial design size for the hyperparameter tuning process.\nPREFIX: The prefix for the experiment name.\nK: The factor that determines the number of samples in the data set.\n\n\n\n\n\n\n\nCaution: Run time and initial design size should be increased for real experiments\n\n\n\n\nMAX_TIME is set to one minute for demonstration purposes. For real experiments, this should be increased to at least 1 hour.\nINIT_SIZE is set to 5 for demonstration purposes. For real experiments, this should be increased to at least 10.\nK is the multiplier for the number of samples. If it is set to 1, then 100_000samples are taken. It is set to 0.1 for demonstration purposes. For real experiments, this should be increased to at least 1.\n\n\n\n\nMAX_TIME = 1\nINIT_SIZE = 5\nPREFIX=\"52-river\""
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#initialization-of-the-fun_control-dictionary",
    "href": "52_spot_hpt_river_bananas_amfc.html#initialization-of-the-fun_control-dictionary",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.2 Initialization of the fun_control Dictionary",
    "text": "22.2 Initialization of the fun_control Dictionary\nspotPython supports the visualization of the hyperparameter tuning process with TensorBoard. The following example shows how to use TensorBoard with spotPython.\nFirst, we define an “experiment name” to identify the hyperparameter tuning process. The experiment name is also used to create a directory for the TensorBoard files.\n\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_spot_tensorboard_path\nimport os\nfrom spotPython.utils.file import get_experiment_name\nexperiment_name = get_experiment_name(prefix=PREFIX)\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    TENSORBOARD_CLEAN=True)\nprint(experiment_name)\n\n52-river_bartz09_2023-11-03_23-53-04\n\n\n\n\n\n\n\n\nTip: TensorBoard\n\n\n\n\nSince the spot_tensorboard_path argument is not None, which is the default, spotPython will log the optimization process in the TensorBoard folder.\nSection 22.8.4 describes how to start TensorBoard and access the TensorBoard dashboard.\nThe TENSORBOARD_CLEAN argument is set to True to archive the TensorBoard folder if it already exists. This is useful if you want to start a hyperparameter tuning process from scratch. If you want to continue a hyperparameter tuning process, set TENSORBOARD_CLEAN to False. Then the TensorBoard folder will not be archived and the old and new TensorBoard files will shown in the TensorBoard dashboard."
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#load-data-the-bananas-dataset",
    "href": "52_spot_hpt_river_bananas_amfc.html#load-data-the-bananas-dataset",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.3 Load Data: The Bananas Dataset",
    "text": "22.3 Load Data: The Bananas Dataset\nWe will use the Bananas dataset [SOURCE].\nThe following parameters are used to generate and handle the data set:\n\nhorizon: The prediction horizon in hours.\nn_samples: The number of samples in the data set.\nn_train: The number of samples provided for the training.\noml_grace_period: The number of samples that are used for the initial training of the model.\n\n\nhorizon = 53\nn_samples = 5300\nn_train = 100\noml_grace_period = n_train\n\n\nfrom river.datasets import Bananas\nimport pandas as pd\ndataset = Bananas(\n)\n\n\nWe will use spotRiver’s convert_to_df function [SOURCE] to convert the river data set to a pandas data frame.\n\n\nfrom spotRiver.utils.data_conversion import convert_to_df\ntarget_column = \"y\"\ndf = convert_to_df(dataset, target_column=target_column, n_total=n_samples)\ndf.describe(include=\"all\")\n\n\n\n\n\n\n\n\n1\n2\ny\n\n\n\n\ncount\n5.300000e+03\n5.300000e+03\n5300\n\n\nunique\nNaN\nNaN\n2\n\n\ntop\nNaN\nNaN\nFalse\n\n\nfreq\nNaN\nNaN\n2924\n\n\nmean\n-4.150943e-09\n-1.886792e-10\nNaN\n\n\nstd\n1.000000e+00\n1.000000e+00\nNaN\n\n\nmin\n-3.089839e+00\n-2.385937e+00\nNaN\n\n\n25%\n-7.533490e-01\n-9.139027e-01\nNaN\n\n\n50%\n-1.523150e-02\n-3.721500e-02\nNaN\n\n\n75%\n7.818312e-01\n8.221040e-01\nNaN\n\n\nmax\n2.813360e+00\n3.194302e+00\nNaN\n\n\n\n\n\n\n\n\nAdd column names x1 until x2 to the first 2 columns of the dataframe and the column name y to the last column of the dataframe.\nThen split the data frame into a training and test data set. The train and test data sets are stored in the fun_control dictionary.\n\n\ndf.columns = [f\"x{i}\" for i in range(1, dataset.n_features+1)] + [\"y\"]\n# map the target from False to integer 0 and from True to integer 1\ndf[\"y\"] = df[\"y\"].astype(int)\n\nfun_control.update({\"train\":  df[:n_train],\n                    \"oml_grace_period\": oml_grace_period,\n                    \"test\":  df[n_train:],\n                    \"n_samples\": n_samples,\n                    \"target_column\": target_column})"
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#specification-of-the-preprocessing-model",
    "href": "52_spot_hpt_river_bananas_amfc.html#specification-of-the-preprocessing-model",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.4 Specification of the Preprocessing Model",
    "text": "22.4 Specification of the Preprocessing Model\n\nWe use the StandardScaler [SOURCE] from river as the preprocessing model. The StandardScaler is used to standardize the data set, i.e., it has zero mean and unit variance.\n\n\nfrom river import preprocessing\nprep_model = preprocessing.StandardScaler()\nfun_control.update({\"prep_model\": prep_model})"
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#selectselect-model-algorithm-and-core_model_hyper_dict",
    "href": "52_spot_hpt_river_bananas_amfc.html#selectselect-model-algorithm-and-core_model_hyper_dict",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.5 SelectSelect Model (algorithm) and core_model_hyper_dict",
    "text": "22.5 SelectSelect Model (algorithm) and core_model_hyper_dict\nspotPython hyperparameter tuning approach uses two components:\n\na model (class) and\nan associated hyperparameter dictionary.\n\nThe corresponding hyperparameters are loaded from the associated dictionary, which is stored as a JSON file [SOURCE]. The JSON file contains hyperparameter type information, names, and bounds.\nThe method add_core_model_to_fun_control adds the model and the hyperparameter dictionary to the fun_control dictionary.\nAlternatively, you can load a local hyper_dict. Simply set river_hyper_dict.json as the filename. If filenameis set to None, which is the default, the hyper_dict [SOURCE] is loaded from the spotRiver package.\n\nfrom river.forest import AMFClassifier\nfrom spotRiver.data.river_hyper_dict import RiverHyperDict\nfrom spotPython.hyperparameters.values import add_core_model_to_fun_control\nadd_core_model_to_fun_control(core_model=AMFClassifier,\n                              fun_control=fun_control,\n                              hyper_dict=RiverHyperDict,\n                              filename=None)"
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "href": "52_spot_hpt_river_bananas_amfc.html#modify-hyper_dict-hyperparameters-for-the-selected-algorithm-aka-core_model",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.6 Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model",
    "text": "22.6 Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\nAfter the core_model and the core_model_hyper_dict are added to the fun_control dictionary, the hyperparameter tuning can be started. However, in some settings, the user wants to modify the hyperparameters of the core_model_hyper_dict. This can be done with the modify_hyper_parameter_bounds and modify_hyper_parameter_levels functions [SOURCE].\nThe following code shows how hyperparameter of type numeric and integer (boolean) can be modified. The modify_hyper_parameter_bounds function is used to modify the bounds of the hyperparameter delta and merit_preprune. Similar option exists for the modify_hyper_parameter_levels function to modify the levels of categorical hyperparameters.\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_bounds\nmodify_hyper_parameter_bounds(fun_control, \"n_estimators\", bounds=[2,20])\nmodify_hyper_parameter_bounds(fun_control, \"step\", bounds=[0.5,2])\n\n::: {.callout-note} #### Note: Active and Inactive Hyperparameters Hyperparameters can be excluded from the tuning procedure by selecting identical values for the lower and upper bounds.\n\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control))\n\n| name            | type   |   default |   lower |   upper | transform   |\n|-----------------|--------|-----------|---------|---------|-------------|\n| n_estimators    | int    |      10   |    2    |      20 | None        |\n| step            | float  |       1   |    0.5  |       2 | None        |\n| use_aggregation | factor |       1   |    0    |       1 | None        |\n| dirichlet       | float  |       0.5 |    0.01 |       1 | None        |\n| split_pure      | factor |       0   |    0    |       1 | None        |"
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#selection-of-the-objective-loss-function",
    "href": "52_spot_hpt_river_bananas_amfc.html#selection-of-the-objective-loss-function",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.7 Selection of the Objective (Loss) Function",
    "text": "22.7 Selection of the Objective (Loss) Function\nThe metric_sklearn is used for the sklearn based evaluation via eval_oml_horizon [SOURCE]. Here we use the mean_absolute_error [SOURCE] as the objective function.\n\n\n\n\n\n\nNote: Additional metrics\n\n\n\nspotRiver also supports additional metrics. For example, the metric_river is used for the river based evaluation via eval_oml_iter_progressive [SOURCE]. The metric_river is implemented to simulate the behaviour of the “original” river metrics.\n\n\nspotRiver provides information about the model’s score (metric), memory, and time. The hyperparamter tuner requires a single objective. Therefore, a weighted sum of the metric, memory, and time is computed. The weights are defined in the weights array.\n\n\n\n\n\n\nNote: Weights\n\n\n\nThe weights provide a flexible way to define specific requirements, e.g., if the memory is more important than the time, the weight for the memory can be increased.\n\n\nThe oml_grace_period defines the number of observations that are used for the initial training of the model. The weight_coeff defines a multiplier for the results: results are multiplied by (step/n_steps)**weight_coeff, where n_steps is the total number of iterations. Results from the beginning have a lower weight than results from the end if weight_coeff &gt; 1. If weight_coeff == 0, all results have equal weight. Note, that the weight_coeff is only used internally for the tuner and does not affect the results that are used for the evaluation or comparisons.\n\nimport numpy as np\nfrom sklearn.metrics import accuracy_score\n\nweights = np.array([- 1, 1/1000, 1/1000])*10_000.0\nweight_coeff = 1.0\n\nfun_control.update({\n               \"horizon\": horizon,\n               \"oml_grace_period\": oml_grace_period,\n               \"weights\": weights,\n               \"weight_coeff\": weight_coeff,\n               \"metric_sklearn\": accuracy_score\n               })"
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#calling-the-spot-function",
    "href": "52_spot_hpt_river_bananas_amfc.html#calling-the-spot-function",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.8 Calling the SPOT Function",
    "text": "22.8 Calling the SPOT Function\n\n22.8.1 Prepare the SPOT Parameters\nThe hyperparameter tuning configuration is stored in the fun_control dictionary. Since Spot can be used as an optimization algorithm with a similar interface as optimization algorithms from scipy.optimize [LINK], the bounds and variable types have to be specified explicitely. The get_var_type, get_var_name, and get_bound_values functions [SOURCE] implement the required functionality.\n\nGet types and variable names as well as lower and upper bounds for the hyperparameters, so that they can be passed to the Spot function.\n\n\nfrom spotPython.hyperparameters.values import (\n    get_var_type,\n    get_var_name,\n    get_bound_values\n    )\nvar_type = get_var_type(fun_control)\nvar_name = get_var_name(fun_control)\nlower = get_bound_values(fun_control, \"lower\")\nupper = get_bound_values(fun_control, \"upper\")\n\n\n\n22.8.2 The Objective Function\nThe objective function fun_oml_horizon [SOURCE] is selected next.\n\nfrom spotRiver.fun.hyperriver import HyperRiver\nfun = HyperRiver(log_level=50).fun_oml_horizon\n\nThe following code snippet shows how to get the default hyperparameters as an array, so that they can be passed to the Spot function.\n\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nX_start = get_default_hyperparameters_as_array(fun_control)\n\n\n\n22.8.3 Run the Spot Optimizer\nThe class Spot [SOURCE] is the hyperparameter tuning workhorse. It is initialized with the following parameters:\n\nfun: the objective function\nlower: lower bounds of the hyperparameters\nupper: upper bounds of the hyperparameters\nfun_evals: number of function evaluations\nmax_time: maximum time in seconds\ntolerance_x: tolerance for the hyperparameters\nvar_type: variable types of the hyperparameters\nvar_name: variable names of the hyperparameters\nshow_progress: show progress bar\nfun_control: dictionary with control parameters for the objective function\ndesign_control: dictionary with control parameters for the initial design\nsurrogate_control: dictionary with control parameters for the surrogate model\n\n\n\n\n\n\n\nNote: Total run time\n\n\n\nThe total run time may exceed the specified max_time, because the initial design (here: init_size = INIT_SIZE as specified above) is always evaluated, even if this takes longer than max_time.\n\n\n\nfrom spotPython.spot import spot\nfrom math import inf\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   max_time = MAX_TIME,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE},\n                   surrogate_control={\"noise\": False,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_fun_evals\": 10_000},\n                                      log_level=50)\nspot_tuner.run(X_start=X_start)\n\nspotPython tuning: -1.6828589766922688 [#####-----] 45.59% \n\n\nspotPython tuning: -1.6828589766922688 [######----] 55.24% \n\n\nspotPython tuning: -1.6828589766922688 [##########] 97.11% \n\n\nspotPython tuning: -1.6828589766922688 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x177a79650&gt;\n\n\n\n\n22.8.4 TensorBoard\nNow we can start TensorBoard in the background with the following command, where ./runs is the default directory for the TensorBoard log files:\ntensorboard --logdir=\"./runs\"\n\n\n\n\n\n\nTip: TENSORBOARD_PATH\n\n\n\nThe TensorBoard path can be printed with the following command:\n\nfrom spotPython.utils.file import get_tensorboard_path\nget_tensorboard_path(fun_control)\n\n'runs/'\n\n\n\n\nWe can access the TensorBoard web server with the following URL:\nhttp://localhost:6006/\nThe TensorBoard plot illustrates how spotPython can be used as a microscope for the internal mechanisms of the surrogate-based optimization process. Here, one important parameter, the learning rate \\(\\theta\\) of the Kriging surrogate [SOURCE] is plotted against the number of optimization steps.\n\n\n\nTensorBoard visualization of the spotPython optimization process and the surrogate model.\n\n\n\n\n22.8.5 Results\nAfter the hyperparameter tuning run is finished, the results can be saved and reloaded with the following commands:\n\nfrom spotPython.utils.file import save_pickle\nsave_pickle(spot_tuner, experiment_name)\n\n\nfrom spotPython.utils.file import load_pickle\nspot_tuner = load_pickle(experiment_name)\n\nAfter the hyperparameter tuning run is finished, the progress of the hyperparameter tuning can be visualized. The black points represent the performace values (score or metric) of hyperparameter configurations from the initial design, whereas the red points represents the hyperparameter configurations found by the surrogate model based optimization.\n\nspot_tuner.plot_progress(log_y=False, filename=\"./figures/\" + experiment_name+\"_progress.pdf\")\n\n\n\n\nResults can also be printed in tabular form.\n\nprint(gen_design_table(fun_control=fun_control, spot=spot_tuner))\n\n| name            | type   |   default |   lower |   upper |              tuned | transform   |   importance | stars   |\n|-----------------|--------|-----------|---------|---------|--------------------|-------------|--------------|---------|\n| n_estimators    | int    |      10.0 |     2.0 |    20.0 |               14.0 | None        |         2.98 | *       |\n| step            | float  |       1.0 |     0.5 |     2.0 | 0.7838536943593333 | None        |         0.00 |         |\n| use_aggregation | factor |       1.0 |     0.0 |     1.0 |                1.0 | None        |         0.00 |         |\n| dirichlet       | float  |       0.5 |    0.01 |     1.0 | 0.7654943814816635 | None        |         0.37 | .       |\n| split_pure      | factor |       0.0 |     0.0 |     1.0 |                0.0 | None        |       100.00 | ***     |\n\n\nA histogram can be used to visualize the most important hyperparameters.\n\nspot_tuner.plot_importance(threshold=0.0025, filename=\"./figures/\" + experiment_name+\"_importance.pdf\")"
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#get-default-hyperparameters",
    "href": "52_spot_hpt_river_bananas_amfc.html#get-default-hyperparameters",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.9 Get Default Hyperparameters",
    "text": "22.9 Get Default Hyperparameters\nThe default hyperparameters, whihc will be used for a comparion with the tuned hyperparameters, can be obtained with the following commands:\n\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nX_start = get_default_hyperparameters_as_array(fun_control)\nmodel_default = get_one_core_model_from_X(X_start, fun_control)\n\n\n\n\n\n\n\nNote: spotPython tunes numpy arrays\n\n\n\n\nspotPython tunes numpy arrays, i.e., the hyperparameters are stored in a numpy array.\n\n\n\nThe model with the default hyperparameters can be trained and evaluated with the following commands:\n\nfrom spotRiver.evaluation.eval_bml import eval_oml_horizon\n\ndf_eval_default, df_true_default = eval_oml_horizon(\n                    model=model_default,\n                    train=fun_control[\"train\"],\n                    test=fun_control[\"test\"],\n                    target_column=fun_control[\"target_column\"],\n                    horizon=fun_control[\"horizon\"],\n                    oml_grace_period=fun_control[\"oml_grace_period\"],\n                    metric=fun_control[\"metric_sklearn\"],\n                )"
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#get-spot-results",
    "href": "52_spot_hpt_river_bananas_amfc.html#get-spot-results",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.10 Get SPOT Results",
    "text": "22.10 Get SPOT Results\nIn a similar way, we can obtain the hyperparameters found by spotPython.\n\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nmodel_spot = get_one_core_model_from_X(X, fun_control)\n\n\ndf_eval_spot, df_true_spot = eval_oml_horizon(\n                    model=model_spot,\n                    train=fun_control[\"train\"],\n                    test=fun_control[\"test\"],\n                    target_column=fun_control[\"target_column\"],\n                    horizon=fun_control[\"horizon\"],\n                    oml_grace_period=fun_control[\"oml_grace_period\"],\n                    metric=fun_control[\"metric_sklearn\"],\n                )\n\n\nfrom spotRiver.evaluation.eval_bml import plot_bml_oml_horizon_metrics\ndf_labels=[\"default\", \"spot\"]\nplot_bml_oml_horizon_metrics(df_eval = [df_eval_default, df_eval_spot], log_y=False, df_labels=df_labels, metric=fun_control[\"metric_sklearn\"], filename=\"./figures/\" + experiment_name+\"_metrics.pdf\")"
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#compare-predictions",
    "href": "52_spot_hpt_river_bananas_amfc.html#compare-predictions",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.11 Compare Predictions",
    "text": "22.11 Compare Predictions\n\nfrom spotPython.plot.validation import plot_roc_from_dataframes\nplot_roc_from_dataframes([df_true_default, df_true_spot], model_names=[\"default\", \"spot\"], target_column=fun_control[\"target_column\"])  \n\n\n\n\n\nfrom spotPython.plot.validation import plot_confusion_matrix\nplot_confusion_matrix(df=df_true_default, title=\"Default\", y_true_name=fun_control[\"target_column\"], y_pred_name=\"Prediction\")\n\n\n\n\n\nplot_confusion_matrix(df=df_true_spot, title=\"Spot\", y_true_name=fun_control[\"target_column\"], y_pred_name=\"Prediction\")"
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#detailed-hyperparameter-plots",
    "href": "52_spot_hpt_river_bananas_amfc.html#detailed-hyperparameter-plots",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.12 Detailed Hyperparameter Plots",
    "text": "22.12 Detailed Hyperparameter Plots\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)\n\nn_estimators:  2.9837871920597987\ndirichlet:  0.3650771160166603\nsplit_pure:  100.0"
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#parallel-coordinates-plots",
    "href": "52_spot_hpt_river_bananas_amfc.html#parallel-coordinates-plots",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.13 Parallel Coordinates Plots",
    "text": "22.13 Parallel Coordinates Plots\n\nspot_tuner.parallel_plot()"
  },
  {
    "objectID": "52_spot_hpt_river_bananas_amfc.html#plot-all-combinations-of-hyperparameters",
    "href": "52_spot_hpt_river_bananas_amfc.html#plot-all-combinations-of-hyperparameters",
    "title": "22  river Hyperparameter Tuning: Mondrian Tree Classifier with Bananas Data",
    "section": "22.14 Plot all Combinations of Hyperparameters",
    "text": "22.14 Plot all Combinations of Hyperparameters\n\nWarning: this may take a while.\n\n\nPLOT_ALL = False\nif PLOT_ALL:\n    n = spot_tuner.k\n    for i in range(n-1):\n        for j in range(i+1, n):\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z)"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-setup-14",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-setup-14",
    "title": "24  HPT: PyTorch With spotPython and Ray Tune on CIFAR10",
    "section": "24.1 Step 1: Setup",
    "text": "24.1 Step 1: Setup\nBefore we consider the detailed experimental setup, we select the parameters that affect run time, initial design size and the device that is used.\n\n\n\n\n\n\nCaution: Run time and initial design size should be increased for real experiments\n\n\n\n\nMAX_TIME is set to one minute for demonstration purposes. For real experiments, this should be increased to at least 1 hour.\nINIT_SIZE is set to 5 for demonstration purposes. For real experiments, this should be increased to at least 10.\n\n\n\n\n\n\n\n\n\nNote: Device selection\n\n\n\n\nThe device can be selected by setting the variable DEVICE.\nSince we are using a simple neural net, the setting \"cpu\" is preferred (on Mac).\nIf you have a GPU, you can use \"cuda:0\" instead.\nIf DEVICE is set to \"auto\" or None, spotPython will automatically select the device.\n\nThis might result in \"mps\" on Macs, which is not the best choice for simple neural nets.\n\n\n\n\n\nMAX_TIME = 1\nINIT_SIZE = 5\nDEVICE = \"auto\" # \"cpu\"\nPREFIX = \"14-torch\"\n\n\nfrom spotPython.utils.device import getDevice\nDEVICE = getDevice(DEVICE)\nprint(DEVICE)\n\nmps\n\n\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-initialization-fun-control-14",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-initialization-fun-control-14",
    "title": "24  HPT: PyTorch With spotPython and Ray Tune on CIFAR10",
    "section": "24.2 Step 2: Initialization of the fun_control Dictionary",
    "text": "24.2 Step 2: Initialization of the fun_control Dictionary\nspotPython uses a Python dictionary for storing the information required for the hyperparameter tuning process. This dictionary is called fun_control and is initialized with the function fun_control_init. The function fun_control_init returns a skeleton dictionary. The dictionary is filled with the required information for the hyperparameter tuning process. It stores the hyperparameter tuning settings, e.g., the deep learning network architecture that should be tuned, the classification (or regression) problem, and the data that is used for the tuning. The dictionary is used as an input for the SPOT function.\n\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_experiment_name, get_spot_tensorboard_path\nfrom spotPython.utils.device import getDevice\n\nexperiment_name = get_experiment_name(prefix=PREFIX)\n\nfun_control = fun_control_init(\n    task=\"classification\",\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    device=DEVICE,)"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-data-loading-14",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-data-loading-14",
    "title": "24  HPT: PyTorch With spotPython and Ray Tune on CIFAR10",
    "section": "24.3 Step 3: PyTorch Data Loading",
    "text": "24.3 Step 3: PyTorch Data Loading\nThe data loading process is implemented in the same manner as described in the Section “Data loaders” in PyTorch (2023a). The data loaders are wrapped into the function load_data_cifar10 which is identical to the function load_data in PyTorch (2023a). A global data directory is used, which allows sharing the data directory between different trials. The method load_data_cifar10 is part of the spotPython package and can be imported from spotPython.data.torchdata.\nIn the following step, the test and train data are added to the dictionary fun_control.\n\nfrom spotPython.data.torchdata import load_data_cifar10\ntrain, test = load_data_cifar10()\nn_samples = len(train)\n# add the dataset to the fun_control\nfun_control.update({\n    \"train\": train,\n    \"test\": test,\n    \"n_samples\": n_samples})\n\nFiles already downloaded and verified\n\n\nFiles already downloaded and verified"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-specification-of-preprocessing-model-14",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-specification-of-preprocessing-model-14",
    "title": "24  HPT: PyTorch With spotPython and Ray Tune on CIFAR10",
    "section": "24.4 Step 4: Specification of the Preprocessing Model",
    "text": "24.4 Step 4: Specification of the Preprocessing Model\nAfter the training and test data are specified and added to the fun_control dictionary, spotPython allows the specification of a data preprocessing pipeline, e.g., for the scaling of the data or for the one-hot encoding of categorical variables. The preprocessing model is called prep_model (“preparation” or pre-processing) and includes steps that are not subject to the hyperparameter tuning process. The preprocessing model is specified in the fun_control dictionary. The preprocessing model can be implemented as a sklearn pipeline. The following code shows a typical preprocessing pipeline:\ncategorical_columns = [\"cities\", \"colors\"]\none_hot_encoder = OneHotEncoder(handle_unknown=\"ignore\",\n                                    sparse_output=False)\nprep_model = ColumnTransformer(\n        transformers=[\n             (\"categorical\", one_hot_encoder, categorical_columns),\n         ],\n         remainder=StandardScaler(),\n     )\nBecause the Ray Tune (ray[tune]) hyperparameter tuning as described in PyTorch (2023a) does not use a preprocessing model, the preprocessing model is set to None here.\n\nprep_model = None\nfun_control.update({\"prep_model\": prep_model})"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-selection-of-the-algorithm-14",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-selection-of-the-algorithm-14",
    "title": "24  HPT: PyTorch With spotPython and Ray Tune on CIFAR10",
    "section": "24.5 Step 5: Select Model (algorithm) and core_model_hyper_dict",
    "text": "24.5 Step 5: Select Model (algorithm) and core_model_hyper_dict\nThe same neural network model as implemented in the section “Configurable neural network” of the PyTorch tutorial (PyTorch 2023a) is used here. We will show the implementation from PyTorch (2023a) in Section 24.5.0.1 first, before the extended implementation with spotPython is shown in Section 24.5.0.2.\n\n24.5.0.1 Implementing a Configurable Neural Network With Ray Tune\nWe used the same hyperparameters that are implemented as configurable in the PyTorch tutorial. We specify the layer sizes, namely l1 and l2, of the fully connected layers:\nclass Net(nn.Module):\n    def __init__(self, l1=120, l2=84):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, l1)\n        self.fc2 = nn.Linear(l1, l2)\n        self.fc3 = nn.Linear(l2, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(-1, 16 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n\nThe learning rate, i.e., lr, of the optimizer is made configurable, too:\noptimizer = optim.SGD(net.parameters(), lr=config[\"lr\"], momentum=0.9)\n\n\n24.5.0.2 Implementing a Configurable Neural Network With spotPython\nspotPython implements a class which is similar to the class described in the PyTorch tutorial. The class is called Net_CIFAR10 and is implemented in the file netcifar10.py.\nfrom torch import nn\nimport torch.nn.functional as F\nimport spotPython.torch.netcore as netcore\n\n\nclass Net_CIFAR10(netcore.Net_Core):\n    def __init__(self, l1, l2, lr_mult, batch_size, epochs, k_folds, patience,\n    optimizer, sgd_momentum):\n        super(Net_CIFAR10, self).__init__(\n            lr_mult=lr_mult,\n            batch_size=batch_size,\n            epochs=epochs,\n            k_folds=k_folds,\n            patience=patience,\n            optimizer=optimizer,\n            sgd_momentum=sgd_momentum,\n        )\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, l1)\n        self.fc2 = nn.Linear(l1, l2)\n        self.fc3 = nn.Linear(l2, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(-1, 16 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n\n\n24.5.1 The Net_Core class\nNet_CIFAR10 inherits from the class Net_Core which is implemented in the file netcore.py. It implements the additional attributes that are common to all neural network models. The Net_Core class is implemented in the file netcore.py. It implements hyperparameters as attributes, that are not used by the core_model, e.g.:\n\noptimizer (optimizer),\nlearning rate (lr),\nbatch size (batch_size),\nepochs (epochs),\nk_folds (k_folds), and\nearly stopping criterion “patience” (patience).\n\nUsers can add further attributes to the class. The class Net_Core is shown below.\nfrom torch import nn\n\n\nclass Net_Core(nn.Module):\n    def __init__(self, lr_mult, batch_size, epochs, k_folds, patience,\n        optimizer, sgd_momentum):\n        super(Net_Core, self).__init__()\n        self.lr_mult = lr_mult\n        self.batch_size = batch_size\n        self.epochs = epochs\n        self.k_folds = k_folds\n        self.patience = patience\n        self.optimizer = optimizer\n        self.sgd_momentum = sgd_momentum\n\n\n24.5.2 Comparison of the Approach Described in the PyTorch Tutorial With spotPython\nComparing the class Net from the PyTorch tutorial and the class Net_CIFAR10 from spotPython, we see that the class Net_CIFAR10 has additional attributes and does not inherit from nn directly. It adds an additional class, Net_core, that takes care of additional attributes that are common to all neural network models, e.g., the learning rate multiplier lr_mult or the batch size batch_size.\nspotPython’s core_model implements an instance of the Net_CIFAR10 class. In addition to the basic neural network model, the core_model can use these additional attributes. spotPython provides methods for handling these additional attributes to guarantee 100% compatibility with the PyTorch classes. The method add_core_model_to_fun_control adds the hyperparameters and additional attributes to the fun_control dictionary. The method is shown below.\n\nfrom spotPython.torch.netcifar10 import Net_CIFAR10\nfrom spotPython.data.torch_hyper_dict import TorchHyperDict\nfrom spotPython.hyperparameters.values import add_core_model_to_fun_control\ncore_model = Net_CIFAR10\nadd_core_model_to_fun_control(core_model=core_model,\n                              fun_control=fun_control,\n                              hyper_dict=TorchHyperDict,\n                              filename=None)\n\n\n\n24.5.3 The Search Space: Hyperparameters\nIn Section 24.5.4, we first describe how to configure the search space with ray[tune] (as shown in PyTorch (2023a)) and then how to configure the search space with spotPython in -14.\n\n\n24.5.4 Configuring the Search Space With Ray Tune\nRay Tune’s search space can be configured as follows (PyTorch 2023a):\nconfig = {\n    \"l1\": tune.sample_from(lambda _: 2**np.random.randint(2, 9)),\n    \"l2\": tune.sample_from(lambda _: 2**np.random.randint(2, 9)),\n    \"lr\": tune.loguniform(1e-4, 1e-1),\n    \"batch_size\": tune.choice([2, 4, 8, 16])\n}\nThe tune.sample_from() function enables the user to define sample methods to obtain hyperparameters. In this example, the l1 and l2 parameters should be powers of 2 between 4 and 256, so either 4, 8, 16, 32, 64, 128, or 256. The lr (learning rate) should be uniformly sampled between 0.0001 and 0.1. Lastly, the batch size is a choice between 2, 4, 8, and 16.\nAt each trial, ray[tune] will randomly sample a combination of parameters from these search spaces. It will then train a number of models in parallel and find the best performing one among these. ray[tune] uses the ASHAScheduler which will terminate bad performing trials early.\n\n\n24.5.5 Configuring the Search Space With spotPython\n\n24.5.5.1 The hyper_dict Hyperparameters for the Selected Algorithm\nspotPython uses JSON files for the specification of the hyperparameters. Users can specify their individual JSON files, or they can use the JSON files provided by spotPython. The JSON file for the core_model is called torch_hyper_dict.json.\nIn contrast to ray[tune], spotPython can handle numerical, boolean, and categorical hyperparameters. They can be specified in the JSON file in a similar way as the numerical hyperparameters as shown below. Each entry in the JSON file represents one hyperparameter with the following structure: type, default, transform, lower, and upper.\n\"factor_hyperparameter\": {\n    \"levels\": [\"A\", \"B\", \"C\"],\n    \"type\": \"factor\",\n    \"default\": \"B\",\n    \"transform\": \"None\",\n    \"core_model_parameter_type\": \"str\",\n    \"lower\": 0,\n    \"upper\": 2},\nThe corresponding entries for the core_model` class are shown below.\n\nfun_control['core_model_hyper_dict']\n\n{'l1': {'type': 'int',\n  'default': 5,\n  'transform': 'transform_power_2_int',\n  'lower': 2,\n  'upper': 9},\n 'l2': {'type': 'int',\n  'default': 5,\n  'transform': 'transform_power_2_int',\n  'lower': 2,\n  'upper': 9},\n 'lr_mult': {'type': 'float',\n  'default': 1.0,\n  'transform': 'None',\n  'lower': 0.1,\n  'upper': 10.0},\n 'batch_size': {'type': 'int',\n  'default': 4,\n  'transform': 'transform_power_2_int',\n  'lower': 1,\n  'upper': 4},\n 'epochs': {'type': 'int',\n  'default': 3,\n  'transform': 'transform_power_2_int',\n  'lower': 3,\n  'upper': 4},\n 'k_folds': {'type': 'int',\n  'default': 1,\n  'transform': 'None',\n  'lower': 1,\n  'upper': 1},\n 'patience': {'type': 'int',\n  'default': 5,\n  'transform': 'None',\n  'lower': 2,\n  'upper': 10},\n 'optimizer': {'levels': ['Adadelta',\n   'Adagrad',\n   'Adam',\n   'AdamW',\n   'SparseAdam',\n   'Adamax',\n   'ASGD',\n   'NAdam',\n   'RAdam',\n   'RMSprop',\n   'Rprop',\n   'SGD'],\n  'type': 'factor',\n  'default': 'SGD',\n  'transform': 'None',\n  'class_name': 'torch.optim',\n  'core_model_parameter_type': 'str',\n  'lower': 0,\n  'upper': 12},\n 'sgd_momentum': {'type': 'float',\n  'default': 0.0,\n  'transform': 'None',\n  'lower': 0.0,\n  'upper': 1.0}}"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-modification-of-hyperparameters-14",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-modification-of-hyperparameters-14",
    "title": "24  HPT: PyTorch With spotPython and Ray Tune on CIFAR10",
    "section": "24.6 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model",
    "text": "24.6 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\nRay tune (PyTorch 2023a) does not provide a way to change the specified hyperparameters without re-compilation. However, spotPython provides functions for modifying the hyperparameters, their bounds and factors as well as for activating and de-activating hyperparameters without re-compilation of the Python source code. These functions are described in the following.\n\n24.6.0.1 Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\nAfter specifying the model, the corresponding hyperparameters, their types and bounds are loaded from the JSON file torch_hyper_dict.json. After loading, the user can modify the hyperparameters, e.g., the bounds. spotPython provides a simple rule for de-activating hyperparameters: If the lower and the upper bound are set to identical values, the hyperparameter is de-activated. This is useful for the hyperparameter tuning, because it allows to specify a hyperparameter in the JSON file, but to de-activate it in the fun_control dictionary. This is done in the next step.\n\n\n24.6.0.2 Modify Hyperparameters of Type numeric and integer (boolean)\nSince the hyperparameter k_folds is not used in the PyTorch tutorial, it is de-activated here by setting the lower and upper bound to the same value. Note, k_folds is of type “integer”.\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_bounds\nmodify_hyper_parameter_bounds(fun_control, \n    \"batch_size\", bounds=[1, 5])\nmodify_hyper_parameter_bounds(fun_control, \n    \"k_folds\", bounds=[0, 0])\nmodify_hyper_parameter_bounds(fun_control, \n    \"patience\", bounds=[3, 3])\n\n\n\n24.6.0.3 Modify Hyperparameter of Type factor\nIn a similar manner as for the numerical hyperparameters, the categorical hyperparameters can be modified. New configurations can be chosen by adding or deleting levels. For example, the hyperparameter optimizer can be re-configured as follows:\nIn the following setting, two optimizers (\"SGD\" and \"Adam\") will be compared during the spotPython hyperparameter tuning. The hyperparameter optimizer is active.\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_levels\nmodify_hyper_parameter_levels(fun_control,\n     \"optimizer\", [\"SGD\", \"Adam\"])\n\nThe hyperparameter optimizer can be de-activated by choosing only one value (level), here: \"SGD\".\n\nmodify_hyper_parameter_levels(fun_control, \"optimizer\", [\"SGD\"])\n\nAs discussed in Section 24.6.1, there are some issues with the LBFGS optimizer. Therefore, the usage of the LBFGS optimizer is not deactivated in spotPython by default. However, the LBFGS optimizer can be activated by adding it to the list of optimizers. Rprop was removed, because it does perform very poorly (as some pre-tests have shown). However, it can also be activated by adding it to the list of optimizers. Since SparseAdam does not support dense gradients, Adam was used instead. Therefore, there are 10 default optimizers:\n\nmodify_hyper_parameter_levels(fun_control, \"optimizer\",\n    [\"Adadelta\", \"Adagrad\", \"Adam\", \"AdamW\", \"Adamax\", \"ASGD\", \n    \"NAdam\", \"RAdam\", \"RMSprop\", \"SGD\"])\n\n\n\n24.6.1 Optimizers\nTable 24.1 shows some of the optimizers available in PyTorch:\n\\(a\\) denotes (0.9,0.999), \\(b\\) (0.5,1.2), and \\(c\\) (1e-6, 50), respectively. \\(R\\) denotes required, but unspecified. “m” denotes momentum, “w_d” weight_decay, “d” dampening, “n” nesterov, “r” rho, “l_s” learning rate for scaling delta, “l_d” lr_decay, “b” betas, “l” lambd, “a” alpha, “m_d” for momentum_decay, “e” etas, and “s_s” for step_sizes.\n\n\nTable 24.1: Optimizers available in PyTorch (selection). The default values are shown in the table.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOptimizer\nlr\nm\nw_d\nd\nn\nr\nl_s\nl_d\nb\nl\na\nm_d\ne\ns_s\n\n\n\n\nAdadelta\n-\n-\n0.\n-\n-\n0.9\n1.\n-\n-\n-\n-\n-\n-\n-\n\n\nAdagrad\n1e-2\n-\n0.\n-\n-\n-\n-\n0.\n-\n-\n-\n-\n-\n-\n\n\nAdam\n1e-3\n-\n0.\n-\n-\n-\n-\n-\n\\(a\\)\n-\n-\n-\n-\n-\n\n\nAdamW\n1e-3\n-\n1e-2\n-\n-\n-\n-\n-\n\\(a\\)\n-\n-\n-\n-\n-\n\n\nSparseAdam\n1e-3\n-\n-\n-\n-\n-\n-\n-\n\\(a\\)\n-\n-\n-\n-\n-\n\n\nAdamax\n2e-3\n-\n0.\n-\n-\n-\n-\n-\n\\(a\\)\n-\n-\n-\n-\n-\n\n\nASGD\n1e-2\n.9\n0.\n-\nF\n-\n-\n-\n-\n1e-4\n.75\n-\n-\n-\n\n\nLBFGS\n1.\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\n\nNAdam\n2e-3\n-\n0.\n-\n-\n-\n-\n-\n\\(a\\)\n-\n-\n0\n-\n-\n\n\nRAdam\n1e-3\n-\n0.\n-\n-\n-\n-\n-\n\\(a\\)\n-\n-\n-\n-\n-\n\n\nRMSprop\n1e-2\n0.\n0.\n-\n-\n-\n-\n-\n\\(a\\)\n-\n-\n-\n-\n-\n\n\nRprop\n1e-2\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\\(b\\)\n\\(c\\)\n-\n-\n\n\nSGD\n\\(R\\)\n0.\n0.\n0.\nF\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\n\n\n\nspotPython implements an optimization handler that maps the optimizer names to the corresponding PyTorch optimizers.\n\n\n\n\n\n\nA note on LBFGS\n\n\n\nWe recommend deactivating PyTorch’s LBFGS optimizer, because it does not perform very well. The PyTorch documentation, see https://pytorch.org/docs/stable/generated/torch.optim.LBFGS.html#torch.optim.LBFGS, states:\n\nThis is a very memory intensive optimizer (it requires additional param_bytes * (history_size + 1) bytes). If it doesn’t fit in memory try reducing the history size, or use a different algorithm.\n\nFurthermore, the LBFGS optimizer is not compatible with the PyTorch tutorial. The reason is that the LBFGS optimizer requires the closure function, which is not implemented in the PyTorch tutorial. Therefore, the LBFGS optimizer is recommended here. Since there are ten optimizers in the portfolio, it is not recommended tuning the hyperparameters that effect one single optimizer only.\n\n\n\n\n\n\n\n\nA note on the learning rate\n\n\n\nspotPython provides a multiplier for the default learning rates, lr_mult, because optimizers use different learning rates. Using a multiplier for the learning rates might enable a simultaneous tuning of the learning rates for all optimizers. However, this is not recommended, because the learning rates are not comparable across optimizers. Therefore, we recommend fixing the learning rate for all optimizers if multiple optimizers are used. This can be done by setting the lower and upper bounds of the learning rate multiplier to the same value as shown below.\nThus, the learning rate, which affects the SGD optimizer, will be set to a fixed value. We choose the default value of 1e-3 for the learning rate, because it is used in other PyTorch examples (it is also the default value used by spotPython as defined in the optimizer_handler() method). We recommend tuning the learning rate later, when a reduced set of optimizers is fixed. Here, we will demonstrate how to select in a screening phase the optimizers that should be used for the hyperparameter tuning.\n\n\nFor the same reason, we will fix the sgd_momentum to 0.9.\n\nmodify_hyper_parameter_bounds(fun_control,\n    \"lr_mult\", bounds=[1.0, 1.0])\nmodify_hyper_parameter_bounds(fun_control,\n    \"sgd_momentum\", bounds=[0.9, 0.9])"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#step-7-selection-of-the-objective-loss-function",
    "href": "14_spot_ray_hpt_torch_cifar10.html#step-7-selection-of-the-objective-loss-function",
    "title": "24  HPT: PyTorch With spotPython and Ray Tune on CIFAR10",
    "section": "24.7 Step 7: Selection of the Objective (Loss) Function",
    "text": "24.7 Step 7: Selection of the Objective (Loss) Function\n\n24.7.1 Evaluation: Data Splitting\nThe evaluation procedure requires the specification of the way how the data is split into a train and a test set and the loss function (and a metric). As a default, spotPython provides a standard hold-out data split and cross validation.\n\n\n24.7.2 Hold-out Data Split\nIf a hold-out data split is used, the data will be partitioned into a training, a validation, and a test data set. The split depends on the setting of the eval parameter. If eval is set to train_hold_out, one data set, usually the original training data set, is split into a new training and a validation data set. The training data set is used for training the model. The validation data set is used for the evaluation of the hyperparameter configuration and early stopping to prevent overfitting. In this case, the original test data set is not used.\n\n\n\n\n\n\nNote\n\n\n\nspotPython returns the hyperparameters of the machine learning and deep learning models, e.g., number of layers, learning rate, or optimizer, but not the model weights. Therefore, after the SPOT run is finished, the corresponding model with the optimized architecture has to be trained again with the best hyperparameter configuration. The training is performed on the training data set. The test data set is used for the final evaluation of the model.\nSummarizing, the following splits are performed in the hold-out setting:\n\nRun spotPython with eval set to train_hold_out to determine the best hyperparameter configuration.\nTrain the model with the best hyperparameter configuration (“architecture”) on the training data set: train_tuned(model_spot, train, \"model_spot.pt\").\nTest the model on the test data: test_tuned(model_spot, test, \"model_spot.pt\")\n\nThese steps will be exemplified in the following sections.\n\n\nIn addition to this hold-out setting, spotPython provides another hold-out setting, where an explicit test data is specified by the user that will be used as the validation set. To choose this option, the eval parameter is set to test_hold_out. In this case, the training data set is used for the model training. Then, the explicitly defined test data set is used for the evaluation of the hyperparameter configuration (the validation).\n\n\n24.7.3 Cross-Validation\nThe cross validation setting is used by setting the eval parameter to train_cv or test_cv. In both cases, the data set is split into \\(k\\) folds. The model is trained on \\(k-1\\) folds and evaluated on the remaining fold. This is repeated \\(k\\) times, so that each fold is used exactly once for evaluation. The final evaluation is performed on the test data set. The cross validation setting is useful for small data sets, because it allows to use all data for training and evaluation. However, it is computationally expensive, because the model has to be trained \\(k\\) times.\n\n\n\n\n\n\nNote\n\n\n\nCombinations of the above settings are possible, e.g., cross validation can be used for training and hold-out for evaluation or vice versa. Also, cross validation can be used for training and testing. Because cross validation is not used in the PyTorch tutorial (PyTorch 2023a), it is not considered further here.\n\n\n\n\n24.7.4 Overview of the Evaluation Settings\n\n24.7.4.1 Settings for the Hyperparameter Tuning\nAn overview of the training evaluations is shown in Table 24.2. \"train_cv\" and \"test_cv\" use sklearn.model_selection.KFold() internally. More details on the data splitting are provided in Section D.15 (in the Appendix).\n\n\nTable 24.2: Overview of the evaluation settings.\n\n\n\n\n\n\n\n\n\neval\ntrain\ntest\nfunction\ncomment\n\n\n\n\n\"train_hold_out\"\n\\(\\checkmark\\)\n\ntrain_one_epoch(), validate_one_epoch() for early stopping\nsplits the train data set internally\n\n\n\"test_hold_out\"\n\\(\\checkmark\\)\n\\(\\checkmark\\)\ntrain_one_epoch(), validate_one_epoch() for early stopping\nuse the test data set for validate_one_epoch()\n\n\n\"train_cv\"\n\\(\\checkmark\\)\n\nevaluate_cv(net, train)\nCV using the train data set\n\n\n\"test_cv\"\n\n\\(\\checkmark\\)\nevaluate_cv(net, test)\nCV using the test data set . Identical to \"train_cv\", uses only test data.\n\n\n\n\n\n\n24.7.4.2 Settings for the Final Evaluation of the Tuned Architecture\n\n24.7.4.2.1 Training of the Tuned Architecture\ntrain_tuned(model, train): train the model with the best hyperparameter configuration (or simply the default) on the training data set. It splits the traindata into new train and validation sets using create_train_val_data_loaders(), which calls torch.utils.data.random_split() internally. Currently, 60% of the data is used for training and 40% for validation. The train data is used for training the model with train_hold_out(). The validation data is used for early stopping using validate_fold_or_hold_out() on the validation data set.\n\n\n24.7.4.2.2 Testing of the Tuned Architecture\ntest_tuned(model, test): test the model on the test data set. No data splitting is performed. The (trained) model is evaluated using the validate_fold_or_hold_out() function. Note: During training, \"shuffle\" is set to True, whereas during testing, \"shuffle\" is set to False.\nSection D.15.1.4 describes the final evaluation of the tuned architecture.\n\nfun_control.update({\n    \"eval\": \"train_hold_out\",\n    \"path\": \"torch_model.pt\",\n    \"shuffle\": True})\n\n\n\n\n\n24.7.5 Evaluation: Loss Functions and Metrics\nThe key \"loss_function\" specifies the loss function which is used during the optimization. There are several different loss functions under PyTorch’s nn package. For example, a simple loss is MSELoss, which computes the mean-squared error between the output and the target. In this tutorial we will use CrossEntropyLoss, because it is also used in the PyTorch tutorial.\n\nfrom torch.nn import CrossEntropyLoss\nloss_function = CrossEntropyLoss()\nfun_control.update({\"loss_function\": loss_function})\n\nIn addition to the loss functions, spotPython provides access to a large number of metrics.\n\nThe key \"metric_sklearn\" is used for metrics that follow the scikit-learn conventions.\nThe key \"river_metric\" is used for the river based evaluation (Montiel et al. 2021) via eval_oml_iter_progressive, and\nthe key \"metric_torch\" is used for the metrics from TorchMetrics.\n\nTorchMetrics is a collection of more than 90 PyTorch metrics, see https://torchmetrics.readthedocs.io/en/latest/. Because the PyTorch tutorial uses the accuracy as metric, we use the same metric here. Currently, accuracy is computed in the tutorial’s example code. We will use TorchMetrics instead, because it offers more flexibilty, e.g., it can be used for regression and classification. Furthermore, TorchMetrics offers the following advantages:\n* A standardized interface to increase reproducibility\n* Reduces Boilerplate\n* Distributed-training compatible\n* Rigorously tested\n* Automatic accumulation over batches\n* Automatic synchronization between multiple devices\nTherefore, we set\n\nimport torchmetrics\nmetric_torch = torchmetrics.Accuracy(task=\"multiclass\", num_classes=10).to(fun_control[\"device\"])\nfun_control.update({\"metric_torch\": metric_torch})"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#step-8-calling-the-spot-function",
    "href": "14_spot_ray_hpt_torch_cifar10.html#step-8-calling-the-spot-function",
    "title": "24  HPT: PyTorch With spotPython and Ray Tune on CIFAR10",
    "section": "24.8 Step 8: Calling the SPOT Function",
    "text": "24.8 Step 8: Calling the SPOT Function\n\n24.8.1 Preparing the SPOT Call\nThe following code passes the information about the parameter ranges and bounds to spot.\n\nfrom spotPython.hyperparameters.values import (\n    get_var_type,\n    get_var_name,\n    get_bound_values\n    )\nvar_type = get_var_type(fun_control)\nvar_name = get_var_name(fun_control)\n\nlower = get_bound_values(fun_control, \"lower\")\nupper = get_bound_values(fun_control, \"upper\")\n\nNow, the dictionary fun_control contains all information needed for the hyperparameter tuning. Before the hyperparameter tuning is started, it is recommended to take a look at the experimental design. The method gen_design_table generates a design table as follows:\n\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control))\n\n| name         | type   | default   |   lower |   upper | transform             |\n|--------------|--------|-----------|---------|---------|-----------------------|\n| l1           | int    | 5         |     2   |     9   | transform_power_2_int |\n| l2           | int    | 5         |     2   |     9   | transform_power_2_int |\n| lr_mult      | float  | 1.0       |     1   |     1   | None                  |\n| batch_size   | int    | 4         |     1   |     5   | transform_power_2_int |\n| epochs       | int    | 3         |     3   |     4   | transform_power_2_int |\n| k_folds      | int    | 1         |     0   |     0   | None                  |\n| patience     | int    | 5         |     3   |     3   | None                  |\n| optimizer    | factor | SGD       |     0   |     9   | None                  |\n| sgd_momentum | float  | 0.0       |     0.9 |     0.9 | None                  |\n\n\nThis allows to check if all information is available and if the information is correct. ?tbl-design shows the experimental design for the hyperparameter tuning. The table shows the hyperparameters, their types, default values, lower and upper bounds, and the transformation function. The transformation function is used to transform the hyperparameter values from the unit hypercube to the original domain. The transformation function is applied to the hyperparameter values before the evaluation of the objective function. Hyperparameter transformations are shown in the column “transform”, e.g., the l1 default is 5, which results in the value \\(2^5 = 32\\) for the network, because the transformation transform_power_2_int was selected in the JSON file. The default value of the batch_size is set to 4, which results in a batch size of \\(2^4 = 16\\).\n\n\n24.8.2 The Objective Function fun_torch\nThe objective function fun_torch is selected next. It implements an interface from PyTorch’s training, validation, and testing methods to spotPython.\n\nfrom spotPython.fun.hypertorch import HyperTorch\nfun = HyperTorch().fun_torch\n\n\n\n24.8.3 Using Default Hyperparameters or Results from Previous Runs\nWe add the default setting to the initial design:\n\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nX_start = get_default_hyperparameters_as_array(fun_control)\n\n\n\n24.8.4 Starting the Hyperparameter Tuning\nThe spotPython hyperparameter tuning is started by calling the Spot function. Here, we will run the tuner for approximately 30 minutes (max_time). Note: the initial design is always evaluated in the spotPython run. As a consequence, the run may take longer than specified by max_time, because the evaluation time of initial design (here: init_size, 10 points) is performed independently of max_time. During the run, results from the training is shown. These results can be visualized with Tensorboard as will be shown in Section 24.9.\n\nfrom spotPython.spot import spot\nfrom math import inf\nimport numpy as np\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   max_time = MAX_TIME,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE},\n                   surrogate_control={\"noise\": True,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_fun_evals\": 10_000\n                                      })\nspot_tuner.run(X_start=X_start)\n\n\nconfig: {'l1': 128, 'l2': 8, 'lr_mult': 1.0, 'batch_size': 32, 'epochs': 16, 'k_folds': 0, 'patience': 3, 'optimizer': 'AdamW', 'sgd_momentum': 0.9}\nEpoch: 1 | \n\n\nMulticlassAccuracy: 0.3838500082492828 | Loss: 1.6562047554016113 | Acc: 0.3838500000000000.\nEpoch: 2 | \n\n\nMulticlassAccuracy: 0.4587000012397766 | Loss: 1.4801345227241516 | Acc: 0.4587000000000000.\nEpoch: 3 | \n\n\nMulticlassAccuracy: 0.5033000111579895 | Loss: 1.3707357211112976 | Acc: 0.5033000000000000.\nEpoch: 4 | \n\n\nMulticlassAccuracy: 0.5238500237464905 | Loss: 1.3132523689270019 | Acc: 0.5238500000000000.\nEpoch: 5 | \n\n\nMulticlassAccuracy: 0.5549499988555908 | Loss: 1.2375486762046815 | Acc: 0.5549500000000001.\nEpoch: 6 | \n\n\nMulticlassAccuracy: 0.5734999775886536 | Loss: 1.2021079837799071 | Acc: 0.5735000000000000.\nEpoch: 7 | \n\n\nMulticlassAccuracy: 0.5772500038146973 | Loss: 1.1980135177612306 | Acc: 0.5772500000000000.\nEpoch: 8 | \n\n\nMulticlassAccuracy: 0.5938000082969666 | Loss: 1.1599345854759215 | Acc: 0.5938000000000000.\nEpoch: 9 | \n\n\nMulticlassAccuracy: 0.6009500026702881 | Loss: 1.1328843992233277 | Acc: 0.6009500000000000.\nEpoch: 10 | \n\n\nMulticlassAccuracy: 0.6024000048637390 | Loss: 1.1520775830268859 | Acc: 0.6024000000000000.\nEpoch: 11 | \n\n\nMulticlassAccuracy: 0.6004999876022339 | Loss: 1.1797576458930970 | Acc: 0.6005000000000000.\nEpoch: 12 | \n\n\nMulticlassAccuracy: 0.6086500287055969 | Loss: 1.1477203011512755 | Acc: 0.6086500000000000.\nEarly stopping at epoch 11\nReturned to Spot: Validation loss: 1.1477203011512755\n\nconfig: {'l1': 16, 'l2': 16, 'lr_mult': 1.0, 'batch_size': 8, 'epochs': 8, 'k_folds': 0, 'patience': 3, 'optimizer': 'NAdam', 'sgd_momentum': 0.9}\nEpoch: 1 | \n\n\nMulticlassAccuracy: 0.4344500005245209 | Loss: 1.5370126734256744 | Acc: 0.4344500000000000.\nEpoch: 2 | \n\n\nMulticlassAccuracy: 0.4992499947547913 | Loss: 1.3821711903572083 | Acc: 0.4992500000000000.\nEpoch: 3 | \n\n\nMulticlassAccuracy: 0.5210499763488770 | Loss: 1.3544268280982972 | Acc: 0.5210500000000000.\nEpoch: 4 | \n\n\nMulticlassAccuracy: 0.5225499868392944 | Loss: 1.3431447335362434 | Acc: 0.5225500000000000.\nEpoch: 5 | \n\n\nMulticlassAccuracy: 0.5267999768257141 | Loss: 1.3126116187691688 | Acc: 0.5268000000000000.\nEpoch: 6 | \n\n\nMulticlassAccuracy: 0.5393000245094299 | Loss: 1.3071551247596740 | Acc: 0.5393000000000000.\nEpoch: 7 | \n\n\nMulticlassAccuracy: 0.5383499860763550 | Loss: 1.3307678449213505 | Acc: 0.5383500000000000.\nEpoch: 8 | \n\n\nMulticlassAccuracy: 0.5449500083923340 | Loss: 1.2984912836074829 | Acc: 0.5449500000000000.\nReturned to Spot: Validation loss: 1.298491283607483\n\nconfig: {'l1': 256, 'l2': 128, 'lr_mult': 1.0, 'batch_size': 2, 'epochs': 16, 'k_folds': 0, 'patience': 3, 'optimizer': 'RMSprop', 'sgd_momentum': 0.9}\nEpoch: 1 | \n\n\nMulticlassAccuracy: 0.1054999977350235 | Loss: 2.3146803474247455 | Acc: 0.1055000000000000.\nEpoch: 2 | \n\n\nMulticlassAccuracy: 0.1067499965429306 | Loss: 2.3664452521443367 | Acc: 0.1067500000000000.\nEpoch: 3 | \n\n\nMulticlassAccuracy: 0.0958999991416931 | Loss: 2.3053415326595306 | Acc: 0.0959000000000000.\nEpoch: 4 | \n\n\nMulticlassAccuracy: 0.1058500036597252 | Loss: 2.3030879536867142 | Acc: 0.1058500000000000.\nEpoch: 5 | \n\n\nMulticlassAccuracy: 0.1409499943256378 | Loss: 2.5993600514886870 | Acc: 0.1409500000000000.\nEpoch: 6 | \n\n\nMulticlassAccuracy: 0.0986500009894371 | Loss: 2.3089555664300918 | Acc: 0.0986500000000000.\nEpoch: 7 | \n\n\nMulticlassAccuracy: 0.0958499982953072 | Loss: 2.3065662771463393 | Acc: 0.0958500000000000.\nEarly stopping at epoch 6\nReturned to Spot: Validation loss: 2.3065662771463393\n\nconfig: {'l1': 8, 'l2': 32, 'lr_mult': 1.0, 'batch_size': 4, 'epochs': 8, 'k_folds': 0, 'patience': 3, 'optimizer': 'Adamax', 'sgd_momentum': 0.9}\nEpoch: 1 | \n\n\nMulticlassAccuracy: 0.3878000080585480 | Loss: 1.6677710754990578 | Acc: 0.3878000000000000.\nEpoch: 2 | \n\n\nMulticlassAccuracy: 0.4491499960422516 | Loss: 1.5083286433458327 | Acc: 0.4491500000000000.\nEpoch: 3 | \n\n\nMulticlassAccuracy: 0.4769999980926514 | Loss: 1.4328012544035911 | Acc: 0.4770000000000000.\nEpoch: 4 | \n\n\nMulticlassAccuracy: 0.5037000179290771 | Loss: 1.3618832346677781 | Acc: 0.5037000000000000.\nEpoch: 5 | \n\n\nMulticlassAccuracy: 0.5237500071525574 | Loss: 1.3237895696029067 | Acc: 0.5237500000000000.\nEpoch: 6 | \n\n\nMulticlassAccuracy: 0.5248000025749207 | Loss: 1.3229136003062130 | Acc: 0.5248000000000000.\nEpoch: 7 | \n\n\nMulticlassAccuracy: 0.5267000198364258 | Loss: 1.3368793054573238 | Acc: 0.5266999999999999.\nEpoch: 8 | \n\n\nMulticlassAccuracy: 0.5468500256538391 | Loss: 1.3025472436670213 | Acc: 0.5468499999999999.\nReturned to Spot: Validation loss: 1.3025472436670213\n\nconfig: {'l1': 64, 'l2': 512, 'lr_mult': 1.0, 'batch_size': 16, 'epochs': 16, 'k_folds': 0, 'patience': 3, 'optimizer': 'Adagrad', 'sgd_momentum': 0.9}\nEpoch: 1 | \n\n\nMulticlassAccuracy: 0.4503999948501587 | Loss: 1.5053875568389892 | Acc: 0.4504000000000000.\nEpoch: 2 | \n\n\nMulticlassAccuracy: 0.4817500114440918 | Loss: 1.4276890246868132 | Acc: 0.4817500000000000.\nEpoch: 3 | \n\n\nMulticlassAccuracy: 0.4971500039100647 | Loss: 1.3758006053924561 | Acc: 0.4971500000000000.\nEpoch: 4 | \n\n\nMulticlassAccuracy: 0.5052999854087830 | Loss: 1.3617287966728211 | Acc: 0.5053000000000000.\nEpoch: 5 | \n\n\nMulticlassAccuracy: 0.5246499776840210 | Loss: 1.3144499421119691 | Acc: 0.5246499999999999.\nEpoch: 6 | \n\n\nMulticlassAccuracy: 0.5333999991416931 | Loss: 1.2918155289649964 | Acc: 0.5334000000000000.\nEpoch: 7 | \n\n\nMulticlassAccuracy: 0.5371000170707703 | Loss: 1.2804483198165895 | Acc: 0.5371000000000000.\nEpoch: 8 | \n\n\nMulticlassAccuracy: 0.5475000143051147 | Loss: 1.2682600169181824 | Acc: 0.5475000000000000.\nEpoch: 9 | \n\n\nMulticlassAccuracy: 0.5515000224113464 | Loss: 1.2482085966110230 | Acc: 0.5515000000000000.\nEpoch: 10 | \n\n\nMulticlassAccuracy: 0.5543000102043152 | Loss: 1.2493398176908492 | Acc: 0.5543000000000000.\nEpoch: 11 | \n\n\nMulticlassAccuracy: 0.5570499897003174 | Loss: 1.2347032400369644 | Acc: 0.5570500000000000.\nEpoch: 12 | \n\n\nMulticlassAccuracy: 0.5618000030517578 | Loss: 1.2204034348726274 | Acc: 0.5618000000000000.\nEpoch: 13 | \n\n\nMulticlassAccuracy: 0.5636000037193298 | Loss: 1.2188638792991637 | Acc: 0.5636000000000000.\nEpoch: 14 | \n\n\nMulticlassAccuracy: 0.5701000094413757 | Loss: 1.2036190267801286 | Acc: 0.5701000000000001.\nEpoch: 15 | \n\n\nMulticlassAccuracy: 0.5735499858856201 | Loss: 1.2017679643630981 | Acc: 0.5735500000000000.\nEpoch: 16 | \n\n\nMulticlassAccuracy: 0.5740000009536743 | Loss: 1.1927833241224288 | Acc: 0.5740000000000000.\nReturned to Spot: Validation loss: 1.1927833241224288\n\n\n\nconfig: {'l1': 128, 'l2': 16, 'lr_mult': 1.0, 'batch_size': 32, 'epochs': 16, 'k_folds': 0, 'patience': 3, 'optimizer': 'AdamW', 'sgd_momentum': 0.9}\nEpoch: 1 | \n\n\nMulticlassAccuracy: 0.4125500023365021 | Loss: 1.5910222095489501 | Acc: 0.4125500000000000.\nEpoch: 2 | \n\n\nMulticlassAccuracy: 0.4715499877929688 | Loss: 1.4488346719741820 | Acc: 0.4715500000000000.\nEpoch: 3 | \n\n\nMulticlassAccuracy: 0.5084999799728394 | Loss: 1.3695043066978454 | Acc: 0.5085000000000000.\nEpoch: 4 | \n\n\nMulticlassAccuracy: 0.5306500196456909 | Loss: 1.3158891970634461 | Acc: 0.5306500000000000.\nEpoch: 5 | \n\n\nMulticlassAccuracy: 0.5375000238418579 | Loss: 1.3249270143508911 | Acc: 0.5375000000000000.\nEpoch: 6 | \n\n\nMulticlassAccuracy: 0.5588499903678894 | Loss: 1.2504237797737121 | Acc: 0.5588500000000000.\nEpoch: 7 | \n\n\nMulticlassAccuracy: 0.5788999795913696 | Loss: 1.2066600365638733 | Acc: 0.5789000000000000.\nEpoch: 8 | \n\n\nMulticlassAccuracy: 0.5720999836921692 | Loss: 1.2174073032379151 | Acc: 0.5721000000000001.\nEpoch: 9 | \n\n\nMulticlassAccuracy: 0.5911499857902527 | Loss: 1.1804030963897705 | Acc: 0.5911500000000000.\nEpoch: 10 | \n\n\nMulticlassAccuracy: 0.5900999903678894 | Loss: 1.1776824831962585 | Acc: 0.5901000000000000.\nEpoch: 11 | \n\n\nMulticlassAccuracy: 0.5999000072479248 | Loss: 1.1676074934005738 | Acc: 0.5999000000000000.\nEpoch: 12 | \n\n\nMulticlassAccuracy: 0.5935000181198120 | Loss: 1.1752061429977416 | Acc: 0.5935000000000000.\nEpoch: 13 | \n\n\nMulticlassAccuracy: 0.6051499843597412 | Loss: 1.1578538383483887 | Acc: 0.6051500000000000.\nEpoch: 14 | \n\n\nMulticlassAccuracy: 0.6034500002861023 | Loss: 1.1724235271453858 | Acc: 0.6034500000000000.\nEpoch: 15 | \n\n\nMulticlassAccuracy: 0.6014999747276306 | Loss: 1.1903479053497314 | Acc: 0.6015000000000000.\nEpoch: 16 | \n\n\nMulticlassAccuracy: 0.6006500124931335 | Loss: 1.1868701674461364 | Acc: 0.6006500000000000.\nEarly stopping at epoch 15\nReturned to Spot: Validation loss: 1.1868701674461364\nspotPython tuning: 1.1477203011512755 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x299bc6990&gt;"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-tensorboard-14",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-tensorboard-14",
    "title": "24  HPT: PyTorch With spotPython and Ray Tune on CIFAR10",
    "section": "24.9 Step 9: Tensorboard",
    "text": "24.9 Step 9: Tensorboard\nThe textual output shown in the console (or code cell) can be visualized with Tensorboard.\n\n24.9.1 Tensorboard: Start Tensorboard\nStart TensorBoard through the command line to visualize data you logged. Specify the root log directory as used in fun_control = fun_control_init(task=\"regression\", tensorboard_path=\"runs/24_spot_torch_regression\") as the tensorboard_path. The argument logdir points to directory where TensorBoard will look to find event files that it can display. TensorBoard will recursively walk the directory structure rooted at logdir, looking for .tfevents. files.\ntensorboard --logdir=runs\nGo to the URL it provides or to http://localhost:6006/. The following figures show some screenshots of Tensorboard.\n\n\n\nFigure 24.1: Tensorboard\n\n\n\n\n\nFigure 24.2: Tensorboard\n\n\n\n\n24.9.2 Saving the State of the Notebook\nThe state of the notebook can be saved and reloaded as follows:\n\nimport pickle\nSAVE = False\nLOAD = False\n\nif SAVE:\n    result_file_name = \"res_\" + experiment_name + \".pkl\"\n    with open(result_file_name, 'wb') as f:\n        pickle.dump(spot_tuner, f)\n\nif LOAD:\n    result_file_name = \"add_the_name_of_the_result_file_here.pkl\"\n    with open(result_file_name, 'rb') as f:\n        spot_tuner =  pickle.load(f)"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-results-14",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-results-14",
    "title": "24  HPT: PyTorch With spotPython and Ray Tune on CIFAR10",
    "section": "24.10 Step 10: Results",
    "text": "24.10 Step 10: Results\nAfter the hyperparameter tuning run is finished, the progress of the hyperparameter tuning can be visualized. The following code generates the progress plot from ?fig-progress.\n\nspot_tuner.plot_progress(log_y=False, \n    filename=\"./figures/\" + experiment_name+\"_progress.png\")\n\n\n\n\nProgress plot. Black dots denote results from the initial design. Red dots illustrate the improvement found by the surrogate model based optimization.\n\n\n\n\n?fig-progress shows a typical behaviour that can be observed in many hyperparameter studies (Bartz et al. 2022): the largest improvement is obtained during the evaluation of the initial design. The surrogate model based optimization-optimization with the surrogate refines the results. ?fig-progress also illustrates one major difference between ray[tune] as used in PyTorch (2023a) and spotPython: the ray[tune] uses a random search and will generate results similar to the black dots, whereas spotPython uses a surrogate model based optimization and presents results represented by red dots in ?fig-progress. The surrogate model based optimization is considered to be more efficient than a random search, because the surrogate model guides the search towards promising regions in the hyperparameter space.\nIn addition to the improved (“optimized”) hyperparameter values, spotPython allows a statistical analysis, e.g., a sensitivity analysis, of the results. We can print the results of the hyperparameter tuning, see ?tbl-results. The table shows the hyperparameters, their types, default values, lower and upper bounds, and the transformation function. The column “tuned” shows the tuned values. The column “importance” shows the importance of the hyperparameters. The column “stars” shows the importance of the hyperparameters in stars. The importance is computed by the SPOT software.\n\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control=fun_control, spot=spot_tuner))\n\n| name         | type   | default   |   lower |   upper |   tuned | transform             |   importance | stars   |\n|--------------|--------|-----------|---------|---------|---------|-----------------------|--------------|---------|\n| l1           | int    | 5         |     2.0 |     9.0 |     7.0 | transform_power_2_int |         0.00 |         |\n| l2           | int    | 5         |     2.0 |     9.0 |     3.0 | transform_power_2_int |         0.00 |         |\n| lr_mult      | float  | 1.0       |     1.0 |     1.0 |     1.0 | None                  |         0.00 |         |\n| batch_size   | int    | 4         |     1.0 |     5.0 |     5.0 | transform_power_2_int |         0.81 | .       |\n| epochs       | int    | 3         |     3.0 |     4.0 |     4.0 | transform_power_2_int |         6.06 | *       |\n| k_folds      | int    | 1         |     0.0 |     0.0 |     0.0 | None                  |         0.00 |         |\n| patience     | int    | 5         |     3.0 |     3.0 |     3.0 | None                  |         0.00 |         |\n| optimizer    | factor | SGD       |     0.0 |     9.0 |     3.0 | None                  |       100.00 | ***     |\n| sgd_momentum | float  | 0.0       |     0.9 |     0.9 |     0.9 | None                  |         0.00 |         |\n\n\nTo visualize the most important hyperparameters, spotPython provides the function plot_importance. The following code generates the importance plot from ?fig-importance.\n\nspot_tuner.plot_importance(threshold=0.025,\n    filename=\"./figures/\" + experiment_name+\"_importance.png\")\n\n\n\n\nVariable importance plot, threshold 0.025.\n\n\n\n\n\n24.10.1 Get the Tuned Architecture (SPOT Results)\nThe architecture of the spotPython model can be obtained as follows. First, the numerical representation of the hyperparameters are obtained, i.e., the numpy array X is generated. This array is then used to generate the model model_spot by the function get_one_core_model_from_X. The model model_spot has the following architecture:\n\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nmodel_spot = get_one_core_model_from_X(X, fun_control)\nmodel_spot\n\nNet_CIFAR10(\n  (conv1): Conv2d(3, 6, kernel_size=(5, 5), stride=(1, 1))\n  (pool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)\n  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))\n  (fc1): Linear(in_features=400, out_features=128, bias=True)\n  (fc2): Linear(in_features=128, out_features=8, bias=True)\n  (fc3): Linear(in_features=8, out_features=10, bias=True)\n)\n\n\n\n\n24.10.2 Get Default Hyperparameters\nIn a similar manner as in Section 24.10.1, the default hyperparameters can be obtained.\n\n# fun_control was modified, we generate a new one with the original \n# default hyperparameters\nfrom spotPython.hyperparameters.values import get_one_core_model_from_X\nfrom spotPython.hyperparameters.values import get_default_hyperparameters_as_array\nX_start = get_default_hyperparameters_as_array(fun_control)\nmodel_default = get_one_core_model_from_X(X_start, fun_control)\nmodel_default\n\nNet_CIFAR10(\n  (conv1): Conv2d(3, 6, kernel_size=(5, 5), stride=(1, 1))\n  (pool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)\n  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))\n  (fc1): Linear(in_features=400, out_features=32, bias=True)\n  (fc2): Linear(in_features=32, out_features=32, bias=True)\n  (fc3): Linear(in_features=32, out_features=10, bias=True)\n)\n\n\n\n\n24.10.3 Evaluation of the Default Architecture\nThe method train_tuned takes a model architecture without trained weights and trains this model with the train data. The train data is split into train and validation data. The validation data is used for early stopping. The trained model weights are saved as a dictionary.\nThis evaluation is similar to the final evaluation in PyTorch (2023a).\n\nfrom spotPython.torch.traintest import (\n    train_tuned,\n    test_tuned,\n    )\ntrain_tuned(net=model_default, train_dataset=train, shuffle=True,\n        loss_function=fun_control[\"loss_function\"],\n        metric=fun_control[\"metric_torch\"],\n        device = fun_control[\"device\"], show_batch_interval=1_000_000,\n        path=None,\n        task=fun_control[\"task\"],)\n\ntest_tuned(net=model_default, test_dataset=test, \n        loss_function=fun_control[\"loss_function\"],\n        metric=fun_control[\"metric_torch\"],\n        shuffle=False, \n        device = fun_control[\"device\"],\n        task=fun_control[\"task\"],)        \n\nEpoch: 1 | \n\n\nMulticlassAccuracy: 0.0995000004768372 | Loss: 2.2999522211074828 | Acc: 0.0995000000000000.\nEpoch: 2 | \n\n\nMulticlassAccuracy: 0.1305000036954880 | Loss: 2.2869610927581787 | Acc: 0.1305000000000000.\nEpoch: 3 | \n\n\nMulticlassAccuracy: 0.1363500058650970 | Loss: 2.2477050289154055 | Acc: 0.1363500000000000.\nEpoch: 4 | \n\n\nMulticlassAccuracy: 0.2006500065326691 | Loss: 2.1781324967384337 | Acc: 0.2006500000000000.\nEpoch: 5 | \n\n\nMulticlassAccuracy: 0.2182500064373016 | Loss: 2.1153550539016726 | Acc: 0.2182500000000000.\nEpoch: 6 | \n\n\nMulticlassAccuracy: 0.2264499962329865 | Loss: 2.0708753735542298 | Acc: 0.2264500000000000.\nEpoch: 7 | \n\n\nMulticlassAccuracy: 0.2435999959707260 | Loss: 2.0414400042533876 | Acc: 0.2436000000000000.\nEpoch: 8 | \n\n\nMulticlassAccuracy: 0.2531499862670898 | Loss: 2.0214681243896484 | Acc: 0.2531500000000000.\nReturned to Spot: Validation loss: 2.0214681243896484\n\n\nMulticlassAccuracy: 0.2574999928474426 | Loss: 2.0162517908096311 | Acc: 0.2575000000000000.\nFinal evaluation: Validation loss: 2.016251790809631\nFinal evaluation: Validation metric: 0.2574999928474426\n----------------------------------------------\n\n\n(2.016251790809631, nan, tensor(0.2575, device='mps:0'))\n\n\n\n\n24.10.4 Evaluation of the Tuned Architecture\nThe following code trains the model model_spot.\nIf path is set to a filename, e.g., path = \"model_spot_trained.pt\", the weights of the trained model will be saved to this file.\nIf path is set to a filename, e.g., path = \"model_spot_trained.pt\", the weights of the trained model will be loaded from this file.\n\ntrain_tuned(net=model_spot, train_dataset=train,\n        loss_function=fun_control[\"loss_function\"],\n        metric=fun_control[\"metric_torch\"],\n        shuffle=True,\n        device = fun_control[\"device\"],\n        path=None,\n        task=fun_control[\"task\"],)\ntest_tuned(net=model_spot, test_dataset=test,\n            shuffle=False,\n            loss_function=fun_control[\"loss_function\"],\n            metric=fun_control[\"metric_torch\"],\n            device = fun_control[\"device\"],\n            task=fun_control[\"task\"],)\n\nEpoch: 1 | \n\n\nMulticlassAccuracy: 0.4187499880790710 | Loss: 1.5769843736648559 | Acc: 0.4187500000000000.\nEpoch: 2 | \n\n\nMulticlassAccuracy: 0.4675000011920929 | Loss: 1.4508240690231324 | Acc: 0.4675000000000000.\nEpoch: 3 | \n\n\nMulticlassAccuracy: 0.5137000083923340 | Loss: 1.3569832351684570 | Acc: 0.5137000000000000.\nEpoch: 4 | \n\n\nMulticlassAccuracy: 0.5307499766349792 | Loss: 1.3070075393676759 | Acc: 0.5307500000000001.\nEpoch: 5 | \n\n\nMulticlassAccuracy: 0.5393499732017517 | Loss: 1.2841068645477296 | Acc: 0.5393500000000000.\nEpoch: 6 | \n\n\nMulticlassAccuracy: 0.5460500121116638 | Loss: 1.2693293420791627 | Acc: 0.5460500000000000.\nEpoch: 7 | \n\n\nMulticlassAccuracy: 0.5558999776840210 | Loss: 1.2405844126701355 | Acc: 0.5558999999999999.\nEpoch: 8 | \n\n\nMulticlassAccuracy: 0.5686500072479248 | Loss: 1.2219975400924683 | Acc: 0.5686500000000000.\nEpoch: 9 | \n\n\nMulticlassAccuracy: 0.5616499781608582 | Loss: 1.2282655703544616 | Acc: 0.5616500000000000.\nEpoch: 10 | \n\n\nMulticlassAccuracy: 0.5766999721527100 | Loss: 1.2177041532516479 | Acc: 0.5767000000000000.\nEpoch: 11 | \n\n\nMulticlassAccuracy: 0.5799999833106995 | Loss: 1.2102932430267335 | Acc: 0.5800000000000000.\nEpoch: 12 | \n\n\nMulticlassAccuracy: 0.5819000005722046 | Loss: 1.2291380684852600 | Acc: 0.5819000000000000.\nEpoch: 13 | \n\n\nMulticlassAccuracy: 0.5869500041007996 | Loss: 1.2013124509811401 | Acc: 0.5869500000000000.\nEpoch: 14 | \n\n\nMulticlassAccuracy: 0.5739499926567078 | Loss: 1.2463197503089904 | Acc: 0.5739500000000000.\nEpoch: 15 | \n\n\nMulticlassAccuracy: 0.5835999846458435 | Loss: 1.2343276533126830 | Acc: 0.5836000000000000.\nEpoch: 16 | \n\n\nMulticlassAccuracy: 0.5806499719619751 | Loss: 1.2479942989349366 | Acc: 0.5806500000000000.\nEarly stopping at epoch 15\nReturned to Spot: Validation loss: 1.2479942989349366\n\n\nMulticlassAccuracy: 0.5892999768257141 | Loss: 1.2312500318780113 | Acc: 0.5893000000000000.\nFinal evaluation: Validation loss: 1.2312500318780113\nFinal evaluation: Validation metric: 0.5892999768257141\n----------------------------------------------\n\n\n(1.2312500318780113, nan, tensor(0.5893, device='mps:0'))\n\n\n\n\n24.10.5 Detailed Hyperparameter Plots\nThe contour plots in this section visualize the interactions of the three most important hyperparameters. Since some of these hyperparameters take fatorial or integer values, sometimes step-like fitness landcapes (or response surfaces) are generated. SPOT draws the interactions of the main hyperparameters by default. It is also possible to visualize all interactions.\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)\n\nbatch_size:  0.808580970629426\nepochs:  6.061007441106652\noptimizer:  100.0\n\n\n\n\n\nContour plots.\n\n\n\n\n\n\n\n\n\n\nThe figures (?fig-contour) show the contour plots of the loss as a function of the hyperparameters. These plots are very helpful for benchmark studies and for understanding neural networks. spotPython provides additional tools for a visual inspection of the results and give valuable insights into the hyperparameter tuning process. This is especially useful for model explainability, transparency, and trustworthiness. In addition to the contour plots, ?fig-parallel shows the parallel plot of the hyperparameters.\n\nspot_tuner.parallel_plot()\n\n\n                                                \nParallel coordinates plots"
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-summary",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-summary",
    "title": "24  HPT: PyTorch With spotPython and Ray Tune on CIFAR10",
    "section": "24.11 Summary and Outlook",
    "text": "24.11 Summary and Outlook\nThis tutorial presents the hyperparameter tuning open source software spotPython for PyTorch. To show its basic features, a comparison with the “official” PyTorch hyperparameter tuning tutorial (PyTorch 2023a) is presented. Some of the advantages of spotPython are:\n\nNumerical and categorical hyperparameters.\nPowerful surrogate models.\nFlexible approach and easy to use.\nSimple JSON files for the specification of the hyperparameters.\nExtension of default and user specified network classes.\nNoise handling techniques.\nInteraction with tensorboard.\n\nCurrently, only rudimentary parallel and distributed neural network training is possible, but these capabilities will be extended in the future. The next version of spotPython will also include a more detailed documentation and more examples.\n\n\n\n\n\n\nImportant\n\n\n\nImportant: This tutorial does not present a complete benchmarking study (Bartz-Beielstein et al. 2020). The results are only preliminary and highly dependent on the local configuration (hard- and software). Our goal is to provide a first impression of the performance of the hyperparameter tuning package spotPython. To demonstrate its capabilities, a quick comparison with ray[tune] was performed. ray[tune] was chosen, because it is presented as “an industry standard tool for distributed hyperparameter tuning.” The results should be interpreted with care."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#sec-appendix",
    "href": "14_spot_ray_hpt_torch_cifar10.html#sec-appendix",
    "title": "24  HPT: PyTorch With spotPython and Ray Tune on CIFAR10",
    "section": "24.12 Appendix",
    "text": "24.12 Appendix\n\n24.12.1 Sample Output From Ray Tune’s Run\nThe output from ray[tune] could look like this (PyTorch 2023b):\nNumber of trials: 10 (10 TERMINATED)\n------+------+-------------+--------------+---------+------------+--------------------+\n|   l1 |   l2 |          lr |   batch_size |    loss |   accuracy | training_iteration |\n+------+------+-------------+--------------+---------+------------+--------------------|\n|   64 |    4 | 0.00011629  |            2 | 1.87273 |     0.244  |                  2 |\n|   32 |   64 | 0.000339763 |            8 | 1.23603 |     0.567  |                  8 |\n|    8 |   16 | 0.00276249  |           16 | 1.1815  |     0.5836 |                 10 |\n|    4 |   64 | 0.000648721 |            4 | 1.31131 |     0.5224 |                  8 |\n|   32 |   16 | 0.000340753 |            8 | 1.26454 |     0.5444 |                  8 |\n|    8 |    4 | 0.000699775 |            8 | 1.99594 |     0.1983 |                  2 |\n|  256 |    8 | 0.0839654   |           16 | 2.3119  |     0.0993 |                  1 |\n|   16 |  128 | 0.0758154   |           16 | 2.33575 |     0.1327 |                  1 |\n|   16 |    8 | 0.0763312   |           16 | 2.31129 |     0.1042 |                  4 |\n|  128 |   16 | 0.000124903 |            4 | 2.26917 |     0.1945 |                  1 |\n+-----+------+------+-------------+--------------+---------+------------+--------------------+\nBest trial config: {'l1': 8, 'l2': 16, 'lr': 0.00276249, 'batch_size': 16, 'data_dir': '...'}\nBest trial final validation loss: 1.181501\nBest trial final validation accuracy: 0.5836\nBest trial test set accuracy: 0.5806\n\n\n\n\nBartz, Eva, Thomas Bartz-Beielstein, Martin Zaefferer, and Olaf Mersmann, eds. 2022. Hyperparameter Tuning for Machine and Deep Learning with R - A Practical Guide. Springer.\n\n\nBartz-Beielstein, Thomas, Carola Doerr, Jakob Bossek, Sowmya Chandrasekaran, Tome Eftimov, Andreas Fischbach, Pascal Kerschke, et al. 2020. “Benchmarking in Optimization: Best Practice and Open Issues.” arXiv. https://arxiv.org/abs/2007.03488.\n\n\nMontiel, Jacob, Max Halford, Saulo Martiello Mastelini, Geoffrey Bolmier, Raphael Sourty, Robin Vaysse, Adil Zouitine, et al. 2021. “River: Machine Learning for Streaming Data in Python.”\n\n\nPyTorch. 2023a. “Hyperparameter Tuning with Ray Tune.” https://pytorch.org/tutorials/beginner/hyperparameter_tuning_tutorial.html.\n\n\n———. 2023b. “Training a Classifier.” https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html."
  },
  {
    "objectID": "14_spot_ray_hpt_torch_cifar10.html#footnotes",
    "href": "14_spot_ray_hpt_torch_cifar10.html#footnotes",
    "title": "24  HPT: PyTorch With spotPython and Ray Tune on CIFAR10",
    "section": "",
    "text": "Alternatively, the source code can be downloaded from gitHub: https://github.com/sequential-parameter-optimization/spotPython.↩︎\nWe were not able to install Ray Tune on our system. Therefore, we used the results from the PyTorch tutorial.↩︎"
  },
  {
    "objectID": "31_spot_lightning_csv.html#sec-setup-31",
    "href": "31_spot_lightning_csv.html#sec-setup-31",
    "title": "25  HPT PyTorch Lightning: VBDP",
    "section": "25.1 Step 1: Setup",
    "text": "25.1 Step 1: Setup\n\nBefore we consider the detailed experimental setup, we select the parameters that affect run time, initial design size, etc.\nThe parameter MAX_TIME specifies the maximum run time in seconds.\nThe parameter INIT_SIZE specifies the initial design size.\nThe parameter WORKERS specifies the number of workers.\nThe prefix PREFIX is used for the experiment name and the name of the log file.\n\n\nMAX_TIME = 1\nINIT_SIZE = 5\nWORKERS = 0\nPREFIX=\"31\"\n\n\n\n\n\n\n\nCaution: Run time and initial design size should be increased for real experiments\n\n\n\n\nMAX_TIME is set to one minute for demonstration purposes. For real experiments, this should be increased to at least 1 hour.\nINIT_SIZE is set to 5 for demonstration purposes. For real experiments, this should be increased to at least 10.\nWORKERS is set to 0 for demonstration purposes. For real experiments, this should be increased. See the warnings that are printed when the number of workers is set to 0.\n\n\n\n\n\n\n\n\n\nNote: Device selection\n\n\n\n\nAlthough there are no .cuda() or .to(device) calls required, because Lightning does these for you, see LIGHTNINGMODULE, we would like to know which device is used. Threrefore, we imitate the LightningModule behaviour which selects the highest device.\nThe method spotPython.utils.device.getDevice() returns the device that is used by Lightning."
  },
  {
    "objectID": "31_spot_lightning_csv.html#step-2-initialization-of-the-fun_control-dictionary",
    "href": "31_spot_lightning_csv.html#step-2-initialization-of-the-fun_control-dictionary",
    "title": "25  HPT PyTorch Lightning: VBDP",
    "section": "25.2 Step 2: Initialization of the fun_control Dictionary",
    "text": "25.2 Step 2: Initialization of the fun_control Dictionary\nspotPython uses a Python dictionary for storing the information required for the hyperparameter tuning process, which was described in Section 23.2, see Initialization of the fun_control Dictionary in the documentation.\n\nfrom spotPython.utils.init import fun_control_init\nfrom spotPython.utils.file import get_experiment_name, get_spot_tensorboard_path\nfrom spotPython.utils.device import getDevice\n\nexperiment_name = get_experiment_name(prefix=PREFIX)\nfun_control = fun_control_init(\n    spot_tensorboard_path=get_spot_tensorboard_path(experiment_name),\n    num_workers=WORKERS,\n    device=getDevice(),\n    _L_in=64,\n    _L_out=11,\n    TENSORBOARD_CLEAN=True)\n\n\nfun_control[\"device\"]\n\n'mps'"
  },
  {
    "objectID": "31_spot_lightning_csv.html#sec-data-loading-31",
    "href": "31_spot_lightning_csv.html#sec-data-loading-31",
    "title": "25  HPT PyTorch Lightning: VBDP",
    "section": "25.3 Step 3: PyTorch Data Loading",
    "text": "25.3 Step 3: PyTorch Data Loading\n\n25.3.1 Lightning Dataset and DataModule\nThe data loading and preprocessing is handled by Lightning and PyTorch. It comprehends the following classes:\n\nCSVDataset: A class that loads the data from a CSV file. [SOURCE]\nCSVDataModule: A class that prepares the data for training and testing. [SOURCE]\n\nSection Section 25.12.2 illustrates how to access the data."
  },
  {
    "objectID": "31_spot_lightning_csv.html#sec-preprocessing-31",
    "href": "31_spot_lightning_csv.html#sec-preprocessing-31",
    "title": "25  HPT PyTorch Lightning: VBDP",
    "section": "25.4 Step 4: Preprocessing",
    "text": "25.4 Step 4: Preprocessing\nPreprocessing is handled by Lightning and PyTorch. It can be implemented in the CSVDataModule class [SOURCE] and is described in the LIGHTNINGDATAMODULE documentation. Here you can find information about the transforms methods."
  },
  {
    "objectID": "31_spot_lightning_csv.html#sec-selection-of-the-algorithm-31",
    "href": "31_spot_lightning_csv.html#sec-selection-of-the-algorithm-31",
    "title": "25  HPT PyTorch Lightning: VBDP",
    "section": "25.5 Step 5: Select the NN Model (algorithm) and core_model_hyper_dict",
    "text": "25.5 Step 5: Select the NN Model (algorithm) and core_model_hyper_dict\nspotPython includes the NetLightBase class [SOURCE] for configurable neural networks. The class is imported here. It inherits from the class Lightning.LightningModule, which is the base class for all models in Lightning. Lightning.LightningModule is a subclass of torch.nn.Module and provides additional functionality for the training and testing of neural networks. The class Lightning.LightningModule is described in the Lightning documentation.\n\nHere we simply add the NN Model to the fun_control dictionary by calling the function add_core_model_to_fun_control:\n\n\nfrom spotPython.light.netlightbase import NetLightBase \nfrom spotPython.data.light_hyper_dict import LightHyperDict\nfrom spotPython.hyperparameters.values import add_core_model_to_fun_control\nadd_core_model_to_fun_control(core_model=NetLightBase,\n                              fun_control=fun_control,\n                              hyper_dict= LightHyperDict)\n\nThe NetLightBase is a configurable neural network. The hyperparameters of the model are specified in the core_model_hyper_dict dictionary [SOURCE]."
  },
  {
    "objectID": "31_spot_lightning_csv.html#sec-modification-of-hyperparameters-31",
    "href": "31_spot_lightning_csv.html#sec-modification-of-hyperparameters-31",
    "title": "25  HPT PyTorch Lightning: VBDP",
    "section": "25.6 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model",
    "text": "25.6 Step 6: Modify hyper_dict Hyperparameters for the Selected Algorithm aka core_model\nspotPython provides functions for modifying the hyperparameters, their bounds and factors as well as for activating and de-activating hyperparameters without re-compilation of the Python source code. These functions were described in Section 23.6.\n\n\n\n\n\n\nCaution: Small number of epochs for demonstration purposes\n\n\n\n\nepochs and patience are set to small values for demonstration purposes. These values are too small for a real application.\nMore resonable values are, e.g.:\n\nmodify_hyper_parameter_bounds(fun_control, \"epochs\", bounds=[7, 9]) and\nmodify_hyper_parameter_bounds(fun_control, \"patience\", bounds=[2, 7])\n\n\n\n\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_bounds\n\nmodify_hyper_parameter_bounds(fun_control, \"l1\", bounds=[5,8])\nmodify_hyper_parameter_bounds(fun_control, \"epochs\", bounds=[6,13])\nmodify_hyper_parameter_bounds(fun_control, \"batch_size\", bounds=[2, 8])\n\n\nfrom spotPython.hyperparameters.values import modify_hyper_parameter_levels\nmodify_hyper_parameter_levels(fun_control, \"optimizer\",[\"Adam\", \"AdamW\", \"Adamax\", \"NAdam\"])\n# modify_hyper_parameter_levels(fun_control, \"optimizer\", [\"Adam\"])\n\nNow, the dictionary fun_control contains all information needed for the hyperparameter tuning. Before the hyperparameter tuning is started, it is recommended to take a look at the experimental design. The method gen_design_table [SOURCE] generates a design table as follows:\n\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control))\n\n| name           | type   | default   |   lower |   upper | transform             |\n|----------------|--------|-----------|---------|---------|-----------------------|\n| l1             | int    | 3         |     5   |    8    | transform_power_2_int |\n| epochs         | int    | 4         |     6   |   13    | transform_power_2_int |\n| batch_size     | int    | 4         |     2   |    8    | transform_power_2_int |\n| act_fn         | factor | ReLU      |     0   |    5    | None                  |\n| optimizer      | factor | SGD       |     0   |    3    | None                  |\n| dropout_prob   | float  | 0.01      |     0   |    0.25 | None                  |\n| lr_mult        | float  | 1.0       |     0.1 |   10    | None                  |\n| patience       | int    | 2         |     2   |    6    | transform_power_2_int |\n| initialization | factor | Default   |     0   |    2    | None                  |\n\n\nThis allows to check if all information is available and if the information is correct.\n\n\n\n\n\n\nNote: Hyperparameters of the Tuned Model and the fun_control Dictionary\n\n\n\nThe updated fun_control dictionary can be shown with the command fun_control[\"core_model_hyper_dict\"]."
  },
  {
    "objectID": "31_spot_lightning_csv.html#step-7-data-splitting-the-objective-loss-function-and-the-metric",
    "href": "31_spot_lightning_csv.html#step-7-data-splitting-the-objective-loss-function-and-the-metric",
    "title": "25  HPT PyTorch Lightning: VBDP",
    "section": "25.7 Step 7: Data Splitting, the Objective (Loss) Function and the Metric",
    "text": "25.7 Step 7: Data Splitting, the Objective (Loss) Function and the Metric\n\n25.7.1 Evaluation\nThe evaluation procedure requires the specification of two elements:\n\nthe way how the data is split into a train and a test set (see Section 23.7.1)\nthe loss function (and a metric).\n\n\n\n\n\n\n\nCaution: Data Splitting in Lightning\n\n\n\n\nThe data splitting is handled by Lightning.\n\n\n\n\n\n25.7.2 Loss Functions and Metrics\nThe loss function is specified in the configurable network class [SOURCE] We will use CrossEntropy loss for the multiclass-classification task.\n\n\n25.7.3 Metric\n\nWe will use the MAP@k metric [SOURCE] for the evaluation of the model.\nAn example, how this metric works, is shown in the Appendix, see Section {Section 25.12.3}.\n\nSimilar to the loss function, the metric is specified in the configurable network class [SOURCE].\n\n\n\n\n\n\nCaution: Loss Function and Metric in Lightning\n\n\n\n\nThe loss function and the metric are not hyperparameters that can be tuned with spotPython.\nThey are handled by Lightning."
  },
  {
    "objectID": "31_spot_lightning_csv.html#step-8-calling-the-spot-function",
    "href": "31_spot_lightning_csv.html#step-8-calling-the-spot-function",
    "title": "25  HPT PyTorch Lightning: VBDP",
    "section": "25.8 Step 8: Calling the SPOT Function",
    "text": "25.8 Step 8: Calling the SPOT Function\n\n25.8.1 Preparing the SPOT Call\nThe following code passes the information about the parameter ranges and bounds to spot. It extracts the variable types, names, and bounds\n\nfrom spotPython.hyperparameters.values import (get_bound_values,\n    get_var_name,\n    get_var_type,)\nvar_type = get_var_type(fun_control)\nvar_name = get_var_name(fun_control)\nlower = get_bound_values(fun_control, \"lower\")\nupper = get_bound_values(fun_control, \"upper\")\n\n\n\n25.8.2 The Objective Function fun\nThe objective function fun from the class HyperLight [SOURCE] is selected next. It implements an interface from PyTorch’s training, validation, and testing methods to spotPython.\n\nfrom spotPython.fun.hyperlight import HyperLight\nfun = HyperLight().fun\n\n\n\n25.8.3 Starting the Hyperparameter Tuning\nThe spotPython hyperparameter tuning is started by calling the Spot function [SOURCE] as described in Section 23.8.4.\n\nimport numpy as np\nfrom spotPython.spot import spot\nfrom math import inf\nspot_tuner = spot.Spot(fun=fun,\n                   lower = lower,\n                   upper = upper,\n                   fun_evals = inf,\n                   max_time = MAX_TIME,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type = var_type,\n                   var_name = var_name,\n                   show_progress= True,\n                   fun_control = fun_control,\n                   design_control={\"init_size\": INIT_SIZE},\n                   surrogate_control={\"noise\": True,\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": len(var_name),\n                                      \"model_fun_evals\": 10_000,\n                                      })\nspot_tuner.run()\n\nfun: Calling train_model\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric           2.2744216918945312\n         val_acc            0.24381625652313232\n        val_loss            2.2744216918945312\n       valid_mapk           0.3699631094932556\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nfun: train_model returned\nfun: Calling train_model\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric           2.2821764945983887\n         val_acc             0.268551230430603\n        val_loss            2.2821764945983887\n       valid_mapk           0.3694058656692505\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nfun: train_model returned\nfun: Calling train_model\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric            2.40523099899292\n         val_acc            0.13780918717384338\n        val_loss             2.40523099899292\n       valid_mapk           0.1892361044883728\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nfun: train_model returned\nfun: Calling train_model\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric            2.301100015640259\n         val_acc            0.23674911260604858\n        val_loss             2.301100015640259\n       valid_mapk           0.3090277910232544\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nfun: train_model returned\nfun: Calling train_model\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric           2.2979023456573486\n         val_acc            0.22968198359012604\n        val_loss            2.2979023456573486\n       valid_mapk           0.3073495328426361\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nfun: train_model returned\nfun: Calling train_model\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric            2.285515546798706\n         val_acc            0.24028268456459045\n        val_loss             2.285515546798706\n       valid_mapk           0.3344908058643341\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nfun: train_model returned\n\n\nspotPython tuning: 2.2744216918945312 [#######---] 66.75% \n\n\nfun: Calling train_model\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric            2.285055637359619\n         val_acc            0.2473498284816742\n        val_loss             2.285055637359619\n       valid_mapk           0.3562082052230835\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nfun: train_model returned\n\n\nspotPython tuning: 2.2744216918945312 [#######---] 71.67% \n\n\nfun: Calling train_model\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric            2.276766061782837\n         val_acc            0.2473498284816742\n        val_loss             2.276766061782837\n       valid_mapk           0.3588348925113678\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nfun: train_model returned\n\n\nspotPython tuning: 2.2744216918945312 [##########] 95.24% \n\n\nfun: Calling train_model\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric            2.272672414779663\n         val_acc            0.2473498284816742\n        val_loss             2.272672414779663\n       valid_mapk           0.3421362042427063\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nfun: train_model returned\n\n\nspotPython tuning: 2.272672414779663 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x16dc2cad0&gt;"
  },
  {
    "objectID": "31_spot_lightning_csv.html#sec-tensorboard-31",
    "href": "31_spot_lightning_csv.html#sec-tensorboard-31",
    "title": "25  HPT PyTorch Lightning: VBDP",
    "section": "25.9 Step 9: Tensorboard",
    "text": "25.9 Step 9: Tensorboard\nThe textual output shown in the console (or code cell) can be visualized with Tensorboard.\ntensorboard --logdir=\"runs/\"\nFurther information can be found in the PyTorch Lightning documentation for Tensorboard."
  },
  {
    "objectID": "31_spot_lightning_csv.html#sec-results-31",
    "href": "31_spot_lightning_csv.html#sec-results-31",
    "title": "25  HPT PyTorch Lightning: VBDP",
    "section": "25.10 Step 10: Results",
    "text": "25.10 Step 10: Results\nAfter the hyperparameter tuning run is finished, the results can be analyzed as described in Section 23.10.\n\nspot_tuner.plot_progress(log_y=False,\n    filename=\"./figures/\" + experiment_name+\"_progress.png\")\n\n\n\n\nProgress plot. Black dots denote results from the initial design. Red dots illustrate the improvement found by the surrogate model based optimization.\n\n\n\n\n\nfrom spotPython.utils.eda import gen_design_table\nprint(gen_design_table(fun_control=fun_control, spot=spot_tuner))\n\n| name           | type   | default   |   lower |   upper |              tuned | transform             |   importance | stars   |\n|----------------|--------|-----------|---------|---------|--------------------|-----------------------|--------------|---------|\n| l1             | int    | 3         |     5.0 |     8.0 |                5.0 | transform_power_2_int |         0.12 | .       |\n| epochs         | int    | 4         |     6.0 |    13.0 |                7.0 | transform_power_2_int |       100.00 | ***     |\n| batch_size     | int    | 4         |     2.0 |     8.0 |                2.0 | transform_power_2_int |         0.00 |         |\n| act_fn         | factor | ReLU      |     0.0 |     5.0 |                3.0 | None                  |         4.78 | *       |\n| optimizer      | factor | SGD       |     0.0 |     3.0 |                2.0 | None                  |         0.01 |         |\n| dropout_prob   | float  | 0.01      |     0.0 |    0.25 |               0.25 | None                  |         0.02 |         |\n| lr_mult        | float  | 1.0       |     0.1 |    10.0 | 2.1136416734217627 | None                  |         0.00 |         |\n| patience       | int    | 2         |     2.0 |     6.0 |                5.0 | transform_power_2_int |         0.00 |         |\n| initialization | factor | Default   |     0.0 |     2.0 |                0.0 | None                  |         0.00 |         |\n\n\n\nspot_tuner.plot_importance(threshold=0.025,\n    filename=\"./figures/\" + experiment_name+\"_importance.png\")\n\n\n\n\nVariable importance plot, threshold 0.025.\n\n\n\n\n\n25.10.1 Get the Tuned Architecture\n\nfrom spotPython.light.utils import get_tuned_architecture\nconfig = get_tuned_architecture(spot_tuner, fun_control)\n\n\nTest on the full data set\n\n\nfrom spotPython.light.traintest import test_model\ntest_model(config, fun_control)\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n       Test metric             DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric            2.19404935836792\n     test_mapk_epoch        0.42514118552207947\n         val_acc            0.3465346395969391\n        val_loss             2.19404935836792\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n\n\n(2.19404935836792, 0.3465346395969391)\n\n\n\nfrom spotPython.light.traintest import load_light_from_checkpoint\n\nmodel_loaded = load_light_from_checkpoint(config, fun_control)\n\nLoading model from runs/saved_models/-140200857605837501_TEST/last.ckpt\n\n\n\n\n25.10.2 Cross Validation With Lightning\n\nThe KFold class from sklearn.model_selection is used to generate the folds for cross-validation.\nThese mechanism is used to generate the folds for the final evaluation of the model.\nThe CrossValidationDataModule class [SOURCE] is used to generate the folds for the hyperparameter tuning process.\nIt is called from the cv_model function [SOURCE].\n\n\nfrom spotPython.light.traintest import cv_model\n# set the number of folds to 10\nfun_control[\"k_folds\"] = 10\ncv_model(config, fun_control)\n\nk: 0\nTrain Dataset Size: 636\nVal Dataset Size: 71\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric           2.1368539333343506\n         val_acc            0.4084506928920746\n        val_loss            2.1368539333343506\n       valid_mapk           0.4606481194496155\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ntrain_model result: {'valid_mapk': 0.4606481194496155, 'val_loss': 2.1368539333343506, 'val_acc': 0.4084506928920746, 'hp_metric': 2.1368539333343506}\nk: 1\nTrain Dataset Size: 636\nVal Dataset Size: 71\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric           2.2264761924743652\n         val_acc            0.30985915660858154\n        val_loss            2.2264761924743652\n       valid_mapk           0.4004629850387573\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ntrain_model result: {'valid_mapk': 0.4004629850387573, 'val_loss': 2.2264761924743652, 'val_acc': 0.30985915660858154, 'hp_metric': 2.2264761924743652}\nk: 2\nTrain Dataset Size: 636\nVal Dataset Size: 71\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric           2.3198959827423096\n         val_acc            0.23943662643432617\n        val_loss            2.3198959827423096\n       valid_mapk           0.3009259104728699\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ntrain_model result: {'valid_mapk': 0.3009259104728699, 'val_loss': 2.3198959827423096, 'val_acc': 0.23943662643432617, 'hp_metric': 2.3198959827423096}\nk: 3\nTrain Dataset Size: 636\nVal Dataset Size: 71\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric           2.2523036003112793\n         val_acc            0.2535211145877838\n        val_loss            2.2523036003112793\n       valid_mapk           0.3634259104728699\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ntrain_model result: {'valid_mapk': 0.3634259104728699, 'val_loss': 2.2523036003112793, 'val_acc': 0.2535211145877838, 'hp_metric': 2.2523036003112793}\nk: 4\nTrain Dataset Size: 636\nVal Dataset Size: 71\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric            2.302013635635376\n         val_acc            0.22535210847854614\n        val_loss             2.302013635635376\n       valid_mapk           0.2847222089767456\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ntrain_model result: {'valid_mapk': 0.2847222089767456, 'val_loss': 2.302013635635376, 'val_acc': 0.22535210847854614, 'hp_metric': 2.302013635635376}\nk: 5\nTrain Dataset Size: 636\nVal Dataset Size: 71\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric           2.2929389476776123\n         val_acc            0.19718310236930847\n        val_loss            2.2929389476776123\n       valid_mapk           0.3379629850387573\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ntrain_model result: {'valid_mapk': 0.3379629850387573, 'val_loss': 2.2929389476776123, 'val_acc': 0.19718310236930847, 'hp_metric': 2.2929389476776123}\nk: 6\nTrain Dataset Size: 636\nVal Dataset Size: 71\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric            2.294412851333618\n         val_acc            0.22535210847854614\n        val_loss             2.294412851333618\n       valid_mapk           0.3356481194496155\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ntrain_model result: {'valid_mapk': 0.3356481194496155, 'val_loss': 2.294412851333618, 'val_acc': 0.22535210847854614, 'hp_metric': 2.294412851333618}\nk: 7\nTrain Dataset Size: 637\nVal Dataset Size: 70\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric            2.260765790939331\n         val_acc            0.2571428716182709\n        val_loss             2.260765790939331\n       valid_mapk           0.37731483578681946\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ntrain_model result: {'valid_mapk': 0.37731483578681946, 'val_loss': 2.260765790939331, 'val_acc': 0.2571428716182709, 'hp_metric': 2.260765790939331}\nk: 8\nTrain Dataset Size: 637\nVal Dataset Size: 70\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric           2.3352291584014893\n         val_acc            0.17142857611179352\n        val_loss            2.3352291584014893\n       valid_mapk           0.3194444477558136\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ntrain_model result: {'valid_mapk': 0.3194444477558136, 'val_loss': 2.3352291584014893, 'val_acc': 0.17142857611179352, 'hp_metric': 2.3352291584014893}\nk: 9\nTrain Dataset Size: 637\nVal Dataset Size: 70\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     Validate metric           DataLoader 0\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n        hp_metric            2.22326922416687\n         val_acc            0.3142857253551483\n        val_loss             2.22326922416687\n       valid_mapk           0.36574074625968933\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ntrain_model result: {'valid_mapk': 0.36574074625968933, 'val_loss': 2.22326922416687, 'val_acc': 0.3142857253551483, 'hp_metric': 2.22326922416687}\n\n\n0.3546296268701553\n\n\n\n\n\n\n\n\nNote: Evaluation for the Final Comaprison\n\n\n\n\nThis is the evaluation that will be used in the comparison.\n\n\n\n\n\n25.10.3 Detailed Hyperparameter Plots\n\nfilename = \"./figures/\" + experiment_name\nspot_tuner.plot_important_hyperparameter_contour(filename=filename)\n\nl1:  0.11651205242017379\nepochs:  100.0\nact_fn:  4.7762099479218705\n\n\n\n\n\nContour plots.\n\n\n\n\n\n\n\n\n\n\n\n\n25.10.4 Parallel Coordinates Plot\n\nspot_tuner.parallel_plot()\n\n\n                                                \nParallel coordinates plots\n\n\n\n\n25.10.5 Plot all Combinations of Hyperparameters\n\nWarning: this may take a while.\n\n\nPLOT_ALL = False\nif PLOT_ALL:\n    n = spot_tuner.k\n    for i in range(n-1):\n        for j in range(i+1, n):\n            spot_tuner.plot_contour(i=i, j=j, min_z=min_z, max_z = max_z)\n\n\n\n25.10.6 Visualizing the Activation Distribution\n\n\n\n\n\n\nReference:\n\n\n\n\nThe following code is based on [PyTorch Lightning TUTORIAL 2: ACTIVATION FUNCTIONS], Author: Phillip Lippe, License: [CC BY-SA], Generated: 2023-03-15T09:52:39.179933.\n\n\n\nAfter we have trained the models, we can look at the actual activation values that find inside the model. For instance, how many neurons are set to zero in ReLU? Where do we find most values in Tanh? To answer these questions, we can write a simple function which takes a trained model, applies it to a batch of images, and plots the histogram of the activations inside the network:\n\nfrom spotPython.torch.activation import Sigmoid, Tanh, ReLU, LeakyReLU, ELU, Swish\nact_fn_by_name = {\"sigmoid\": Sigmoid, \"tanh\": Tanh, \"relu\": ReLU, \"leakyrelu\": LeakyReLU, \"elu\": ELU, \"swish\": Swish}\n\n\nfrom spotPython.hyperparameters.values import get_one_config_from_X\nX = spot_tuner.to_all_dim(spot_tuner.min_X.reshape(1,-1))\nconfig = get_one_config_from_X(X, fun_control)\nmodel = fun_control[\"core_model\"](**config, _L_in=64, _L_out=11)\nmodel\n\nNetLightBase(\n  (train_mapk): MAPK()\n  (valid_mapk): MAPK()\n  (test_mapk): MAPK()\n  (layers): Sequential(\n    (0): Linear(in_features=64, out_features=32, bias=True)\n    (1): LeakyReLU()\n    (2): Dropout(p=0.25, inplace=False)\n    (3): Linear(in_features=32, out_features=16, bias=True)\n    (4): LeakyReLU()\n    (5): Dropout(p=0.25, inplace=False)\n    (6): Linear(in_features=16, out_features=16, bias=True)\n    (7): LeakyReLU()\n    (8): Dropout(p=0.25, inplace=False)\n    (9): Linear(in_features=16, out_features=8, bias=True)\n    (10): LeakyReLU()\n    (11): Dropout(p=0.25, inplace=False)\n    (12): Linear(in_features=8, out_features=11, bias=True)\n  )\n)\n\n\n\nfrom spotPython.utils.eda import visualize_activations\nvisualize_activations(model, color=f\"C{0}\")"
  },
  {
    "objectID": "31_spot_lightning_csv.html#submission",
    "href": "31_spot_lightning_csv.html#submission",
    "title": "25  HPT PyTorch Lightning: VBDP",
    "section": "25.11 Submission",
    "text": "25.11 Submission\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import OrdinalEncoder\n\n\nimport pandas as pd\nfrom sklearn.preprocessing import OrdinalEncoder\ntrain_df = pd.read_csv('./data/VBDP/train.csv', index_col=0)\n# remove the id column\n# train_df = train_df.drop(columns=['id'])\nn_samples = train_df.shape[0]\nn_features = train_df.shape[1] - 1\ntarget_column = \"prognosis\"\n# Encode our prognosis labels as integers for easier decoding later\nenc = OrdinalEncoder()\ny = enc.fit_transform(train_df[[target_column]])\ntest_df = pd.read_csv('./data/VBDP/test.csv', index_col=0)\ntest_df\n\n\n\n\n\n\n\n\nsudden_fever\nheadache\nmouth_bleed\nnose_bleed\nmuscle_pain\njoint_pain\nvomiting\nrash\ndiarrhea\nhypotension\n...\nlymph_swells\nbreathing_restriction\ntoe_inflammation\nfinger_inflammation\nlips_irritation\nitchiness\nulcers\ntoenail_loss\nspeech_problem\nbullseye_rash\n\n\nid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n707\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n1.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n708\n1.0\n1.0\n0.0\n1.0\n0.0\n1.0\n1.0\n1.0\n1.0\n1.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n709\n1.0\n1.0\n0.0\n1.0\n1.0\n1.0\n1.0\n0.0\n1.0\n0.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n1.0\n0.0\n0.0\n0.0\n0.0\n\n\n710\n0.0\n1.0\n0.0\n0.0\n0.0\n1.0\n1.0\n1.0\n0.0\n0.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n711\n0.0\n0.0\n1.0\n0.0\n1.0\n1.0\n0.0\n0.0\n1.0\n1.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1005\n0.0\n1.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n1.0\n0.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n1006\n1.0\n0.0\n1.0\n0.0\n1.0\n1.0\n0.0\n1.0\n1.0\n1.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n1007\n1.0\n0.0\n0.0\n1.0\n1.0\n0.0\n1.0\n1.0\n1.0\n1.0\n...\n1.0\n1.0\n1.0\n1.0\n1.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n1008\n1.0\n0.0\n1.0\n1.0\n1.0\n0.0\n1.0\n0.0\n0.0\n0.0\n...\n0.0\n0.0\n0.0\n1.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n1009\n1.0\n0.0\n0.0\n0.0\n0.0\n0.0\n1.0\n0.0\n1.0\n0.0\n...\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n\n\n303 rows × 64 columns\n\n\n\n\nimport torch\nX_tensor = torch.Tensor(test_df.values)\nX_tensor = X_tensor.to(fun_control[\"device\"])\n\n\ny = model_loaded(X_tensor)\ny.shape\n\ntorch.Size([303, 11])\n\n\n\n# convert the predictions to a numpy array\ny = y.cpu().detach().numpy()\ny\n\narray([[9.34182387e-03, 5.37784013e-04, 2.97997333e-03, ...,\n        1.40091812e-03, 2.82173569e-04, 6.32511335e-04],\n       [9.99848008e-01, 7.51649758e-18, 1.86774578e-25, ...,\n        4.66555216e-25, 7.63578790e-28, 1.09261675e-27],\n       [0.00000000e+00, 7.19368104e-34, 4.33420110e-03, ...,\n        3.09993569e-02, 8.19055815e-13, 9.93454279e-08],\n       ...,\n       [0.00000000e+00, 0.00000000e+00, 8.14403385e-16, ...,\n        2.04248618e-09, 1.57991721e-34, 7.37077867e-24],\n       [0.00000000e+00, 2.22367631e-28, 2.23893952e-02, ...,\n        8.89114141e-02, 1.02690148e-10, 2.38016310e-06],\n       [0.00000000e+00, 4.63367610e-30, 1.01549635e-02, ...,\n        5.43198213e-02, 2.20471991e-11, 7.28340353e-07]], dtype=float32)\n\n\n\ntest_sorted_prediction_ids = np.argsort(-y, axis=1)\ntest_top_3_prediction_ids = test_sorted_prediction_ids[:,:3]\noriginal_shape = test_top_3_prediction_ids.shape\ntest_top_3_prediction = enc.inverse_transform(test_top_3_prediction_ids.reshape(-1, 1))\ntest_top_3_prediction = test_top_3_prediction.reshape(original_shape)\ntest_df['prognosis'] = np.apply_along_axis(lambda x: np.array(' '.join(x), dtype=\"object\"), 1, test_top_3_prediction)\ntest_df['prognosis'].reset_index().to_csv('./data/VBDP/submission.csv', index=False)"
  },
  {
    "objectID": "31_spot_lightning_csv.html#appendix",
    "href": "31_spot_lightning_csv.html#appendix",
    "title": "25  HPT PyTorch Lightning: VBDP",
    "section": "25.12 Appendix",
    "text": "25.12 Appendix\n\n25.12.1 Differences to the spotPython Approaches for torch, sklearn and river\n\n\n\n\n\n\nCaution: Data Loading in Lightning\n\n\n\n\nData loading is handled independently from the fun_control dictionary by Lightning and PyTorch.\nIn contrast to spotPython with torch, river and sklearn, the data sets are not added to the fun_control dictionary.\n\n\n\n\n25.12.1.1 Specification of the Preprocessing Model\nThe fun_control dictionary, the torch, sklearnand river versions of spotPython allow the specification of a data preprocessing pipeline, e.g., for the scaling of the data or for the one-hot encoding of categorical variables, see Section 23.4. This feature is not used in the Lightning version.\n\n\n\n\n\n\nCaution: Data preprocessing in Lightning\n\n\n\nLightning allows the data preprocessing to be specified in the LightningDataModule class. It is not considered here, because it should be computed at one location only.\n\n\n\n\n\n25.12.2 Taking a Look at the Data\n\nimport torch\nfrom spotPython.light.csvdataset import CSVDataset\nfrom torch.utils.data import DataLoader\nfrom torchvision.transforms import ToTensor\n\n# Create an instance of CSVDataset\ndataset = CSVDataset(csv_file=\"./data/VBDP/train.csv\", train=True)\n# show the dimensions of the input data\nprint(dataset[0][0].shape)\n# show the first element of the input data\nprint(dataset[0][0])\n# show the size of the dataset\nprint(f\"Dataset Size: {len(dataset)}\")\n\ntorch.Size([64])\ntensor([1., 1., 0., 1., 1., 1., 1., 0., 1., 1., 1., 1., 0., 0., 1., 1., 0., 0.,\n        1., 0., 1., 0., 1., 1., 1., 1., 1., 1., 1., 0., 0., 1., 0., 0., 0., 0.,\n        1., 0., 0., 0., 0., 0., 1., 0., 1., 0., 1., 0., 0., 0., 0., 1., 0., 1.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])\nDataset Size: 707\n\n\n\n# Set batch size for DataLoader\nbatch_size = 3\n# Create DataLoader\ndataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)\n\n# Iterate over the data in the DataLoader\nfor batch in dataloader:\n    inputs, targets = batch\n    print(f\"Batch Size: {inputs.size(0)}\")\n    print(\"---------------\")\n    print(f\"Inputs: {inputs}\")\n    print(f\"Targets: {targets}\")\n    break\n\nBatch Size: 3\n---------------\nInputs: tensor([[1., 0., 1., 1., 1., 1., 1., 1., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n         1., 1., 0., 1., 1., 0., 0., 1., 1., 1., 1., 1., 0., 0., 1., 1., 1., 1.,\n         1., 1., 1., 1., 0., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 0., 0.,\n         0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 1., 1., 1., 0., 0., 0., 0., 1., 0., 1., 1., 0., 0., 0., 1.,\n         0., 0., 1., 0., 1., 1., 1., 0., 1., 0., 1., 0., 0., 0., 1., 0., 1., 1.,\n         0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n         0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 1., 0., 0.,\n         1., 1., 1., 1., 1., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1.,\n         1., 0., 1., 1., 1., 0., 1., 1., 0., 1., 0., 1., 1., 1., 0., 1., 1., 1.,\n         0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]])\nTargets: tensor([4, 5, 8])\n\n\n\n\n25.12.3 The MAPK Metric\nHere is an example how the MAPK metric is calculated.\n\nfrom spotPython.torch.mapk import MAPK\nimport torch\nmapk = MAPK(k=2)\ntarget = torch.tensor([0, 1, 2, 2])\npreds = torch.tensor(\n    [\n        [0.5, 0.2, 0.2],  # 0 is in top 2\n        [0.3, 0.4, 0.2],  # 1 is in top 2\n        [0.2, 0.4, 0.3],  # 2 is in top 2\n        [0.7, 0.2, 0.1],  # 2 isn't in top 2\n    ]\n)\nmapk.update(preds, target)\nprint(mapk.compute()) # tensor(0.6250)\n\ntensor(0.6250)"
  },
  {
    "objectID": "91_intro_to_notebooks.html",
    "href": "91_intro_to_notebooks.html",
    "title": "Appendix A — Introduction to Jupyter Notebook",
    "section": "",
    "text": "B Different Notebook cells\nThere are different cells that the notebook is currently supporting:\nAs a default, every cells in jupyter is set to “code”\nBecause python is a heavily used programming language, there are many different packags that can make your life easier. Sadly, there are only a few standard packages that are already included in your python enviroment. If you have the need to install a new package in your enviroment, you can simply do that by exectuing the following code snippet in a code cell\n!pip install numpy\nHint: It is often usefull to restart the kernel after installing a package, otherwise loading the package could lead to an error.\nAfter successfully installing the package it is necessary to import them before you can work with them. The import of the packages is done in the following way:\nimport numpy as np\nThe imported packages are often abbreviated. This is because you need to specify where the function is coming from.\nThe most common abbreviations for data science packages are:\nBecause python is not using Semicolon’s it is import to keep track of indentation in your code. The indentation works as a placeholder for the semicolons. This is especially important if your are defining loops, functions, etc. …\nExample: We are defining a function that calculates the squared sum of its input parameters\ndef squared_sum(x,y): \n    z = x**2 + y**2\n    return z\nIf you are working with something that needs indentation, it will be already done by the notebook.\nHint: Keep in mind that is good practice to use the return parameter. If you are not using return and a function has multiple paramaters that you would like to return, it will only return the last one defined.\nIf you combine everything you can create beautiful graphics\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Generate 100 random data points along 3 dimensions\nx, y, scale = np.random.randn(3, 100)\nfig, ax = plt.subplots()\n\n# Map each onto a scatterplot we'll create with Matplotlib\nax.scatter(x=x, y=y, c=scale, s=np.abs(scale)*500)\nax.set(title=\"Some random data, created with the Jupyter Notebook!\")\nplt.show()"
  },
  {
    "objectID": "91_intro_to_notebooks.html#code-cells",
    "href": "91_intro_to_notebooks.html#code-cells",
    "title": "Appendix A — Introduction to Jupyter Notebook",
    "section": "B.1 Code cells",
    "text": "B.1 Code cells\nThe code cells are used to execute the code. They are following the logic of the choosen kernel. Therefore, it is important to keep in mind which programming language is currently used. Otherwise one might yield an error because of the wrong syntax.\nThe code cells are executed my be ▶ Run button (can be found in the header of the notebook)."
  },
  {
    "objectID": "91_intro_to_notebooks.html#markdown-cells",
    "href": "91_intro_to_notebooks.html#markdown-cells",
    "title": "Appendix A — Introduction to Jupyter Notebook",
    "section": "B.2 Markdown cells",
    "text": "B.2 Markdown cells\nThe markdown cells are a usefull tool to comment the written code. Especially with the help of headers can the code be brought in a more readable format. If you are not familiar with the markdown syntax, you can find a usefull cheat sheet here: Markdown Cheat Sheeet"
  },
  {
    "objectID": "91_intro_to_notebooks.html#raw-cells",
    "href": "91_intro_to_notebooks.html#raw-cells",
    "title": "Appendix A — Introduction to Jupyter Notebook",
    "section": "B.3 Raw cells",
    "text": "B.3 Raw cells\nThe “Raw NBConvert” cell type can be used to render different code formats into HTML or LaTeX by Sphinx. This information is stored in the notebook metadata and converted appropriately.\n\nB.3.1 Usage\nTo select a desired format from within Jupyter, select the cell containing your special code and choose options from the following dropdown menus:\n\nSelect “Raw NBConvert”\nSwitch the Cell Toolbar to “Raw Cell Format” (The cell toolbar can be found under View)\nChose the appropriate “Raw NBConvert Format” within the cell\n\nData Science is fun"
  },
  {
    "objectID": "99_spot_doc.html#example-spot",
    "href": "99_spot_doc.html#example-spot",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.1 Example: spot",
    "text": "D.1 Example: spot\n\nimport numpy as np\nfrom math import inf\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nfrom scipy.optimize import shgo\nfrom scipy.optimize import direct\nfrom scipy.optimize import differential_evolution\nimport matplotlib.pyplot as plt\n\n\nD.1.1 The Objective Function\nThe spotPython package provides several classes of objective functions. We will use an analytical objective function, i.e., a function that can be described by a (closed) formula: \\[f(x) = x^2\\]\n\nfun = analytical().fun_sphere\n\n\nx = np.linspace(-1,1,100).reshape(-1,1)\ny = fun(x)\nplt.figure()\nplt.plot(x,y, \"k\")\nplt.show()\n\n\n\n\n\nspot_1 = spot.Spot(fun=fun,\n                   lower = np.array([-10]),\n                   upper = np.array([100]),\n                   fun_evals = 7,\n                   fun_repeats = 1,\n                   max_time = inf,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type=[\"num\"],\n                   infill_criterion = \"y\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models=True,\n                   fun_control = {},\n                   design_control={\"init_size\": 5,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": False,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": 1,\n                                      \"model_optimizer\": differential_evolution,\n                                      \"model_fun_evals\": 1000,\n                                      })\n\nspot’s __init__ method sets the control parameters. There are two parameter groups:\n\nexternal parameters can be specified by the user\ninternal parameters, which are handled by spot.\n\n\n\nD.1.2 External Parameters\n\n\n\n\n\n\n\n\n\n\nexternal parameter\ntype\ndescription\ndefault\nmandatory\n\n\n\n\nfun\nobject\nobjective function\n\nyes\n\n\nlower\narray\nlower bound\n\nyes\n\n\nupper\narray\nupper bound\n\nyes\n\n\nfun_evals\nint\nnumber of function evaluations\n15\nno\n\n\nfun_evals\nint\nnumber of function evaluations\n15\nno\n\n\nfun_control\ndict\nnoise etc.\n{}\nn\n\n\nmax_time\nint\nmax run time budget\ninf\nno\n\n\nnoise\nbool\nif repeated evaluations of fun results in different values, then noise should be set to True.\nFalse\nno\n\n\ntolerance_x\nfloat\ntolerance for new x solutions. Minimum distance of new solutions, generated by suggest_new_X, to already existing solutions. If zero (which is the default), every new solution is accepted.\n0\nno\n\n\nvar_type\nlist\nlist of type information, can be either \"num\" or \"factor\"\n[\"num\"]\nno\n\n\ninfill_criterion\nstring\nCan be \"y\", \"s\", \"ei\" (negative expected improvement), or \"all\"\n\"y\"\nno\n\n\nn_points\nint\nnumber of infill points\n1\nno\n\n\nseed\nint\ninitial seed. If Spot.run() is called twice, different results will be generated. To reproduce results, the seed can be used.\n123\nno\n\n\nlog_level\nint\nlog level with the following settings: NOTSET (0), DEBUG (10: Detailed information, typically of interest only when diagnosing problems.), INFO (20: Confirmation that things are working as expected.), WARNING (30: An indication that something unexpected happened, or indicative of some problem in the near future (e.g. ‘disk space low’). The software is still working as expected.), ERROR (40: Due to a more serious problem, the software has not been able to perform some function.), and CRITICAL (50: A serious error, indicating that the program itself may be unable to continue running.)\n50\nno\n\n\nshow_models\nbool\nPlot model. Currently only 1-dim functions are supported\nFalse\nno\n\n\ndesign\nobject\nexperimental design\nNone\nno\n\n\ndesign_control\ndict\ncontrol parameters\nsee below\nno\n\n\nsurrogate\n\nsurrogate model\nkriging\nno\n\n\nsurrogate_control\ndict\ncontrol parameters\nsee below\nno\n\n\noptimizer\nobject\noptimizer\nsee below\nno\n\n\noptimizer_control\ndict\ncontrol parameters\nsee below\nno\n\n\n\n\nBesides these single parameters, the following parameter dictionaries can be specified by the user:\n\nfun_control\ndesign_control\nsurrogate_control\noptimizer_control"
  },
  {
    "objectID": "99_spot_doc.html#the-fun_control-dictionary",
    "href": "99_spot_doc.html#the-fun_control-dictionary",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.2 The fun_control Dictionary",
    "text": "D.2 The fun_control Dictionary\n\n\n\nexternal parameter\ntype\ndescription\ndefault\nmandatory\n\n\n\n\nsigma\nfloat\nnoise: standard deviation\n0\nyes\n\n\nseed\nint\nseed for rng\n124\nyes"
  },
  {
    "objectID": "99_spot_doc.html#the-design_control-dictionary",
    "href": "99_spot_doc.html#the-design_control-dictionary",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.3 The design_control Dictionary",
    "text": "D.3 The design_control Dictionary\n\n\n\n\n\n\n\n\n\n\nexternal parameter\ntype\ndescription\ndefault\nmandatory\n\n\n\n\ninit_size\nint\ninitial sample size\n10\nyes\n\n\nrepeats\nint\nnumber of repeats of the initial sammples\n1\nyes"
  },
  {
    "objectID": "99_spot_doc.html#the-surrogate_control-dictionary",
    "href": "99_spot_doc.html#the-surrogate_control-dictionary",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.4 The surrogate_control Dictionary",
    "text": "D.4 The surrogate_control Dictionary\n\n\n\n\n\n\n\n\n\n\nexternal parameter\ntype\ndescription\ndefault\nmandatory\n\n\n\n\nnoise\n\n\n\n\n\n\nmodel_optimizer\nobject\noptimizer\ndifferential_evolution\nno\n\n\nmodel_fun_evals\n\n\n\n\n\n\nmin_theta\n\n\n-3.\n\n\n\nmax_theta\n\n\n3.\n\n\n\nn_theta\n\n\n1\n\n\n\nn_p\n\n\n1\n\n\n\noptim_p\n\n\nFalse\n\n\n\ncod_type\n\n\n\"norm\"\n\n\n\nvar_type\n\n\n\n\n\n\nuse_cod_y\nbool\n\nFalse"
  },
  {
    "objectID": "99_spot_doc.html#the-optimizer_control-dictionary",
    "href": "99_spot_doc.html#the-optimizer_control-dictionary",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.5 The optimizer_control Dictionary",
    "text": "D.5 The optimizer_control Dictionary\n\n\n\n\n\n\n\n\n\n\nexternal parameter\ntype\ndescription\ndefault\nmandatory\n\n\n\n\nmax_iter\nint\nmax number of iterations. Note: these are the cheap evaluations on the surrogate.\n1000\nno"
  },
  {
    "objectID": "99_spot_doc.html#run",
    "href": "99_spot_doc.html#run",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.6 Run",
    "text": "D.6 Run\n\nspot_1.run()\n\n\n\n\n\n\n\nspotPython tuning: 1.6142446477388548 [#########-] 85.71% \n\n\n\n\n\nspotPython tuning: 0.29984480579304645 [##########] 100.00% Done...\n\n\n\n&lt;spotPython.spot.spot.Spot at 0x1483728d0&gt;"
  },
  {
    "objectID": "99_spot_doc.html#print-the-results",
    "href": "99_spot_doc.html#print-the-results",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.7 Print the Results",
    "text": "D.7 Print the Results\n\nspot_1.print_results()\n\nmin y: 0.29984480579304645\nx0: -0.5475808668982568\n\n\n[['x0', -0.5475808668982568]]"
  },
  {
    "objectID": "99_spot_doc.html#show-the-progress",
    "href": "99_spot_doc.html#show-the-progress",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.8 Show the Progress",
    "text": "D.8 Show the Progress\n\nspot_1.plot_progress()"
  },
  {
    "objectID": "99_spot_doc.html#visualize-the-surrogate",
    "href": "99_spot_doc.html#visualize-the-surrogate",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.9 Visualize the Surrogate",
    "text": "D.9 Visualize the Surrogate\n\nThe plot method of the kriging surrogate is used.\nNote: the plot uses the interval defined by the ranges of the natural variables.\n\n\nspot_1.surrogate.plot()\n\n&lt;Figure size 864x576 with 0 Axes&gt;"
  },
  {
    "objectID": "99_spot_doc.html#run-with-a-specific-start-design",
    "href": "99_spot_doc.html#run-with-a-specific-start-design",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.10 Run With a Specific Start Design",
    "text": "D.10 Run With a Specific Start Design\n\nspot_x0 = spot.Spot(fun=fun,\n                   lower = np.array([-10, -10]),\n                   upper = np.array([10, 10]),\n                   fun_evals = 7,\n                   fun_repeats = 1,\n                   max_time = inf,\n                   noise = False,\n                   tolerance_x = np.sqrt(np.spacing(1)),\n                   var_type=[\"num\"],\n                   infill_criterion = \"y\",\n                   n_points = 1,\n                   seed=123,\n                   log_level = 50,\n                   show_models=False,\n                   fun_control = {},\n                   design_control={\"init_size\": 5,\n                                   \"repeats\": 1},\n                   surrogate_control={\"noise\": False,\n                                      \"cod_type\": \"norm\",\n                                      \"min_theta\": -4,\n                                      \"max_theta\": 3,\n                                      \"n_theta\": 2,\n                                      \"model_optimizer\": differential_evolution,\n                                      \"model_fun_evals\": 1000,\n                                      })\nspot_x0.run(X_start=np.array([0.5, -0.5]))\nspot_x0.plot_progress()\n\nspotPython tuning: 9.869670875300805 [#########-] 85.71% \n\n\nspotPython tuning: 1.5261843012598162 [##########] 100.00% Done..."
  },
  {
    "objectID": "99_spot_doc.html#init-build-initial-design",
    "href": "99_spot_doc.html#init-build-initial-design",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.11 Init: Build Initial Design",
    "text": "D.11 Init: Build Initial Design\n\nfrom spotPython.design.spacefilling import spacefilling\nfrom spotPython.build.kriging import Kriging\nfrom spotPython.fun.objectivefunctions import analytical\ngen = spacefilling(2)\nrng = np.random.RandomState(1)\nlower = np.array([-5,-0])\nupper = np.array([10,15])\nfun = analytical().fun_branin\nfun_control = {\"sigma\": 0,\n               \"seed\": 123}\n\nX = gen.scipy_lhd(10, lower=lower, upper = upper)\nprint(X)\ny = fun(X, fun_control=fun_control)\nprint(y)\n\n[[ 8.97647221 13.41926847]\n [ 0.66946019  1.22344228]\n [ 5.23614115 13.78185824]\n [ 5.6149825  11.5851384 ]\n [-1.72963184  1.66516096]\n [-4.26945568  7.1325531 ]\n [ 1.26363761 10.17935555]\n [ 2.88779942  8.05508969]\n [-3.39111089  4.15213772]\n [ 7.30131231  5.22275244]]\n[128.95676449  31.73474356 172.89678121 126.71295908  64.34349975\n  70.16178611  48.71407916  31.77322887  76.91788181  30.69410529]"
  },
  {
    "objectID": "99_spot_doc.html#replicability",
    "href": "99_spot_doc.html#replicability",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.12 Replicability",
    "text": "D.12 Replicability\nSeed\n\ngen = spacefilling(2, seed=123)\nX0 = gen.scipy_lhd(3)\ngen = spacefilling(2, seed=345)\nX1 = gen.scipy_lhd(3)\nX2 = gen.scipy_lhd(3)\ngen = spacefilling(2, seed=123)\nX3 = gen.scipy_lhd(3)\nX0, X1, X2, X3\n\n(array([[0.77254938, 0.31539299],\n        [0.59321338, 0.93854273],\n        [0.27469803, 0.3959685 ]]),\n array([[0.78373509, 0.86811887],\n        [0.06692621, 0.6058029 ],\n        [0.41374778, 0.00525456]]),\n array([[0.121357  , 0.69043832],\n        [0.41906219, 0.32838498],\n        [0.86742658, 0.52910374]]),\n array([[0.77254938, 0.31539299],\n        [0.59321338, 0.93854273],\n        [0.27469803, 0.3959685 ]]))"
  },
  {
    "objectID": "99_spot_doc.html#surrogates",
    "href": "99_spot_doc.html#surrogates",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.13 Surrogates",
    "text": "D.13 Surrogates\n\nD.13.1 A Simple Predictor\nThe code below shows how to use a simple model for prediction. Assume that only two (very costly) measurements are available:\n\nf(0) = 0.5\nf(2) = 2.5\n\nWe are interested in the value at \\(x_0 = 1\\), i.e., \\(f(x_0 = 1)\\), but cannot run an additional, third experiment.\n\nfrom sklearn import linear_model\nX = np.array([[0], [2]])\ny = np.array([0.5, 2.5])\nS_lm = linear_model.LinearRegression()\nS_lm = S_lm.fit(X, y)\nX0 = np.array([[1]])\ny0 = S_lm.predict(X0)\nprint(y0)\n\n[1.5]\n\n\nCentral Idea: Evaluation of the surrogate model S_lm is much cheaper (or / and much faster) than running the real-world experiment \\(f\\)."
  },
  {
    "objectID": "99_spot_doc.html#demotest-objective-function-fails",
    "href": "99_spot_doc.html#demotest-objective-function-fails",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.14 Demo/Test: Objective Function Fails",
    "text": "D.14 Demo/Test: Objective Function Fails\nSPOT expects np.nan values from failed objective function values. These are handled. Note: SPOT’s counter considers only successful executions of the objective function.\n\nimport numpy as np\nfrom spotPython.fun.objectivefunctions import analytical\nfrom spotPython.spot import spot\nimport numpy as np\nfrom math import inf\n# number of initial points:\nni = 20\n# number of points\nn = 30\n\nfun = analytical().fun_random_error\nlower = np.array([-1])\nupper = np.array([1])\ndesign_control={\"init_size\": ni}\n\nspot_1 = spot.Spot(fun=fun,\n            lower = lower,\n            upper= upper,\n            fun_evals = n,\n            show_progress=False,\n            design_control=design_control,)\nspot_1.run()\n# To check whether the run was successfully completed,\n# we compare the number of evaluated points to the specified\n# number of points.\nassert spot_1.y.shape[0] == n\n\n[ 0.53176481 -0.9053821  -0.02203599 -0.21843718  0.78240941 -0.58120945\n -0.3923345   0.67234256  0.31802454 -0.68898927 -0.75129705  0.97550354\n         nan  0.0786237   0.82585329  0.23700598 -0.49274073 -0.82319082\n -0.17991251  0.1481835 ]\n\n\n[-1.]\n\n\n[0.17335968]\n\n\n[nan]\n\n\n[-0.58552368]\n\n\n[-0.20126111]\n\n\n[-0.60100809]\n\n\n[-0.97897336]\n\n\n[-0.2748985]\n\n\n[0.8359486]\n\n\n[0.99035591]\n\n\n[0.01641232]\n\n\n[0.5629346]"
  },
  {
    "objectID": "99_spot_doc.html#sec-detailed-data-splitting",
    "href": "99_spot_doc.html#sec-detailed-data-splitting",
    "title": "Appendix D — Documentation of the Sequential Parameter Optimization",
    "section": "D.15 PyTorch: Detailed Description of the Data Splitting",
    "text": "D.15 PyTorch: Detailed Description of the Data Splitting\n\nD.15.1 Description of the \"train_hold_out\" Setting\nThe \"train_hold_out\" setting is used by default. It uses the loss function specfied in fun_control and the metric specified in fun_control.\n\nFirst, the method HyperTorch().fun_torch is called.\nfun_torc(), which is implemented in the file hypertorch.py, calls evaluate_hold_out() as follows:\n\ndf_eval, _ = evaluate_hold_out(\n    model,\n    train_dataset=fun_control[\"train\"],\n    shuffle=self.fun_control[\"shuffle\"],\n    loss_function=self.fun_control[\"loss_function\"],\n    metric=self.fun_control[\"metric_torch\"],\n    device=self.fun_control[\"device\"],\n    show_batch_interval=self.fun_control[\"show_batch_interval\"],\n    path=self.fun_control[\"path\"],\n    task=self.fun_control[\"task\"],\n    writer=self.fun_control[\"writer\"],\n    writerId=config_id,\n)\nNote: Only the data set fun_control[\"train\"] is used for training and validation. It is used in evaluate_hold_out as follows:\ntrainloader, valloader = create_train_val_data_loaders(\n                dataset=train_dataset, batch_size=batch_size_instance, shuffle=shuffle\n            )\ncreate_train_val_data_loaders() splits the train_dataset into trainloader and valloader using torch.utils.data.random_split() as follows:\ndef create_train_val_data_loaders(dataset, batch_size, shuffle, num_workers=0):\n    test_abs = int(len(dataset) * 0.6)\n    train_subset, val_subset = random_split(dataset, [test_abs, len(dataset) - test_abs])\n    trainloader = torch.utils.data.DataLoader(\n        train_subset, batch_size=int(batch_size), shuffle=shuffle, num_workers=num_workers\n    )\n    valloader = torch.utils.data.DataLoader(\n        val_subset, batch_size=int(batch_size), shuffle=shuffle, num_workers=num_workers\n    )\n    return trainloader, valloader\nThe optimizer is set up as follows:\noptimizer_instance = net.optimizer\nlr_mult_instance = net.lr_mult\nsgd_momentum_instance = net.sgd_momentum\noptimizer = optimizer_handler(\n    optimizer_name=optimizer_instance,\n    params=net.parameters(),\n    lr_mult=lr_mult_instance,\n    sgd_momentum=sgd_momentum_instance,\n)\n\nevaluate_hold_out() sets the net attributes such as epochs, batch_size, optimizer, and patience. For each epoch, the methods train_one_epoch() and validate_one_epoch() are called, the former for training and the latter for validation and early stopping. The validation loss from the last epoch (not the best validation loss) is returned from evaluate_hold_out.\nThe method train_one_epoch() is implemented as follows:\n\ndef train_one_epoch(\n    net,\n    trainloader,\n    batch_size,\n    loss_function,\n    optimizer,\n    device,\n    show_batch_interval=10_000,\n    task=None,\n):\n    running_loss = 0.0\n    epoch_steps = 0\n    for batch_nr, data in enumerate(trainloader, 0):\n        input, target = data\n        input, target = input.to(device), target.to(device)\n        optimizer.zero_grad()\n        output = net(input)\n        if task == \"regression\":\n            target = target.unsqueeze(1)\n            if target.shape == output.shape:\n                loss = loss_function(output, target)\n            else:\n                raise ValueError(f\"Shapes of target and output do not match:\n                 {target.shape} vs {output.shape}\")\n        elif task == \"classification\":\n            loss = loss_function(output, target)\n        else:\n            raise ValueError(f\"Unknown task: {task}\")\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(net.parameters(), max_norm=1.0)\n        optimizer.step()\n        running_loss += loss.item()\n        epoch_steps += 1\n        if batch_nr % show_batch_interval == (show_batch_interval - 1):  \n            print(\n                \"Batch: %5d. Batch Size: %d. Training Loss (running): %.3f\"\n                % (batch_nr + 1, int(batch_size), running_loss / epoch_steps)\n            )\n            running_loss = 0.0\n    return loss.item()\n\nThe method validate_one_epoch() is implemented as follows:\n\ndef validate_one_epoch(net, valloader, loss_function, metric, device, task):\n    val_loss = 0.0\n    val_steps = 0\n    total = 0\n    correct = 0\n    metric.reset()\n    for i, data in enumerate(valloader, 0):\n        # get batches\n        with torch.no_grad():\n            input, target = data\n            input, target = input.to(device), target.to(device)\n            output = net(input)\n            # print(f\"target: {target}\")\n            # print(f\"output: {output}\")\n            if task == \"regression\":\n                target = target.unsqueeze(1)\n                if target.shape == output.shape:\n                    loss = loss_function(output, target)\n                else:\n                    raise ValueError(f\"Shapes of target and output \n                        do not match: {target.shape} vs {output.shape}\")\n                metric_value = metric.update(output, target)\n            elif task == \"classification\":\n                loss = loss_function(output, target)\n                metric_value = metric.update(output, target)\n                _, predicted = torch.max(output.data, 1)\n                total += target.size(0)\n                correct += (predicted == target).sum().item()\n            else:\n                raise ValueError(f\"Unknown task: {task}\")\n            val_loss += loss.cpu().numpy()\n            val_steps += 1\n    loss = val_loss / val_steps\n    print(f\"Loss on hold-out set: {loss}\")\n    if task == \"classification\":\n        accuracy = correct / total\n        print(f\"Accuracy on hold-out set: {accuracy}\")\n    # metric on all batches using custom accumulation\n    metric_value = metric.compute()\n    metric_name = type(metric).__name__\n    print(f\"{metric_name} value on hold-out data: {metric_value}\")\n    return metric_value, loss\n\nD.15.1.1 Description of the \"test_hold_out\" Setting\nIt uses the loss function specfied in fun_control and the metric specified in fun_control.\n\nFirst, the method HyperTorch().fun_torch is called.\nfun_torc() calls spotPython.torch.traintest.evaluate_hold_out() similar to the \"train_hold_out\" setting with one exception: It passes an additional test data set to evaluate_hold_out() as follows:\n\ntest_dataset=fun_control[\"test\"]\nevaluate_hold_out() calls create_train_test_data_loaders instead of create_train_val_data_loaders: The two data sets are used in create_train_test_data_loaders as follows:\ndef create_train_test_data_loaders(dataset, batch_size, shuffle, test_dataset, \n        num_workers=0):\n    trainloader = torch.utils.data.DataLoader(\n        dataset, batch_size=int(batch_size), shuffle=shuffle, \n        num_workers=num_workers\n    )\n    testloader = torch.utils.data.DataLoader(\n        test_dataset, batch_size=int(batch_size), shuffle=shuffle, \n        num_workers=num_workers\n    )\n    return trainloader, testloader\n\nThe following steps are identical to the \"train_hold_out\" setting. Only a different data loader is used for testing.\n\n\n\nD.15.1.2 Detailed Description of the \"train_cv\" Setting\nIt uses the loss function specfied in fun_control and the metric specified in fun_control.\n\nFirst, the method HyperTorch().fun_torch is called.\nfun_torc() calls spotPython.torch.traintest.evaluate_cv() as follows (Note: Only the data set fun_control[\"train\"] is used for CV.):\n\ndf_eval, _ = evaluate_cv(\n    model,\n    dataset=fun_control[\"train\"],\n    shuffle=self.fun_control[\"shuffle\"],\n    device=self.fun_control[\"device\"],\n    show_batch_interval=self.fun_control[\"show_batch_interval\"],\n    task=self.fun_control[\"task\"],\n    writer=self.fun_control[\"writer\"],\n    writerId=config_id,\n)\n\nIn `evaluate_cv(), the following steps are performed: The optimizer is set up as follows:\n\noptimizer_instance = net.optimizer\nlr_instance = net.lr\nsgd_momentum_instance = net.sgd_momentum\noptimizer = optimizer_handler(optimizer_name=optimizer_instance,\n     params=net.parameters(), lr_mult=lr_mult_instance)\nevaluate_cv() sets the net attributes such as epochs, batch_size, optimizer, and patience. CV is implemented as follows:\ndef evaluate_cv(\n    net,\n    dataset,\n    shuffle=False,\n    loss_function=None,\n    num_workers=0,\n    device=None,\n    show_batch_interval=10_000,\n    metric=None,\n    path=None,\n    task=None,\n    writer=None,\n    writerId=None,\n):\n    lr_mult_instance = net.lr_mult\n    epochs_instance = net.epochs\n    batch_size_instance = net.batch_size\n    k_folds_instance = net.k_folds\n    optimizer_instance = net.optimizer\n    patience_instance = net.patience\n    sgd_momentum_instance = net.sgd_momentum\n    removed_attributes, net = get_removed_attributes_and_base_net(net)\n    metric_values = {}\n    loss_values = {}\n    try:\n        device = getDevice(device=device)\n        if torch.cuda.is_available():\n            device = \"cuda:0\"\n            if torch.cuda.device_count() &gt; 1:\n                print(\"We will use\", torch.cuda.device_count(), \"GPUs!\")\n                net = nn.DataParallel(net)\n        net.to(device)\n        optimizer = optimizer_handler(\n            optimizer_name=optimizer_instance,\n            params=net.parameters(),\n            lr_mult=lr_mult_instance,\n            sgd_momentum=sgd_momentum_instance,\n        )\n        kfold = KFold(n_splits=k_folds_instance, shuffle=shuffle)\n        for fold, (train_ids, val_ids) in enumerate(kfold.split(dataset)):\n            print(f\"Fold: {fold + 1}\")\n            train_subsampler = torch.utils.data.SubsetRandomSampler(train_ids)\n            val_subsampler = torch.utils.data.SubsetRandomSampler(val_ids)\n            trainloader = torch.utils.data.DataLoader(\n                dataset, batch_size=batch_size_instance, \n                sampler=train_subsampler, num_workers=num_workers\n            )\n            valloader = torch.utils.data.DataLoader(\n                dataset, batch_size=batch_size_instance, \n                sampler=val_subsampler, num_workers=num_workers\n            )\n            # each fold starts with new weights:\n            reset_weights(net)\n            # Early stopping parameters\n            best_val_loss = float(\"inf\")\n            counter = 0\n            for epoch in range(epochs_instance):\n                print(f\"Epoch: {epoch + 1}\")\n                # training loss from one epoch:\n                training_loss = train_one_epoch(\n                    net=net,\n                    trainloader=trainloader,\n                    batch_size=batch_size_instance,\n                    loss_function=loss_function,\n                    optimizer=optimizer,\n                    device=device,\n                    show_batch_interval=show_batch_interval,\n                    task=task,\n                )\n                # Early stopping check. Calculate validation loss from one epoch:\n                metric_values[fold], loss_values[fold] = validate_one_epoch(\n                    net, valloader=valloader, loss_function=loss_function, \n                    metric=metric, device=device, task=task\n                )\n                # Log the running loss averaged per batch\n                metric_name = \"Metric\"\n                if metric is None:\n                    metric_name = type(metric).__name__\n                    print(f\"{metric_name} value on hold-out data: \n                        {metric_values[fold]}\")\n                if writer is not None:\n                    writer.add_scalars(\n                        \"evaluate_cv fold:\" + str(fold + 1) + \n                        \". Train & Val Loss and Val Metric\" + writerId,\n                        {\"Train loss\": training_loss, \"Val loss\": \n                        loss_values[fold], metric_name: metric_values[fold]},\n                        epoch + 1,\n                    )\n                    writer.flush()\n                if loss_values[fold] &lt; best_val_loss:\n                    best_val_loss = loss_values[fold]\n                    counter = 0\n                    # save model:\n                    if path is not None:\n                        torch.save(net.state_dict(), path)\n                else:\n                    counter += 1\n                    if counter &gt;= patience_instance:\n                        print(f\"Early stopping at epoch {epoch}\")\n                        break\n        df_eval = sum(loss_values.values()) / len(loss_values.values())\n        df_metrics = sum(metric_values.values()) / len(metric_values.values())\n        df_preds = np.nan\n    except Exception as err:\n        print(f\"Error in Net_Core. Call to evaluate_cv() failed. {err=}, \n            {type(err)=}\")\n        df_eval = np.nan\n        df_preds = np.nan\n    add_attributes(net, removed_attributes)\n    if writer is not None:\n        metric_name = \"Metric\"\n        if metric is None:\n            metric_name = type(metric).__name__\n        writer.add_scalars(\n            \"CV: Val Loss and Val Metric\" + writerId,\n            {\"CV-loss\": df_eval, metric_name: df_metrics},\n            epoch + 1,\n        )\n        writer.flush()\n    return df_eval, df_preds, df_metrics\n\nThe method train_fold() is implemented as shown above.\nThe method validate_one_epoch() is implemented as shown above. In contrast to the hold-out setting, it is called for each of the \\(k\\) folds. The results are stored in a dictionaries metric_values and loss_values. The results are averaged over the \\(k\\) folds and returned as df_eval.\n\n\n\nD.15.1.3 Detailed Description of the \"test_cv\" Setting\nIt uses the loss function specfied in fun_control and the metric specified in fun_control.\n\nFirst, the method HyperTorch().fun_torch is called.\nfun_torc() calls spotPython.torch.traintest.evaluate_cv() as follows:\n\ndf_eval, _ = evaluate_cv(\n    model,\n    dataset=fun_control[\"test\"],\n    shuffle=self.fun_control[\"shuffle\"],\n    device=self.fun_control[\"device\"],\n    show_batch_interval=self.fun_control[\"show_batch_interval\"],\n    task=self.fun_control[\"task\"],\n    writer=self.fun_control[\"writer\"],\n    writerId=config_id,\n)\nNote: The data set fun_control[\"test\"] is used for CV. The rest is the same as for the \"train_cv\" setting.\n\n\nD.15.1.4 Detailed Description of the Final Model Training and Evaluation\nThere are two methods that can be used for the final evaluation of a Pytorch model:\n\n\"train_tuned and\n\"test_tuned\".\n\ntrain_tuned() is just a wrapper to evaluate_hold_out using the train data set. It is implemented as follows:\ndef train_tuned(\n    net,\n    train_dataset,\n    shuffle,\n    loss_function,\n    metric,\n    device=None,\n    show_batch_interval=10_000,\n    path=None,\n    task=None,\n    writer=None,\n):\n    evaluate_hold_out(\n        net=net,\n        train_dataset=train_dataset,\n        shuffle=shuffle,\n        test_dataset=None,\n        loss_function=loss_function,\n        metric=metric,\n        device=device,\n        show_batch_interval=show_batch_interval,\n        path=path,\n        task=task,\n        writer=writer,\n    )\nThe test_tuned() procedure is implemented as follows:\ndef test_tuned(net, shuffle, test_dataset=None, loss_function=None,\n    metric=None, device=None, path=None, task=None):\n    batch_size_instance = net.batch_size\n    removed_attributes, net = get_removed_attributes_and_base_net(net)\n    if path is not None:\n        net.load_state_dict(torch.load(path))\n        net.eval()\n    try:\n        device = getDevice(device=device)\n        if torch.cuda.is_available():\n            device = \"cuda:0\"\n            if torch.cuda.device_count() &gt; 1:\n                print(\"We will use\", torch.cuda.device_count(), \"GPUs!\")\n                net = nn.DataParallel(net)\n        net.to(device)\n        valloader = torch.utils.data.DataLoader(\n            test_dataset, batch_size=int(batch_size_instance),\n            shuffle=shuffle, \n            num_workers=0\n        )\n        metric_value, loss = validate_one_epoch(\n            net, valloader=valloader, loss_function=loss_function,\n            metric=metric, device=device, task=task\n        )\n        df_eval = loss\n        df_metric = metric_value\n        df_preds = np.nan\n    except Exception as err:\n        print(f\"Error in Net_Core. Call to test_tuned() failed. {err=}, \n            {type(err)=}\")\n        df_eval = np.nan\n        df_metric = np.nan\n        df_preds = np.nan\n    add_attributes(net, removed_attributes)\n    print(f\"Final evaluation: Validation loss: {df_eval}\")\n    print(f\"Final evaluation: Validation metric: {df_metric}\")\n    print(\"----------------------------------------------\")\n    return df_eval, df_preds, df_metric"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Bartz, Eva, Thomas Bartz-Beielstein, Martin Zaefferer, and Olaf\nMersmann, eds. 2022. Hyperparameter Tuning for\nMachine and Deep Learning with R - A Practical Guide.\nSpringer.\n\n\nBartz-Beielstein, Thomas. 2023. “PyTorch\nHyperparameter Tuning with SPOT: Comparison with Ray\nTuner and Default Hyperparameters on\nCIFAR10.” https://github.com/sequential-parameter-optimization/spotPython/blob/main/notebooks/14_spot_ray_hpt_torch_cifar10.ipynb.\n\n\nBartz-Beielstein, Thomas, Jürgen Branke, Jörn Mehnen, and Olaf Mersmann.\n2014. “Evolutionary Algorithms.” Wiley\nInterdisciplinary Reviews: Data Mining and Knowledge Discovery 4\n(3): 178–95.\n\n\nBartz-Beielstein, Thomas, Carola Doerr, Jakob Bossek, Sowmya\nChandrasekaran, Tome Eftimov, Andreas Fischbach, Pascal Kerschke, et al.\n2020. “Benchmarking in Optimization: Best Practice and Open\nIssues.” arXiv. https://arxiv.org/abs/2007.03488.\n\n\nBartz-Beielstein, Thomas, Christian Lasarczyk, and Mike Preuss. 2005.\n“Sequential Parameter Optimization.” In\nProceedings 2005 Congress on Evolutionary\nComputation (CEC’05), Edinburgh, Scotland, edited by B McKay\net al., 773–80. Piscataway NJ: IEEE Press.\n\n\nLewis, R M, V Torczon, and M W Trosset. 2000. “Direct search methods: Then and now.”\nJournal of Computational and Applied Mathematics 124 (1–2):\n191–207.\n\n\nLi, Lisha, Kevin Jamieson, Giulia DeSalvo, Afshin Rostamizadeh, and\nAmeet Talwalkar. 2016. “Hyperband: A Novel\nBandit-Based Approach to Hyperparameter Optimization.”\narXiv e-Prints, March, arXiv:1603.06560.\n\n\nMeignan, David, Sigrid Knust, Jean-Marc Frayet, Gilles Pesant, and\nNicolas Gaud. 2015. “A Review and Taxonomy of\nInteractive Optimization Methods in Operations Research.”\nACM Transactions on Interactive Intelligent Systems, September.\n\n\nMontiel, Jacob, Max Halford, Saulo Martiello Mastelini, Geoffrey\nBolmier, Raphael Sourty, Robin Vaysse, Adil Zouitine, et al. 2021.\n“River: Machine Learning for Streaming Data in Python.”\n\n\nPyTorch. 2023a. “Hyperparameter Tuning with Ray Tune.” https://pytorch.org/tutorials/beginner/hyperparameter_tuning_tutorial.html.\n\n\n———. 2023b. “Training a Classifier.” https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html."
  },
  {
    "objectID": "002_awwe.html#awwe-equation",
    "href": "002_awwe.html#awwe-equation",
    "title": "2  Aircraft Wing Weight Example",
    "section": "2.1 AWWE Equation",
    "text": "2.1 AWWE Equation\n\nExample from Forrester et al. \nUnderstand the weight of an unpainted light aircraft wing as a function of nine design and operational parameters:\n\n\\[ W = 0.036 S_W^{0.758} \\times W_{fw}^{0.0035} \\left( \\frac{A}{\\cos^2 \\Lambda} \\right)^{0.6} \\times  q^{0.006}  \\times \\lambda^{0.04} \\] \\[ \\times \\left( \\frac{100 R_{tc}}{\\cos \\Lambda} \\right)^{-0.3} \\times (N_z W_{dg})^{0.49}\\]"
  },
  {
    "objectID": "002_awwe.html#awwe-parameters-and-equations-part-1",
    "href": "002_awwe.html#awwe-parameters-and-equations-part-1",
    "title": "2  Aircraft Wing Weight Example",
    "section": "2.2 AWWE Parameters and Equations (Part 1)",
    "text": "2.2 AWWE Parameters and Equations (Part 1)\n\n\nTable 2.1: Aircraft Wing Weight Parameters\n\n\n\n\n\n\n\n\n\nSymbol\nParameter\nBaseline\nMinimum\nMaximum\n\n\n\n\n\\(S_W\\)\nWing area (\\(ft^2\\))\n174\n150\n200\n\n\n\\(W_{fw}\\)\nWeight of fuel in wing (lb)\n252\n220\n300\n\n\n\\(A\\)\nAspect ratio\n7.52\n6\n10\n\n\n\\(\\Lambda\\)\nQuarter-chord sweep (deg)\n0\n-10\n10\n\n\n\\(q\\)\nDynamic pressure at cruise (\\(lb/ft^2\\))\n34\n16\n45\n\n\n\\(\\lambda\\)\nTaper ratio\n0.672\n0.5\n1\n\n\n\\(R_{tc}\\)\nAerofoil thickness to chord ratio\n0.12\n0.08\n0.18\n\n\n\\(N_z\\)\nUltimate load factor\n3.8\n2.5\n6\n\n\n\\(W_{dg}\\)\nFlight design gross weight (lb)\n2000\n1700\n2500\n\n\n\\(W_p\\)\npaint weight (lb/ft^2)\n0.064\n0.025\n0.08\n\n\n\n\nThe study begins with a baseline Cessna C172 Skyhawk Aircraft as its reference point. It aims to investigate the impact of wing area and fuel weight on the overall weight of the aircraft. Two crucial parameters in this analysis are the aspect ratio (\\(A\\)), defined as the ratio of the wing’s length to the average chord (thickness of the airfoil), and the taper ratio (\\(\\lambda\\)), which represents the ratio of the maximum to the minimum thickness of the airfoil or the maximum to minimum chord.\nIt’s important to note that the equation used in this context is not a computer simulation but will be treated as one for the purpose of illustration. This approach involves employing a true mathematical equation, even if it’s considered unknown, as a useful tool for generating realistic settings to test the methodology. The functional form of this equation was derived by “calibrating” known physical relationships to curves obtained from existing aircraft data, as referenced in Raymer 2012. Essentially, it acts as a surrogate for actual measurements of aircraft weight.\nExamining the mathematical properties of the AWWE (Aircraft Weight With Wing Area and Fuel Weight Equation), it is evident that the response is highly nonlinear concerning its inputs. While it’s common to apply the logarithm to simplify equations with complex exponents, even when modeling the logarithm, which transforms powers into slope coefficients and products into sums, the response remains nonlinear due to the presence of trigonometric terms. Given the combination of nonlinearity and high input dimension, simple linear and quadratic response surface approximations are likely to be inadequate for this analysis."
  },
  {
    "objectID": "002_awwe.html#goals-understanding-and-optimization",
    "href": "002_awwe.html#goals-understanding-and-optimization",
    "title": "2  Aircraft Wing Weight Example",
    "section": "2.3 Goals: Understanding and Optimization",
    "text": "2.3 Goals: Understanding and Optimization\nThe primary goals of this study revolve around understanding and optimization:\n\nUnderstanding: One of the straightforward objectives is to gain a deep understanding of the input-output relationships in this context. Given the global perspective implied by this setting, it becomes evident that a more sophisticated model is almost necessary. At this stage, let’s focus on this specific scenario to establish a clear understanding.\nOptimization: Another application of this analysis could be optimization. There may be an interest in minimizing the weight of the aircraft, but it’s likely that there will be constraints in place. For example, the presence of wings with a nonzero area is essential for the aircraft to be capable of flying. In situations involving (constrained) optimization, a global perspective and, consequently, the use of flexible modeling are vital.\n\nThe provided Python code serves as a genuine computer implementation that “solves” a mathematical model. It accepts arguments encoded in the unit cube, with defaults used to represent baseline settings, as detailed in the table labeled as Table 2.1. To map values from the interval \\([a, b]\\) to the interval \\([0, 1]\\), the following formula can be employed:\n\\[y = f(x) = \\frac{x - a}{b - a}.\\]\nTo reverse this mapping and obtain the original values, the formula \\[g(y) = a + (b - a) y\\] can be used.\n\nimport numpy as np\n\ndef wingwt(Sw=0.48, Wfw=0.4, A=0.38, L=0.5, q=0.62, l=0.344,  Rtc=0.4, Nz=0.37, Wdg=0.38):\n    # put coded inputs back on natural scale\n    Sw = Sw * (200 - 150) + 150 \n    Wfw = Wfw * (300 - 220) + 220 \n    A = A * (10 - 6) + 6 \n    L = (L * (10 - (-10)) - 10) * np.pi/180\n    q = q * (45 - 16) + 16 \n    l = l * (1 - 0.5) + 0.5  \n    Rtc = Rtc * (0.18 - 0.08) + 0.08\n    Nz = Nz * (6 - 2.5) + 2.5\n    Wdg = Wdg*(2500 - 1700) + 1700\n    # calculation on natural scale\n    W = 0.036 * Sw**0.758 * Wfw**0.0035 * (A/np.cos(L)**2)**0.6 * q**0.006 \n    W = W * l**0.04 * (100*Rtc/np.cos(L))**(-0.3) * (Nz*Wdg)**(0.49)\n    return(W)"
  },
  {
    "objectID": "002_awwe.html#properties-of-the-python-solver",
    "href": "002_awwe.html#properties-of-the-python-solver",
    "title": "2  Aircraft Wing Weight Example",
    "section": "2.4 Properties of the Python “Solver”",
    "text": "2.4 Properties of the Python “Solver”\nThe compute time required by the “wingwt” solver is extremely short and can be considered trivial in terms of computational resources. The approximation error is exceptionally small, effectively approaching machine precision, which indicates the high accuracy of the solver’s results.\nTo simulate time-consuming evaluations, a deliberate delay is introduced by incorporating a sleep(3600) command, which effectively synthesizes a one-hour execution time for a particular evaluation.\nMoving on to the AWWE visualization, plotting in two dimensions is considerably simpler than dealing with nine dimensions. To aid in creating visual representations, the code provided below establishes a grid within the unit square to facilitate the generation of sliced visuals. This involves generating a “meshgrid” as outlined in the code.\n\nimport numpy as np\nx = np.linspace(0, 1, 3)\ny = np.linspace(0, 1, 3)\nX, Y = np.meshgrid(x, y)\nzp = zip(np.ravel(X), np.ravel(Y))\nlist(zp)\n\n[(0.0, 0.0),\n (0.5, 0.0),\n (1.0, 0.0),\n (0.0, 0.5),\n (0.5, 0.5),\n (1.0, 0.5),\n (0.0, 1.0),\n (0.5, 1.0),\n (1.0, 1.0)]\n\n\nThe coding used to transform inputs from natural units is largely a matter of taste, so long as it’s easy to undo for reporting back on original scales\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\n# plt.style.use('seaborn-white')\nimport numpy as np\nx = np.linspace(0, 1, 100)\ny = np.linspace(0, 1, 100)\nX, Y = np.meshgrid(x, y)"
  },
  {
    "objectID": "002_awwe.html#plot-1-load-factor-n_z-and-aspect-ratio-a",
    "href": "002_awwe.html#plot-1-load-factor-n_z-and-aspect-ratio-a",
    "title": "2  Aircraft Wing Weight Example",
    "section": "2.5 Plot 1: Load Factor (\\(N_z\\)) and Aspect Ratio (\\(A\\))",
    "text": "2.5 Plot 1: Load Factor (\\(N_z\\)) and Aspect Ratio (\\(A\\))\nWe will vary \\(N_z\\) and \\(A\\), with other inputs fixed at their baseline values.\n\nz = wingwt(A = X, Nz = Y)\nfig = plt.figure(figsize=(7., 5.))\nplt.contourf(X, Y, z, 20, cmap='jet')\nplt.xlabel(\"A\")\nplt.ylabel(\"Nz\")\nplt.title(\"Load factor (Nz) vs. Aspect Ratio (A)\")\nplt.colorbar()\nplt.show()\n\n\n\n\nContour plots can be refined, e.g., by adding explicit contour lines as shown in the following figure.\n\ncontours = plt.contour(X, Y, z, 4, colors='black')\nplt.clabel(contours, inline=True, fontsize=8)\nplt.xlabel(\"A\")\nplt.ylabel(\"Nz\")\n\nplt.imshow(z, extent=[0, 1, 0, 1], origin='lower',\n           cmap='jet', alpha=0.9)\nplt.colorbar()\n\n&lt;matplotlib.colorbar.Colorbar at 0x169bb2f10&gt;\n\n\n\n\n\nThe interpretation of the AWWE plot can be summarized as follows:\n\nThe figure displays the weight response as a function of two variables, \\(N_z\\) and \\(A\\), using an image-contour plot.\nThe slight curvature observed in the contours suggests an interaction between these two variables.\nNotably, the range of outputs depicted in the figure, spanning from approximately 160 to 320, nearly encompasses the entire range of outputs observed from various input settings within the full 9-dimensional input space.\nThe plot indicates that aircraft wings tend to be heavier when the aspect ratios (\\(A\\)) are high.\nThis observation aligns with the idea that wings are designed to withstand and accommodate high gravitational forces (\\(g\\)-forces, large \\(N_z\\)), and there may be a compounding effect where larger values of \\(N_z\\) contribute to increased wing weight.\nIt’s plausible that this phenomenon is related to the design considerations of fighter jets, which cannot have the efficient and lightweight glider-like wings typically found in other types of aircraft."
  },
  {
    "objectID": "002_awwe.html#plot-2-taper-ratio-and-fuel-weight",
    "href": "002_awwe.html#plot-2-taper-ratio-and-fuel-weight",
    "title": "2  Aircraft Wing Weight Example",
    "section": "2.6 Plot 2: Taper Ratio and Fuel Weight",
    "text": "2.6 Plot 2: Taper Ratio and Fuel Weight\n\nThe same experiment for two other inputs, e.g., taper ratio \\(\\lambda\\) and fuel weight \\(W_{fw}\\)\n\n\nz = wingwt(Wfw = X,  Nz = Y)\ncontours = plt.contour(X, Y, z, 4, colors='black')\nplt.clabel(contours, inline=True, fontsize=8)\nplt.xlabel(\"WfW\")\nplt.ylabel(\"l\")\n\nplt.imshow(z, extent=[0, 1, 0, 1], origin='lower',\n           cmap='jet', alpha=0.9)\nplt.colorbar();\n\n\n\n\n\nInterpretation of Taper Ratio (\\(l\\)) and Fuel Weight (\\(W_{fw}\\))\n\nApparently, neither input has much effect on wing weight:\n\nwith \\(\\lambda\\) having a marginally greater effect, covering less than 4 percent of the span of weights observed in the \\(A \\times N_z\\) plane\n\nThere’s no interaction evident in \\(\\lambda \\times W_{fw}\\)"
  },
  {
    "objectID": "002_awwe.html#the-big-picture-combining-all-variables",
    "href": "002_awwe.html#the-big-picture-combining-all-variables",
    "title": "2  Aircraft Wing Weight Example",
    "section": "2.7 The Big Picture: Combining all Variables",
    "text": "2.7 The Big Picture: Combining all Variables\n\npl = [\"Sw\", \"Wfw\", \"A\", \"L\", \"q\", \"l\",  \"Rtc\", \"Nz\", \"Wdg\"]\n\n\nimport math\n\nZ = []\nZlab = []\nl = len(pl)\n# lc = math.comb(l,2)\nfor i in range(l):\n    for j in range(i+1, l):\n    # for j in range(l):\n        # print(pl[i], pl[j])\n        d = {pl[i]: X, pl[j]: Y}\n        Z.append(wingwt(**d))\n        Zlab.append([pl[i],pl[j]])\n\nNow we can generate all 36 combinations, e.g., our first example is combination p = 19.\n\np = 19\nZlab[p]\n\n['A', 'Nz']\n\n\nTo help interpret outputs from experiments such as this one—to level the playing field when comparing outputs from other pairs of inputs—code below sets up a color palette that can be re-used from one experiment to the next. We use the arguments vmin=180 and vmax =360 to implement comparibility\n\nplt.contourf(X, Y, Z[p], 20, cmap='jet', vmin=180, vmax=360)\nplt.xlabel(Zlab[p][0])\nplt.ylabel(Zlab[p][1])\nplt.colorbar()\n\n&lt;matplotlib.colorbar.Colorbar at 0x169bdb790&gt;\n\n\n\n\n\n\nLet’s plot the second example, taper ratio \\(\\lambda\\) and fuel weight \\(W_{fw}\\)\nThis is combination 11:\n\n\np = 11\nZlab[p]\n\n['Wfw', 'l']\n\n\n\nplt.contourf(X, Y, Z[p], 20, cmap='jet', vmin=180, vmax=360)\nplt.xlabel(Zlab[p][0])\nplt.ylabel(Zlab[p][1])\nplt.colorbar()\n\n&lt;matplotlib.colorbar.Colorbar at 0x169dbfa90&gt;\n\n\n\n\n\n\nUsing a global colormap indicates that these variables have minor effects on the wing weight.\nImportant factors can be detected by visual inspection\nPlotting the Big Picture: we can plot all 36 combinations in one figure.\n\n\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import ImageGrid\nimport numpy as np\n\nfig = plt.figure(figsize=(20., 20.))\ngrid = ImageGrid(fig, 111,  # similar to subplot(111)\n                 nrows_ncols=(6,6),  # creates 2x2 grid of axes\n                 axes_pad=0.5,  # pad between axes in inch.\n                 share_all=True,\n                 label_mode=\"0\",\n                 ) \ni = 0\nfor ax, im in zip(grid, Z):\n    # Iterating over the grid returns the Axes.\n    ax.set_xlabel(Zlab[i][0])\n    ax.set_ylabel(Zlab[i][1])\n    # ax.set_title(Zlab[i][1] + \" vs. \" + Zlab[i][0])\n    ax.contourf(X, Y, im, 30, cmap = \"jet\",  vmin = 180, vmax = 360)\n    i = i + 1\n       \nplt.show()"
  },
  {
    "objectID": "002_awwe.html#awwe-landscape",
    "href": "002_awwe.html#awwe-landscape",
    "title": "2  Aircraft Wing Weight Example",
    "section": "2.8 AWWE Landscape",
    "text": "2.8 AWWE Landscape\n\nOur Observations\n\nThe load factor \\(N_z\\), which determines the magnitude of the maximum aerodynamic load on the wing, is very active and involved in interactions with other variables.\n\n\nClassic example: the interaction of \\(N_z\\) with the aspect ratio \\(A\\) indicates a heavy wing for high aspect ratios and large \\(g\\)-forces\nThis is the reaon why highly manoeuvrable fighter jets cannot have very efficient, glider wings)\n\n\nAspect ratio \\(A\\) and airfoil thickness to chord ratio \\(R_{tc}\\) have nonlinear interactions.\nMost important variables:\n\n\nUltimate load factor \\(N_z\\), wing area \\(S_w\\), and flight design gross weight\\(W_{dg}\\).\n\n\nLittle impact: dynamic pressure \\(q\\), taper ratio \\(l\\), and quarter-chord sweep \\(L\\).\n\nExpert Knowledge\n\nAircraft designers know that the overall weight of the aircraft and the wing area must be kept to a minimum\nthe latter usually dictated by constraints such as required stall speed, landing distance, turn rate, etc."
  },
  {
    "objectID": "002_awwe.html#summary-of-the-first-experiments",
    "href": "002_awwe.html#summary-of-the-first-experiments",
    "title": "2  Aircraft Wing Weight Example",
    "section": "2.9 Summary of the First Experiments",
    "text": "2.9 Summary of the First Experiments\n\nFirst, we considered two pairs of inputs, out of 36 total pairs\nThen, the “Big Picture”:\n\nFor each pair we evaluated wingwt 10,000 times\n\nDoing the same for all pairs would require 360K evaluations:\n\nnot a reasonable number with a real computer simulation that takes any non-trivial amount of time to evaluate\nOnly 1s per evaluation: \\(&gt;100\\) hours\n\nMany solvers take minutes/hours/days to execute a single run\nAnd: three-way interactions?\nConsequence: a different strategy is needed"
  },
  {
    "objectID": "002_awwe.html#exercise",
    "href": "002_awwe.html#exercise",
    "title": "2  Aircraft Wing Weight Example",
    "section": "2.10 Exercise",
    "text": "2.10 Exercise\n\n2.10.1 Adding Paint Weight\n\nPaint weight is not considered.\nAdd Paint Weight \\(W_p\\) to formula (the updated formula is shown below) and update the functions and plots in the notebook.\n\n\\[ W = 0.036S_W^{0.758} \\times W_{fw}^{0.0035} \\times \\left( \\frac{A}{\\cos^2 \\Lambda} \\right)^{0.6} \\times q^{0.006} \\times \\lambda^{0.04} \\] \\[ \\times \\left( \\frac{100 R_{tc}}{\\cos \\Lambda} \\right)^{-0.3} \\times (N_z W_{dg})^{0.49} + S_w W_p\\]"
  },
  {
    "objectID": "300_evolutionary_optimization.html#introduction",
    "href": "300_evolutionary_optimization.html#introduction",
    "title": "3  Evolutionary Optimization",
    "section": "3.1 Introduction",
    "text": "3.1 Introduction"
  },
  {
    "objectID": "300_evolutionary_optimization.html#differential-evolution",
    "href": "300_evolutionary_optimization.html#differential-evolution",
    "title": "3  Evolutionary Optimization",
    "section": "3.2 Differential Evolution",
    "text": "3.2 Differential Evolution"
  },
  {
    "objectID": "300_evolutionary_optimization.html#genetic-algorithms",
    "href": "300_evolutionary_optimization.html#genetic-algorithms",
    "title": "3  Evolutionary Optimization",
    "section": "3.3 Genetic Algorithms",
    "text": "3.3 Genetic Algorithms"
  },
  {
    "objectID": "300_evolutionary_optimization.html#evolution-strategies",
    "href": "300_evolutionary_optimization.html#evolution-strategies",
    "title": "3  Evolutionary Optimization",
    "section": "3.4 Evolution Strategies",
    "text": "3.4 Evolution Strategies"
  },
  {
    "objectID": "00000_optimization_surrogate.html#surrogates",
    "href": "00000_optimization_surrogate.html#surrogates",
    "title": "1  Introduction: Optimization",
    "section": "1.2 Surrogates",
    "text": "1.2 Surrogates\n\nGathering data is expensive, and sometimes getting exactly the data you want is impossible or unethical\nSurrogate: substitute for the real thing\nIn statistics, draws from predictive equations derived from a fitted model can act as a surrogate for the data-generating mechanism\nBenefits of the surrogate approach:\n\nSurrogate could represent a cheaper way to explore relationships, and entertain “what ifs?”\nSurrogates favor faithful yet pragmatic reproduction of dynamics:\n\ninterpretation,\nestablishing causality, or\nidentification\n\nMany numerical simulators are deterministic, whereas field observations are noisy or have measurement error\n\n\n\n1.2.1 Costs of Simulation\n\nComputer simulations are generally cheaper (but not always!) than physical observation\nSome computer simulations can be just as expensive as field experimentation, but computer modeling is regarded as easier because:\n\nthe experimental apparatus is better understood\nmore aspects may be controlled.\n\n\n\n\n1.2.2 Mathematical Models and Meta-Models\n\nUse of mathematical models leveraging numerical solvers has been commonplace for some time\nMathematical models became more complex, requiring more resources to simulate/solve numerically\nPractitioners increasingly relied on meta-models built off of limited simulation campaigns\n\n\n\n1.2.3 Surrogates = Trained Meta-models\n\nData collected via expensive computer evaluations tuned flexible functional forms that could be used in lieu of further simulation to\n\nsave money or computational resources;\ncope with an inability to perform future runs (expired licenses, off-line or over-impacted supercomputers)\n\nTrained meta-models became known as surrogates\n\n\n\n1.2.4 Computer Experiments\n\nComputer experiment: design, running, and fitting meta-models.\n\nLike an ordinary statistical experiment, except the data are generated by computer codes rather than physical or field observations, or surveys\n\nSurrogate modeling is statistical modeling of computer experiments\n\n\n\n1.2.5 Limits of Mathematical Modeling\n\nMathematical biologists, economists and others had reached the limit of equilibrium-based mathematical modeling with cute closed-form solutions\nStochastic simulations replace deterministic solvers based on FEM, Navier–Stokes or Euler methods\nAgent-based simulation models are used to explore predator-prey (Lotka–Voltera) dynamics, spread of disease, management of inventory or patients in health insurance markets\nConsequence: the distinction between surrogate and statistical model is all but gone\n\n\n\n1.2.6 Example: Why Computer Simulations are Necessary\n\nYou can’t seed a real community with Ebola and watch what happens\nIf there’s (real) field data, say on a historical epidemic, further experimentation may be almost entirely limited to the mathematical and computer modeling side\nClassical statistical methods offer little guidance\n\n\n\n1.2.7 Simulation Requirements\n\nSimulation should\n\nenable rich diagnostics to help criticize that models\nunderstanding its sensitivity to inputs and other configurations\nproviding the ability to optimize and\nrefine both automatically and with expert intervention\n\nAnd it has to do all that while remaining computationally tractable\nOne perspective is so-called response surface methods (RSMs):\na poster child from industrial statistics’ heyday, well before information technology became a dominant industry\n\n\n\n\n\n\n\nGoals\n\n\n\n\nHow to choose models and optimizers for solving real-world problems\nHow to use simulation to understand and improve processes"
  },
  {
    "objectID": "003_optimization_gp.html#dace-and-rsm",
    "href": "003_optimization_gp.html#dace-and-rsm",
    "title": "7  Kriging (Gaussian Process Regression)",
    "section": "7.1 DACE and RSM",
    "text": "7.1 DACE and RSM\nMathematical models implemented in computer codes are used to circumvent the need for expensive field data collection. These models are particularly useful when dealing with highly nonlinear response surfaces, high signal-to-noise ratios (which often involve deterministic evaluations), and a global scope. As a result, a new approach is required in comparison to Response Surface Methodology (RSM).\nWith the improvement in computing power and simulation fidelity, researchers gain higher confidence and a better understanding of the dynamics in physical, biological, and social systems. However, the expansion of configuration spaces and increasing input dimensions necessitates more extensive designs. High-performance computing (HPC) allows for thousands of runs, whereas previously only tens were possible. This shift towards larger models and training data presents new computational challenges.\nResearch questions for DACE (Design and Analysis of Computer Experiments) include how to design computer experiments that make efficient use of computation and how to meta-model computer codes to save on simulation effort. The choice of surrogate model for computer codes significantly impacts the optimal experiment design, and the preferred model-design pairs can vary depending on the specific goal.\nThe combination of computer simulation, design, and modeling with field data from similar real-world experiments introduces a new category of computer model tuning problems. The ultimate goal is to automate these processes to the greatest extent possible, allowing for the deployment of HPC with minimal human intervention.\nOne of the remaining differences between RSM and DACE lies in how they handle noise. DACE employs replication, a technique that would not be used in a deterministic setting, to separate signal from noise. Traditional RSM is best suited for situations where a substantial proportion of the variability in the data is due to noise, and where the acquisition of data values can be severely limited. Consequently, RSM is better suited for a different class of problems, aligning with its intended purposes.\n\n7.1.1 DACE Literature\n\nTwo very good texts on computer experiments and surrogate modeling:\n\nThe Design and Analysis of Computer Experiments, by Santner, Williams, and Notz (2018) is the canonical reference in the statistics literature\nEngineering Design via Surrogate Modeling by Forrester, Sobester, and Keane (2008) is perhaps more popular in engineering\n\n\nWe will analyze an example from the latter."
  },
  {
    "objectID": "06_spot_sklearn_gaussian.html#gaussian-processes-regression-basic-introductory-scikit-learn-example",
    "href": "06_spot_sklearn_gaussian.html#gaussian-processes-regression-basic-introductory-scikit-learn-example",
    "title": "12  Sequential Parameter Optimization: Gaussian Process Models",
    "section": "12.1 Gaussian Processes Regression: Basic Introductory scikit-learn Example",
    "text": "12.1 Gaussian Processes Regression: Basic Introductory scikit-learn Example\n\nThis is the example from scikit-learn: https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html\nAfter fitting our model, we see that the hyperparameters of the kernel have been optimized.\nNow, we will use our kernel to compute the mean prediction of the full dataset and plot the 95% confidence interval.\n\n\n12.1.1 Train and Test Data\n\nX = np.linspace(start=0, stop=10, num=1_000).reshape(-1, 1)\ny = np.squeeze(X * np.sin(X))\nrng = np.random.RandomState(1)\ntraining_indices = rng.choice(np.arange(y.size), size=6, replace=False)\nX_train, y_train = X[training_indices], y[training_indices]\n\n\n\n12.1.2 Building the Surrogate With Sklearn\n\nThe model building with sklearn consisits of three steps:\n\nInstantiating the model, then\nfitting the model (using fit), and\nmaking predictions (using predict)\n\n\n\nkernel = 1 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2))\ngaussian_process = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)\ngaussian_process.fit(X_train, y_train)\nmean_prediction, std_prediction = gaussian_process.predict(X, return_std=True)\n\n\n\n12.1.3 Plotting the SklearnModel\n\nplt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, mean_prediction, label=\"Mean prediction\")\nplt.fill_between(\n    X.ravel(),\n    mean_prediction - 1.96 * std_prediction,\n    mean_prediction + 1.96 * std_prediction,\n    alpha=0.5,\n    label=r\"95% confidence interval\",\n)\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"sk-learn Version: Gaussian process regression on noise-free dataset\")\n\n\n\n\n\n\n12.1.4 The spotPython Version\n\nThe spotPython version is very similar:\n\nInstantiating the model, then\nfitting the model and\nmaking predictions (using predict).\n\n\n\nS = Kriging(name='kriging',  seed=123, log_level=50, cod_type=\"norm\")\nS.fit(X_train, y_train)\nS_mean_prediction, S_std_prediction, S_ei = S.predict(X, return_val=\"all\")\n\n\nplt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, S_mean_prediction, label=\"Mean prediction\")\nplt.fill_between(\n    X.ravel(),\n    S_mean_prediction - 1.96 * S_std_prediction,\n    S_mean_prediction + 1.96 * S_std_prediction,\n    alpha=0.5,\n    label=r\"95% confidence interval\",\n)\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"spotPython Version: Gaussian process regression on noise-free dataset\")\n\n\n\n\n\n\n12.1.5 Visualizing the Differences Between the spotPython and the sklearn Model Fits\n\nplt.plot(X, y, label=r\"$f(x) = x \\sin(x)$\", linestyle=\"dotted\")\nplt.scatter(X_train, y_train, label=\"Observations\")\nplt.plot(X, S_mean_prediction, label=\"spotPython Mean prediction\")\nplt.plot(X, mean_prediction, label=\"Sklearn Mean Prediction\")\nplt.legend()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$f(x)$\")\n_ = plt.title(\"Comparing Mean Predictions\")"
  },
  {
    "objectID": "06_spot_sklearn_gaussian.html#exercises",
    "href": "06_spot_sklearn_gaussian.html#exercises",
    "title": "12  Sequential Parameter Optimization: Gaussian Process Models",
    "section": "12.2 Exercises",
    "text": "12.2 Exercises\n\n12.2.1 Schonlau Example Function\n\nThe Schonlau Example Function is based on sample points only (there is no analytical function description available):\n\n\nX = np.linspace(start=0, stop=13, num=1_000).reshape(-1, 1)\nX_train = np.array([1., 2., 3., 4., 12.]).reshape(-1,1)\ny_train = np.array([0., -1.75, -2, -0.5, 5.])\n\n\nDescribe the function.\nCompare the two models that were build using the spotPython and the sklearn surrogate.\nNote: Since there is no analytical function available, you might be interested in adding some points and describe the effects.\n\n\n\n12.2.2 Forrester Example Function\n\nThe Forrester Example Function is defined as follows:\nf(x) = (6x- 2)^2 sin(12x-4) for x in [0,1].\nData points are generated as follows:\n\n\nX = np.linspace(start=-0.5, stop=1.5, num=1_000).reshape(-1, 1)\nX_train = np.array([0.0, 0.175, 0.225, 0.3, 0.35, 0.375, 0.5,1]).reshape(-1,1)\nfun = analytical().fun_forrester\nfun_control = {\"sigma\": 0.1,\n               \"seed\": 123}\ny = fun(X, fun_control=fun_control)\ny_train = fun(X_train, fun_control=fun_control)\n\n\nDescribe the function.\nCompare the two models that were build using the spotPython and the sklearn surrogate.\nNote: Modify the noise level (\"sigma\"), e.g., use a value of 0.2, and compare the two models.\n\n\nfun_control = {\"sigma\": 0.2}\n\n\n\n12.2.3 fun_runge Function (1-dim)\n\nThe Runge function is defined as follows:\nf(x) = 1/ (1 + sum(x_i))^2\nData points are generated as follows:\n\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_runge\nfun_control = {\"sigma\": 0.025,\n               \"seed\": 123}\nX_train = gen.scipy_lhd(10, lower=lower, upper = upper).reshape(-1,1)\ny_train = fun(X, fun_control=fun_control)\nX = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\ny = fun(X, fun_control=fun_control)\n\n\nDescribe the function.\nCompare the two models that were build using the spotPython and the sklearn surrogate.\nNote: Modify the noise level (\"sigma\"), e.g., use a value of 0.05, and compare the two models.\n\n\nfun_control = {\"sigma\": 0.5}\n\n\n\n12.2.4 fun_cubed (1-dim)\n\nThe Cubed function is defined as follows:\nnp.sum(X[i]** 3)\nData points are generated as follows:\n\n\ngen = spacefilling(1)\nrng = np.random.RandomState(1)\nlower = np.array([-10])\nupper = np.array([10])\nfun = analytical().fun_cubed\nfun_control = {\"sigma\": 0.025,\n               \"seed\": 123}\nX_train = gen.scipy_lhd(10, lower=lower, upper = upper).reshape(-1,1)\ny_train = fun(X, fun_control=fun_control)\nX = np.linspace(start=-13, stop=13, num=1000).reshape(-1, 1)\ny = fun(X, fun_control=fun_control)\n\n\nDescribe the function.\nCompare the two models that were build using the spotPython and the sklearn surrogate.\nNote: Modify the noise level (\"sigma\"), e.g., use a value of 0.05, and compare the two models.\n\n\nfun_control = {\"sigma\": 0.05}\n\n\n\n12.2.5 The Effect of Noise\nHow does the behavior of the spotPython fit changes when the argument noise is set to True, i.e.,\nS = Kriging(name='kriging',  seed=123, n_theta=1, noise=True)\nis used?"
  },
  {
    "objectID": "001_optimization_rsm.html#response-surface-methods-what-is-rsm",
    "href": "001_optimization_rsm.html#response-surface-methods-what-is-rsm",
    "title": "5  Introduction: Numerical Methods",
    "section": "5.1 Response Surface Methods: What is RSM?",
    "text": "5.1 Response Surface Methods: What is RSM?\nResponse Surface Methods (RSM) refer to a collection of statistical and mathematical tools that are valuable for developing, improving, and optimizing processes. The overarching theme of RSM involves studying how input variables that control a product or process can potentially influence a response that measures performance or quality characteristics.\nThe advantages of RSM include a rich literature, well-established methods often used in manufacturing, the importance of careful experimental design combined with a well-understood model, and the potential to add significant value to scientific inquiry, process refinement, optimization, and more. However, there are also drawbacks to RSM, such as the use of simple and crude surrogates, the hands-on nature of the methods, and the limitation of local methods.\nRSM is related to various fields, including Design of Experiments (DoE), quality management, reliability, and productivity. Its applications are widespread in industry and manufacturing, focusing on designing, developing, and formulating new products and improving existing ones, as well as from laboratory research. RSM is commonly applied in domains such as materials science, manufacturing, applied chemistry, climate science, and many others.\nAn example of RSM involves studying the relationship between a response variable, such as yield (\\(y\\)) in a chemical process, and two process variables: reaction time (\\(\\xi_1\\)) and reaction temperature (\\(\\xi_2\\)). The provided code illustrates this scenario, following a variation of the so-called “banana function.”\nIn the context of visualization, RSM offers the choice between 3D plots and contour plots. In a 3D plot, the independent variables \\(\\xi_1\\) and \\(\\xi_2\\) are represented, with \\(y\\) as the dependent variable.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef fun_rosen(x1, x2):\n    b = 10\n    return (x1-1)**2 + b*(x2-x1**2)**2\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nx = np.arange(-2.0, 2.0, 0.05)\ny = np.arange(-1.0, 3.0, 0.05)\nX, Y = np.meshgrid(x, y)\nzs = np.array(fun_rosen(np.ravel(X), np.ravel(Y)))\nZ = zs.reshape(X.shape)\n\nax.plot_surface(X, Y, Z)\n\nax.set_xlabel('X1')\nax.set_ylabel('X2')\nax.set_zlabel('Y')\n\nplt.show()\n\n\n\n\n\ncontour plot example:\n\n\\(x_1\\) and \\(x_2\\) are the independent variables\n\\(y\\) is the dependent variable\n\n\n\nimport numpy as np\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\n\ndelta = 0.025\nx1 = np.arange(-2.0, 2.0, delta)\nx2 = np.arange(-1.0, 3.0, delta)\nX1, X2 = np.meshgrid(x1, x2)\nY = fun_rosen(X1, X2)\nfig, ax = plt.subplots()\nCS = ax.contour(X1, X2, Y , 50)\nax.clabel(CS, inline=True, fontsize=10)\nax.set_title(\"Rosenbrock's Banana Function\")\n\nText(0.5, 1.0, \"Rosenbrock's Banana Function\")\n\n\n\n\n\n\nVisual inspection: yield is optimized near \\((\\xi_1. \\xi_2)\\)\n\n\n5.1.1 Visualization: Problems in Practice\n\nTrue response surface is unknown in practice\nWhen yield evaluation is not as simple as a toy banana function, but a process requiring care to monitor, reconfigure and run, it’s far too expensive to observe over a dense grid\nAnd, measuring yield may be a noisy/inexact process\nThat’s where stats (RSM) comes in\n\n\n\n5.1.2 RSM: Strategies\n\nRSMs consist of experimental strategies for\nexploring the space of the process (i.e., independent/input) variables (above \\(\\xi_1\\) and \\(\\xi2)\\)\nempirical statistical modeling targeted toward development of an appropriate approximating relationship between the response (yield) and process variables local to a study region of interest\noptimization methods for sequential refinement in search of the levels or values of process variables that produce desirable responses (e.g., that maximize yield or explain variation)\nRSM used for fitting an Empirical Model\nTrue response surface driven by an unknown physical mechanism\nObservations corrupted by noise\nHelpful: fit an empirical model to output collected under different process configurations\nConsider response \\(Y\\) that depends on controllable input variables \\(\\xi_1, \\xi_2, \\ldots, \\xi_m\\)\nRSM: Equations of the Empirical Model\n\n\\(Y=f(\\xi_1, \\xi_2, \\ldots, \\xi_m) + \\epsilon\\)\n\\(\\mathbb{E}\\{Y\\} = \\eta = f(\\xi1_1, \\xi_2, \\ldots, \\xi_m)\\)\n\\(\\epsilon\\) is treated as zero mean idiosyncratic noise possibly representing\n\ninherent variation, or\nthe effect of other systems or\nvariables not under our purview at this time\n\n\n\n\n\n5.1.3 RSM: Noise in the Empirical Model\n\nTypical simplifying assumption: \\(\\epsilon \\sim N(0,\\sigma^2)\\)\nWe seek estimates for \\(f\\) and \\(\\sigma^2\\) from noisy observations \\(Y\\) at inputs \\(\\xi\\)\n\n\n\n5.1.4 RSM: Natural and Coded Variables\n\nInputs \\(\\xi_1, \\xi_2, \\ldots, \\xi_m\\) called natural variables:\n\nexpressed in natural units of measurement, e.g., degrees Celsius, pounds per square inch (psi), etc.\n\nTransformed to coded variables \\(x_1, x_2, \\ldots, x_m\\):\n\nto mitigate hassles and confusion that can arise when working with a multitude of scales of measurement\n\nTypical Transformations offering dimensionless inputs \\(x_1, x_2, \\ldots, x_m\\)\n\nin the unit cube, or\nscaled to have a mean of zero and standard deviation of one, are common choices.\n\nEmpirical model becomes \\(\\eta = f(x_1, x_2, \\ldots, x_m)\\)\n\n\n\n5.1.5 RSM Low-order Polynomials\n\nLow-order polynomial make the following simplifying Assumptions\n\nLearning about \\(f\\) is lots easier if we make some simplifying approximations\nAppealing to Taylor’s theorem, a low-order polynomial in a small, localized region of the input (\\(x\\)) space is one way forward\nClassical RSM:\n\ndisciplined application of local analysis and\nsequential refinement of locality through conservative extrapolation\n\nInherently a hands-on process"
  },
  {
    "objectID": "00000_optimization_surrogate.html#optimization-simulation-and-surrogate-modeling",
    "href": "00000_optimization_surrogate.html#optimization-simulation-and-surrogate-modeling",
    "title": "1  Introduction: Optimization",
    "section": "1.1 Optimization, Simulation, and Surrogate Modeling",
    "text": "1.1 Optimization, Simulation, and Surrogate Modeling\n\nWe will consider the interplay between\n\nmathematical models,\nnumerical approximation,\nsimulation,\ncomputer experiments, and\nfield data\n\nExperimental design will play a key role in our developments, but not in the classical regression and response surface methodology sense\nChallenging real-data/real-simulation examples benefiting from modern surrogate modeling methodology\nWe will consider the classical, response surface methodology (RSM) approach, and then move on to more modern approaches\nAll approaches are based on surrogates"
  },
  {
    "objectID": "004_scipy_optimize_intro.html#nelder-mead-simplex-algorithm-methodnelder-mead",
    "href": "004_scipy_optimize_intro.html#nelder-mead-simplex-algorithm-methodnelder-mead",
    "title": "4  Introduction to scipy.optimize",
    "section": "4.2 Nelder-Mead Simplex algorithm (method='Nelder-Mead')",
    "text": "4.2 Nelder-Mead Simplex algorithm (method='Nelder-Mead')\nIn the example below, the minimize routine is used with the Nelder-Mead simplex algorithm (selected through the method parameter):\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef rosen(x):\n    \"\"\"The Rosenbrock function\"\"\"\n    return sum(100.0 * (x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0)\n\nx0 = np.array([1.3, 0.7, 0.8, 1.9, 1.2])\nres = minimize(rosen, x0, method='nelder-mead',\n               options={'xatol': 1e-8, 'disp': True})\n\nprint(res.x)\n\nOptimization terminated successfully.\n         Current function value: 0.000000\n         Iterations: 339\n         Function evaluations: 571\n[1. 1. 1. 1. 1.]\n\n\nThe simplex algorithm is probably the simplest way to minimize a well-behaved function. It requires only function evaluations and is a good choice for simple minimization problems. However, because it does not use any gradient evaluations, it may take longer to find the minimum.\nAnother optimization algorithm that needs only function calls to find the minimum is Powell’s method, which can be selected by setting the method parameter to 'powell' in the minimize function.\nTo demonstrate how to supply additional arguments to an objective function, let’s consider minimizing the Rosenbrock function with an additional scaling factor a and an offset b:\n\\[\nf(\\mathbf{x}, a, b) = \\sum_{i=1}^{N-1} a (x_{i+1} - x_i^2)^2 + (1 - x_i)^2 + b\n\\]\nYou can achieve this using the minimize routine with the example parameters a=0.5 and b=1:\n\ndef rosen_with_args(x, a, b):\n    \"\"\"The Rosenbrock function with additional arguments\"\"\"\n    return sum(a * (x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0) + b\n\nx0 = np.array([1.3, 0.7, 0.8, 1.9, 1.2])\nres = minimize(rosen_with_args, x0, method='nelder-mead',\n               args=(0.5, 1.), options={'xatol': 1e-8, 'disp': True})\n\nprint(res.x)\n\nOptimization terminated successfully.\n         Current function value: 1.000000\n         Iterations: 319\n         Function evaluations: 525\n[1.         1.         1.         1.         0.99999999]\n\n\nAs an alternative to using the args parameter of minimize, you can wrap the objective function in a new function that accepts only x. This approach is also useful when it is necessary to pass additional parameters to the objective function as keyword arguments.\n\ndef rosen_with_args(x, a, *, b):  # b is a keyword-only argument\n    return sum(a * (x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0) + b\n\ndef wrapped_rosen_without_args(x):\n    return rosen_with_args(x, 0.5, b=1.)  # pass in `a` and `b`\n\nx0 = np.array([1.3, 0.7, 0.8, 1.9, 1.2])\nres = minimize(wrapped_rosen_without_args, x0, method='nelder-mead',\n               options={'xatol': 1e-8,})\n\nprint(res.x)\n\n[1.         1.         1.         1.         0.99999999]\n\n\nAnother alternative is to use functools.partial.\n\nfrom functools import partial\n\npartial_rosen = partial(rosen_with_args, a=0.5, b=1.)\nres = minimize(partial_rosen, x0, method='nelder-mead',\n               options={'xatol': 1e-8,})\n\nprint(res.x)\n\n[1.         1.         1.         1.         0.99999999]"
  },
  {
    "objectID": "004_scipy_optimize_intro.html#unconstrained-minimization-of-multivariate-scalar-functions",
    "href": "004_scipy_optimize_intro.html#unconstrained-minimization-of-multivariate-scalar-functions",
    "title": "4  Introduction to scipy.optimize",
    "section": "4.1 Unconstrained minimization of multivariate scalar functions",
    "text": "4.1 Unconstrained minimization of multivariate scalar functions\nThe minimize function provides a common interface to unconstrained and constrained minimization algorithms for multivariate scalar functions in scipy.optimize. To demonstrate the minimization function, consider the problem of minimizing the Rosenbrock function of N variables:\n\\[\nf(\\mathbf{x}) = \\sum_{i=1}^{N-1} 100 (x_{i+1} - x_i^2)^2 + (1 - x_i)^2\n\\]\nThe minimum value of this function is 0, which is achieved when (x_i = 1).\nNote that the Rosenbrock function and its derivatives are included in scipy.optimize. The implementations shown in the following sections provide examples of how to define an objective function as well as its Jacobian and Hessian functions. Objective functions in scipy.optimize expect a numpy array as their first parameter, which is to be optimized and must return a float value. The exact calling signature must be f(x, *args), where x represents a numpy array, and args is a tuple of additional arguments supplied to the objective function."
  },
  {
    "objectID": "004_scipy_optimize_intro.html#nelder-mead-simplex-algorithm",
    "href": "004_scipy_optimize_intro.html#nelder-mead-simplex-algorithm",
    "title": "3  Introduction to scipy.optimize",
    "section": "3.1 Nelder-Mead Simplex Algorithm",
    "text": "3.1 Nelder-Mead Simplex Algorithm\nmethod='Nelder-Mead': In the example below, the minimize routine is used with the Nelder-Mead simplex algorithm (selected through the method parameter):\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef rosen(x):\n    \"\"\"The Rosenbrock function\"\"\"\n    return sum(100.0 * (x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0)\n\nx0 = np.array([1.3, 0.7, 0.8, 1.9, 1.2])\nres = minimize(rosen, x0, method='nelder-mead',\n               options={'xatol': 1e-8, 'disp': True})\n\nprint(res.x)\n\nOptimization terminated successfully.\n         Current function value: 0.000000\n         Iterations: 339\n         Function evaluations: 571\n[1. 1. 1. 1. 1.]\n\n\nThe simplex algorithm is probably the simplest way to minimize a well-behaved function. It requires only function evaluations and is a good choice for simple minimization problems. However, because it does not use any gradient evaluations, it may take longer to find the minimum."
  },
  {
    "objectID": "004_scipy_optimize_intro.html#powells-method",
    "href": "004_scipy_optimize_intro.html#powells-method",
    "title": "3  Introduction to scipy.optimize",
    "section": "3.2 Powell’s Method",
    "text": "3.2 Powell’s Method\nAnother optimization algorithm that needs only function calls to find the minimum is Powell’s method, which can be selected by setting the method parameter to 'powell' in the minimize function.\nTo demonstrate how to supply additional arguments to an objective function, let’s consider minimizing the Rosenbrock function with an additional scaling factor a and an offset b:\n\\[\nf(\\mathbf{x}, a, b) = \\sum_{i=1}^{N-1} a (x_{i+1} - x_i^2)^2 + (1 - x_i)^2 + b\n\\]\nYou can achieve this using the minimize routine with the example parameters a=0.5 and b=1:\n\ndef rosen_with_args(x, a, b):\n    \"\"\"The Rosenbrock function with additional arguments\"\"\"\n    return sum(a * (x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0) + b\n\nx0 = np.array([1.3, 0.7, 0.8, 1.9, 1.2])\nres = minimize(rosen_with_args, x0, method='nelder-mead',\n               args=(0.5, 1.), options={'xatol': 1e-8, 'disp': True})\n\nprint(res.x)\n\nOptimization terminated successfully.\n         Current function value: 1.000000\n         Iterations: 319\n         Function evaluations: 525\n[1.         1.         1.         1.         0.99999999]\n\n\nAs an alternative to using the args parameter of minimize, you can wrap the objective function in a new function that accepts only x. This approach is also useful when it is necessary to pass additional parameters to the objective function as keyword arguments.\n\ndef rosen_with_args(x, a, *, b):  # b is a keyword-only argument\n    return sum(a * (x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0) + b\n\ndef wrapped_rosen_without_args(x):\n    return rosen_with_args(x, 0.5, b=1.)  # pass in `a` and `b`\n\nx0 = np.array([1.3, 0.7, 0.8, 1.9, 1.2])\nres = minimize(wrapped_rosen_without_args, x0, method='nelder-mead',\n               options={'xatol': 1e-8,})\n\nprint(res.x)\n\n[1.         1.         1.         1.         0.99999999]\n\n\nAnother alternative is to use functools.partial.\n\nfrom functools import partial\n\npartial_rosen = partial(rosen_with_args, a=0.5, b=1.)\nres = minimize(partial_rosen, x0, method='nelder-mead',\n               options={'xatol': 1e-8,})\n\nprint(res.x)\n\n[1.         1.         1.         1.         0.99999999]"
  },
  {
    "objectID": "004_scipy_optimize_intro.html#broyden-fletcher-goldfarb-shanno-algorithm-bfgs",
    "href": "004_scipy_optimize_intro.html#broyden-fletcher-goldfarb-shanno-algorithm-bfgs",
    "title": "3  Introduction to scipy.optimize",
    "section": "3.3 Broyden-Fletcher-Goldfarb-Shanno Algorithm (BFGS)",
    "text": "3.3 Broyden-Fletcher-Goldfarb-Shanno Algorithm (BFGS)\nThe Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm (selected by setting method='BFGS') is an optimization algorithm that aims to converge quickly to the solution. This algorithm uses the gradient of the objective function. If the gradient is not provided by the user, it is estimated using first-differences. The BFGS method typically requires fewer function calls compared to the simplex algorithm, even when the gradient needs to be estimated.\n\n3.3.1 Using BFGS with the Rosenbrock Function\nTo demonstrate the BFGS algorithm, let’s use the Rosenbrock function again. The gradient of the Rosenbrock function is a vector described by the following mathematical expression:\n\\[\\begin{align}\n\\frac{\\partial f}{\\partial x_j} = \\sum_{i=1}^{N} 200(x_i - x_{i-1}^2)(\\delta_{i,j} - 2x_{i-1}\\delta_{i-1,j}) - 2(1 - x_{i-1})\\delta_{i-1,j} \\\\\n= 200(x_j - x_{j-1}^2) - 400x_j(x_{j+1} - x_j^2) - 2(1 - x_j)\n\\end{align}\\]\nThis expression is valid for interior derivatives, but special cases are:\n\\[\n\\frac{\\partial f}{\\partial x_0} = -400x_0(x_1 - x_0^2) - 2(1 - x_0)\n\\]\n\\[\n\\frac{\\partial f}{\\partial x_{N-1}} = 200(x_{N-1} - x_{N-2}^2)\n\\]\nHere’s a Python function that computes this gradient:\n\ndef rosen_der(x):\n    xm = x[1:-1]\n    xm_m1 = x[:-2]\n    xm_p1 = x[2:]\n    der = np.zeros_like(x)\n    der[1:-1] = 200*(xm-xm_m1**2) - 400*(xm_p1 - xm**2)*xm - 2*(1-xm)\n    der[0] = -400*x[0]*(x[1]-x[0]**2) - 2*(1-x[0])\n    der[-1] = 200*(x[-1]-x[-2]**2)\n    return der\n\nYou can specify this gradient information in the minimize function using the jac parameter as illustrated below:\n\nres = minimize(rosen, x0, method='BFGS', jac=rosen_der,\n               options={'disp': True})\n\nprint(res.x)\n\nOptimization terminated successfully.\n         Current function value: 0.000000\n         Iterations: 25\n         Function evaluations: 30\n         Gradient evaluations: 30\n[1.00000004 1.0000001  1.00000021 1.00000044 1.00000092]"
  },
  {
    "objectID": "004_scipy_optimize_intro.html#global-optimization",
    "href": "004_scipy_optimize_intro.html#global-optimization",
    "title": "3  Introduction to scipy.optimize",
    "section": "3.4 Global Optimization",
    "text": "3.4 Global Optimization\nGlobal optimization aims to find the global minimum of a function within given bounds, in the presence of potentially many local minima. Typically, global minimizers efficiently search the parameter space, while using a local minimizer (e.g., minimize) under the hood. SciPy contains a number of good global optimizers. Here, we’ll use those on the same objective function, namely the (aptly named) eggholder function:\n\ndef eggholder(x):\n    return (-(x[1] + 47) * np.sin(np.sqrt(abs(x[0]/2 + (x[1]  + 47))))\n            -x[0] * np.sin(np.sqrt(abs(x[0] - (x[1]  + 47)))))\n\nbounds = [(-512, 512), (-512, 512)]\n\n\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\nx = np.arange(-512, 513)\ny = np.arange(-512, 513)\nxgrid, ygrid = np.meshgrid(x, y)\nxy = np.stack([xgrid, ygrid])\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.view_init(45, -45)\nax.plot_surface(xgrid, ygrid, eggholder(xy), cmap='terrain')\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('eggholder(x, y)')\nplt.show()\n\n\n\n\nWe now use the global optimizers to obtain the minimum and the function value at the minimum. We’ll store the results in a dictionary so we can compare different optimization results later.\n\nfrom scipy import optimize\nresults = dict()\nresults['shgo'] = optimize.shgo(eggholder, bounds)\nresults['shgo']\n\n message: Optimization terminated successfully.\n success: True\n     fun: -935.3379515605789\n    funl: [-9.353e+02]\n       x: [ 4.395e+02  4.540e+02]\n      xl: [[ 4.395e+02  4.540e+02]]\n     nit: 1\n    nfev: 45\n   nlfev: 40\n   nljev: 10\n   nlhev: 0\n\n\n\nresults['DA'] = optimize.dual_annealing(eggholder, bounds)\nresults['DA']\n\n message: ['Maximum number of iteration reached']\n success: True\n  status: 0\n     fun: -935.3379515585161\n       x: [ 4.395e+02  4.540e+02]\n     nit: 1000\n    nfev: 4121\n    njev: 40\n    nhev: 0\n\n\nAll optimizers return an OptimizeResult, which in addition to the solution contains information on the number of function evaluations, whether the optimization was successful, and more. For brevity, we won’t show the full output of the other optimizers:\n\nresults['DE'] = optimize.differential_evolution(eggholder, bounds)\nresults['DE']\n\n message: Optimization terminated successfully.\n success: True\n     fun: -894.5789003904963\n       x: [-4.657e+02  3.857e+02]\n     nit: 13\n    nfev: 438\n     jac: [ 0.000e+00  0.000e+00]\n\n\nshgo has a second method, which returns all local minima rather than only what it thinks is the global minimum:\n\nresults['shgo_sobol'] = optimize.shgo(eggholder, bounds, n=200, iters=5,\n                                      sampling_method='sobol')\nresults['shgo_sobol']\n\n message: Optimization terminated successfully.\n success: True\n     fun: -959.640662720831\n    funl: [-9.596e+02 -9.353e+02 ... -6.591e+01 -6.387e+01]\n       x: [ 5.120e+02  4.042e+02]\n      xl: [[ 5.120e+02  4.042e+02]\n           [ 4.395e+02  4.540e+02]\n           ...\n           [ 3.165e+01 -8.523e+01]\n           [ 5.865e+01 -5.441e+01]]\n     nit: 5\n    nfev: 3529\n   nlfev: 2327\n   nljev: 634\n   nlhev: 0\n\n\nWe’ll now plot all found minima on a heatmap of the function:\n\nfig = plt.figure()\nax = fig.add_subplot(111)\nim = ax.imshow(eggholder(xy), interpolation='bilinear', origin='lower',\n               cmap='gray')\nax.set_xlabel('x')\nax.set_ylabel('y')\n\ndef plot_point(res, marker='o', color=None):\n    ax.plot(512+res.x[0], 512+res.x[1], marker=marker, color=color, ms=10)\n\nplot_point(results['DE'], color='c')  # differential_evolution - cyan\nplot_point(results['DA'], color='w')  # dual_annealing.        - white\n\n# SHGO produces multiple minima, plot them all (with a smaller marker size)\nplot_point(results['shgo'], color='r', marker='+')\nplot_point(results['shgo_sobol'], color='r', marker='x')\nfor i in range(results['shgo_sobol'].xl.shape[0]):\n    ax.plot(512 + results['shgo_sobol'].xl[i, 0],\n            512 + results['shgo_sobol'].xl[i, 1],\n            'ro', ms=2)\n\nax.set_xlim([-4, 514*2])\nax.set_ylim([-4, 514*2])\nplt.show()"
  },
  {
    "objectID": "004_scipy_optimize_intro.html#optimization-algorithms-in-detail",
    "href": "004_scipy_optimize_intro.html#optimization-algorithms-in-detail",
    "title": "3  Introduction to scipy.optimize",
    "section": "3.5 Optimization Algorithms in Detail",
    "text": "3.5 Optimization Algorithms in Detail\n\n3.5.1 dual_annealing\n\n\n3.5.2 Differential Evolution\n\n\n3.5.3 direct\n\n\n3.5.4 shgo\n\n\n3.5.5 basinhopping"
  },
  {
    "objectID": "9999_git_intro_en.html",
    "href": "9999_git_intro_en.html",
    "title": "Appendix B — Git Intro DE",
    "section": "",
    "text": "C Learning Objectives\nTo download changes from a GitLab repository to your local machine, you can use the git pull command. This command downloads the latest changes from the specified remote repository and merges them with your local repository.\nHere is an example:"
  },
  {
    "objectID": "9999_git_intro_en.html#initializing-a-repository-git-init",
    "href": "9999_git_intro_en.html#initializing-a-repository-git-init",
    "title": "Appendix B — Git Intro DE",
    "section": "D.1 Initializing a Repository: git init",
    "text": "D.1 Initializing a Repository: git init\nTo set up Git as a version control system for your project, you need to initialize a new Git repository at the top-level folder, which is the working directory of your project. This is done using the git init command.\nAll files in this folder and its subfolders will automatically become part of the repository. Creating a Git repository is similar to adding an all-powerful passive observer of all things to your project. Git sits there, observes, and takes note of even the smallest changes, such as a single character in a file within a repository with hundreds of files. And it will tell you where these changes occurred if you forget. Once Git is initialized, it monitors all changes made within the working directory, and it tracks the history of events from that point forward. For this purpose, a historical timeline is created for your project, referred to as a “branch,” and the initial branch is named main. So, when someone says they are on the main branch or working on the main branch, it means they are in the historical main timeline of the project. The Git repository, often abbreviated as repo, is a virtual representation of your project, including its history and branches, a book, if you will, where you can look up and retrieve the entire history of the project: you work in your working directory, and the Git repository tracks and stores your work."
  },
  {
    "objectID": "9999_git_intro_en.html#ignoring-files-.gitignore",
    "href": "9999_git_intro_en.html#ignoring-files-.gitignore",
    "title": "Appendix B — Git Intro DE",
    "section": "D.2 Ignoring Files: .gitignore",
    "text": "D.2 Ignoring Files: .gitignore\nIt’s useful that Git watches and keeps an eye on everything in your project. However, in most projects, there are files and folders that you don’t need or want to keep an eye on. These may include system files, local project settings, libraries with dependencies, and so on.\nYou can exclude any file or folder from your Git repository by including them in the .gitignore file. In the .gitignore file, you create a list of file names, folder names, and other items that Git should not track, and Git will ignore these items. Hence the name “gitignore.” Do you want to track a file that you previously ignored? Simply remove the mention of the file in the gitignore file, and Git will start tracking it again."
  },
  {
    "objectID": "9999_git_intro_en.html#adding-changes-to-the-staging-area-git-add",
    "href": "9999_git_intro_en.html#adding-changes-to-the-staging-area-git-add",
    "title": "Appendix B — Git Intro DE",
    "section": "D.3 Adding Changes to the Staging Area: git add",
    "text": "D.3 Adding Changes to the Staging Area: git add\nThe interesting thing about Git as an all-powerful, passive observer of all things is that it’s very passive. As long as you don’t tell Git what to remember, it will passively observe the changes in the project folder but do nothing.\nWhen you make a change to your project that you want Git to include in the project’s history to take a snapshot of so you can refer back to it later, your personal checkpoint, if you will, you need to first stage the changes in the staging area. What is the staging area? The staging area is where you collect changes to files that you want to include in the project’s history.\nThis is done using the git add command. You can specify which files you want to add by naming them, or you can add all of them using -A. By doing this, you’re telling Git that you’ve made changes and want it to remember these particular changes so you can recall them later if needed. This is important because you can choose which changes you want to stage, and those are the changes that will eventually be transferred to the history.\n\nNote: When you run git add, the changes are not transferred to the project’s history. They are only transferred to the staging area.\n\n\n\n\n\n\n\nNote\n\n\n\nExample of git add from the beginning:\n# Create a new directory for your\n# repository and navigate to that directory:\n\nmkdir my-repo\ncd my-repo\n\n# Initialize the repository with git init:\n\ngit init\n\n# Create a .gitignore file for Python code.\n# You can use a template from GitHub:\n\ncurl https://raw.githubusercontent.com/github/gitignore/master/Python.gitignore -o .gitignore\n\n# Add your files to the repository using git add:\n\ngit add .\nThis adds all files in the current directory to the repository, except for the files listed in the .gitignore file."
  },
  {
    "objectID": "9999_git_intro_en.html#transferring-changes-to-memory-git-commit",
    "href": "9999_git_intro_en.html#transferring-changes-to-memory-git-commit",
    "title": "Appendix B — Git Intro DE",
    "section": "D.4 Transferring Changes to Memory: git commit",
    "text": "D.4 Transferring Changes to Memory: git commit\nThe power of Git becomes evident when you start transferring changes to the project history. This is done using the git commit command. When you run git commit, you inform Git that the changes in the staging area should be added to the history of the project so that they can be referenced or retrieved later.\nAdditionally, you can add a commit message with the -m option to explain what changes were made. So when you look back at the project history, you can see that you added a new feature.\ngit commit creates a snapshot, an image of the current state of your project at that specific time, and adds it to the branch you are currently working on.\nAs you work on your project and transfer more snapshots, the branch grows and forms a timeline of events. This means you can now look back at every transfer in the branch and see what your code looked like at that time.\nYou can compare any phase of your code with any other phase of your code to find errors, restore deleted code, or do things that would otherwise not be possible, such as resetting the project to a previous state or creating a new timeline from any point.\nSo how often should you add these commits? My rule of thumb is not to commit too often. It’s better to have a Git repository with too many commits than one with too few commits.\n\n\n\n\n\n\nContinuing the example from above:\n\n\n\nAfter adding your files with git add, you can create a commit to save your changes. Use the git commit command with the -m option to specify your commit message:\ngit commit -m \"My first commit message\"\nThis creates a new commit with the added files and the specified commit message."
  },
  {
    "objectID": "9999_git_intro_en.html#check-the-status-of-your-repository-git-status",
    "href": "9999_git_intro_en.html#check-the-status-of-your-repository-git-status",
    "title": "Appendix B — Git Intro DE",
    "section": "D.5 Check the Status of Your Repository: git status",
    "text": "D.5 Check the Status of Your Repository: git status\nIf you’re wondering what you’ve changed in your project since the last commit snapshot, you can always check the Git status. Git will list every modified file and the current status of each file.\nThis status can be either:\n\nUnchanged (unmodified), meaning nothing has changed since you last transferred it, or\nIt’s been changed (changed) but not staged (staged) to be transferred into the history, or\nSomething has been added to staging (staged) and is ready to be transferred into the history.\n\nWhen you run git status, you get an overview of the current state of your project.\n\n\n\n\n\n\nContinuing the example from above:\n\n\n\nThe git status command displays the status of your working directory and the staging area. It shows you which files have been modified, which files are staged for commit, and which files are not yet being tracked:\ngit status\ngit status is a useful tool to keep track of your changes and ensure that you have added all the desired files for commit."
  },
  {
    "objectID": "9999_git_intro_en.html#review-your-repositorys-history-git-log",
    "href": "9999_git_intro_en.html#review-your-repositorys-history-git-log",
    "title": "Appendix B — Git Intro DE",
    "section": "D.6 Review Your Repository’s History: git log",
    "text": "D.6 Review Your Repository’s History: git log\n\n\n\n\n\n\nContinuing the example from above:\n\n\n\nYou can view the history of your commits with the git log command. This command displays a list of all the commits in the current branch, along with information such as the author, date, and commit message:\ngit log\nThere are many options to customize the output of git log. For example, you can use the --pretty option to change the format of the output:\ngit log --pretty=oneline\nThis displays each commit in a single line."
  },
  {
    "objectID": "9999_git_intro_en.html#creating-an-alternative-timeline-git-branch",
    "href": "9999_git_intro_en.html#creating-an-alternative-timeline-git-branch",
    "title": "Appendix B — Git Intro DE",
    "section": "E.1 Creating an Alternative Timeline: git branch",
    "text": "E.1 Creating an Alternative Timeline: git branch\nIn the course of developing a project, you often reach a point where you want to add a new feature, but doing so might require changing the existing code in a way that could be challenging to undo later.\nOr maybe you just want to experiment and be able to discard your work if the experiment fails. In such cases, Git allows you to create an alternative timeline called a branch to work in.\nThis new branch has its own name and exists in parallel with the main branch and all other branches in your project.\nDuring development, you can switch between branches and work on different versions of your code concurrently. This way, you can have a stable codebase in the main branch while developing an experimental feature in a separate branch. When you switch from one branch to another, the code you’re working on is automatically reset to the latest commit of the branch you’re currently in.\nIf you’re working in a team, different team members can work on their own branches, creating an entire universe of alternative timelines for your project. When features are completed, they can be seamlessly merged back into the main branch.\n\n\n\n\n\n\nContinuing the example from above:\n\n\n\nTo create a new branch, you can use the git branch command with the name of the new branch as an argument:\ngit branch my-tests"
  },
  {
    "objectID": "9999_git_intro_en.html#the-pointer-to-the-current-branch-head",
    "href": "9999_git_intro_en.html#the-pointer-to-the-current-branch-head",
    "title": "Appendix B — Git Intro DE",
    "section": "E.2 The Pointer to the Current Branch: HEAD",
    "text": "E.2 The Pointer to the Current Branch: HEAD\nHow does Git know where you are on the timeline, and how can you keep track of your position?\nYou’re always working at the tip (HEAD) of the currently active branch. The HEAD pointer points there quite literally. In a new project archive with just a single main branch and only new commits being added, HEAD always points to the latest commit in the main branch. That’s where you are.\nHowever, if you’re in a repository with multiple branches, meaning multiple alternative timelines, HEAD will point to the latest commit in the branch you’re currently working on."
  },
  {
    "objectID": "9999_git_intro_en.html#switching-to-an-alternative-timeline-git-switch",
    "href": "9999_git_intro_en.html#switching-to-an-alternative-timeline-git-switch",
    "title": "Appendix B — Git Intro DE",
    "section": "E.3 Switching to an Alternative Timeline: git switch",
    "text": "E.3 Switching to an Alternative Timeline: git switch\nAs your project grows, and you have multiple branches, you need to be able to switch between these branches. This is where the switch command comes into play.\nAt any time, you can use the git switch command with the name of the branch you want to switch to, and HEAD moves from your current branch to the one you specified.\nIf you’ve made changes to your code before switching, Git will attempt to carry those changes over to the branch you’re switching to. However, if these changes conflict with the target branch, the switch will be canceled.\nTo resolve this issue without losing your changes, return to the original branch, add and commit your recent changes, and then perform the switch."
  },
  {
    "objectID": "9999_git_intro_en.html#switching-to-an-alternative-timeline-and-making-changes-git-checkout",
    "href": "9999_git_intro_en.html#switching-to-an-alternative-timeline-and-making-changes-git-checkout",
    "title": "Appendix B — Git Intro DE",
    "section": "E.4 Switching to an Alternative Timeline and Making Changes: git checkout",
    "text": "E.4 Switching to an Alternative Timeline and Making Changes: git checkout\nTo switch between branches, you can also use the git checkout command. It works similarly to git switch for this purpose: you pass the name of the branch you want to switch to, and HEAD moves to the beginning of that branch.\nBut checkout can do more than just switch to another timeline. With git checkout, you can also move to any commit point in any timeline. In other words, you can travel back in time and work on code from the past.\nTo do this, use git checkout and provide the commit ID. This is an automatically generated, random combination of letters and numbers that identifies each commit. You can retrieve the commit ID using git log. When you run git log, you get a list of all the commits in your repository, starting with the most recent ones.\nWhen you use git checkout with an older commit ID, you check out a commit in the middle of a branch. This disrupts the timeline, as you’re actively attempting to change history. Git doesn’t want you to do that because, much like in a science fiction movie, altering the past might also alter the future. In our case, it would break the version control branch’s coherence.\nTo prevent you from accidentally disrupting time and altering history, checking out an earlier commit in any branch results in the warning “Detached Head,” which sounds rather ominous. The “Detached Head” warning is appropriate because it accurately describes what’s happening. Git literally detaches the head from the branch and sets it aside.\nNow, you’re working outside of time in a space unbound to any timeline, which again sounds rather threatening but is perfectly fine in reality.\nTo continue working on this past code, all you need to do is reattach it to the timeline. You can use git branch to create a new branch, and the detached head will automatically attach to this new branch.\nInstead of breaking the history, you’ve now created a new alternative timeline that starts in the past, allowing you to work safely. You can continue working on the branch as usual.\n\n\n\n\n\n\nContinuing the example from above:\n\n\n\nTo switch to a new branch, you can use the git checkout command:\ngit checkout meine-tests\nNow you’re using the new branch and can make changes independently from the original branch."
  },
  {
    "objectID": "9999_git_intro_en.html#the-difference-between-checkout-and-switch",
    "href": "9999_git_intro_en.html#the-difference-between-checkout-and-switch",
    "title": "Appendix B — Git Intro DE",
    "section": "E.5 The Difference Between checkout and switch",
    "text": "E.5 The Difference Between checkout and switch\nWhat is the difference between git switch and git checkout? git switch and git checkout are two different commands that both serve the purpose of switching between branches. You can use both to switch between branches, but they have an important distinction. git switch is a new command introduced with Git 2.23. git checkout is an older command that has existed since Git 1.6.0. So, git switch and git checkout have different origins. git switch was introduced to separate the purposes of git checkout. git checkout has two different purposes: 1. It can be used to switch between branches, and 2. It can be used to reset files to the state of the last commit.\nHere’s an example: In my project, I made a change since the last commit, but I haven’t staged it yet. Then, I realized that I actually don’t want this change. I want to reset the file to the state before the last commit. As long as I haven’t committed my changes, I can do this with git checkout by targeting the specific file. So, if that file is named main.js, I can say: git checkout main.js. And the file will be reset to the state of the last commit, which makes sense. I’m checking out the file from the last commit.\nBut that’s quite different from switching between the beginning of one branch to another. git switch and git restore were introduced to separate these two operations. git switch is for switching between branches, and git restore is for resetting the specified file to the state of the last commit. If you try to restore a file with git switch, it simply won’t work. It’s not intended for that. As I mentioned earlier, it’s about separating concerns.\n:::{.callout-note} ### Difference Between checkout and switch git checkout and git switch are both commands for switching between branches in a Git repository. The main difference between the two commands is that git switch is a newer command specifically designed for branch switching, while git checkout is an older command that can be used for various tasks, including branch switching.\nHere’s an example demonstrating how to initialize a repository and switch between branches:\n# Create a new directory for your repository\n# and navigate to that directory:\nmkdir my-repo\ncd my-repo\n\n# Initialize the repository with git init:\ngit init\n\n# Create a new branch with git branch:\ngit branch my-new-branch\n\n# Switch to the new branch using git switch:\ngit switch my-new-branch\n\n# Alternatively, you can also use git checkout\n# to switch to the new branch:\n\ngit checkout my-new-branch\nBoth commands lead to the same result: You are now on the new branch."
  },
  {
    "objectID": "9999_git_intro_en.html#git-merge-merging-two-timelines",
    "href": "9999_git_intro_en.html#git-merge-merging-two-timelines",
    "title": "Appendix B — Git Intro DE",
    "section": "F.1 git merge: Merging Two Timelines",
    "text": "F.1 git merge: Merging Two Timelines\nGit allows you to split your development work into as many branches or alternative timelines as you like, enabling you to work on many different versions of your code simultaneously without losing or overwriting any of your work.\nThis is all well and good, but at some point, you need to bring those various versions of your code back together into one branch. That’s where git merge comes in.\nConsider an example where you have two branches, a main branch and an experimental branch called experimental-branch. In the experimental branch, there is a new feature. To merge these two branches, you set HEAD to the branch where you want to incorporate the code and execute git merge followed by the name of the branch you want to merge. HEAD is a special pointer that points to the current branch. When you run git merge, it combines the code from the branch associated with HEAD with the code from the branch specified by the branch name you provide.\n# Initialize the repository\ngit init\n\n# Create a new branch called \"experimental-branch\"\ngit branch experimental-branch\n\n# Switch to the \"experimental-branch\"\ngit checkout experimental-branch\n\n# Add the new feature here and\n# make a commit\n# ...\n\n# Switch back to the \"main\" branch\ngit checkout main\n\n# Perform the merge\ngit merge experimental-branch\nDuring the merge, matching pieces of code in the branches overlap, and any new code from the branch being merged is added to the project. So now, the main branch also contains the code from the experimental branch, and the events of the two separate timelines have been merged into a single one. What’s interesting is that even though the experimental branch was merged with the main branch, the last commit of the experimental branch remains intact, allowing you to continue working on the experimental branch separately if you wish."
  },
  {
    "objectID": "9999_git_intro_en.html#resolving-conflicts-when-merging",
    "href": "9999_git_intro_en.html#resolving-conflicts-when-merging",
    "title": "Appendix B — Git Intro DE",
    "section": "F.2 Resolving Conflicts When Merging",
    "text": "F.2 Resolving Conflicts When Merging\nMerging branches where there are no code changes at the same place in both branches is a straightforward process. It’s also a rare process. In most cases, there will be some form of conflict between the branches – the same code or the same code area has been modified differently in the different branches. Merging two branches with such conflicts will not work, at least not automatically.\nIn this case, Git doesn’t know how to merge this code. So, when such a situation occurs, it’s marked as a conflict, and the merging process is halted. This might sound more dramatic than it is. When you get a conflict warning, Git is saying there are two different versions here, and Git needs to know which one you want to keep. To help you figure out the conflict, Git combines all the code into a single file and automatically marks the conflicting code as the current change, which is the original code from the branch you’re working on, or as the incoming change, which is the code from the file you’re trying to merge.\nTo resolve this conflict, you’ll edit the file to literally resolve the code conflict. This might mean accepting either the current or incoming change and discarding the other. It could mean combining both changes or something else entirely. It’s up to you. So, you edit the code to resolve the conflict. Once you’ve resolved the conflict by editing the code, you add the new conflict-free version to the staging area with git add and then commit the merged code with git commit. That’s how the conflict is resolved.\nA merge conflict occurs when Git struggles to automatically merge changes from two different branches. This usually happens when changes were made to the same line in the same file in both branches. To resolve a merge conflict, you must manually edit the affected files and choose the desired changes. Git marks the conflict areas in the file with special markings like &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, and &gt;&gt;&gt;&gt;&gt;&gt;&gt;. You can search for these markings and manually select the desired changes. After resolving the conflicts, you can add the changes with git add and create a new commit with git commit to complete the merge.\nHere’s an example:\n# Perform the merge (this will cause a conflict)\ngit merge experimenteller-branch\n\n# Open the affected file in an editor and manually resolve the conflicts\n# ...\n\n# Add the modified file\ngit add &lt;filename&gt;\n\n# Create a new commit\ngit commit -m \"Resolved conflicts\""
  },
  {
    "objectID": "9999_git_intro_en.html#git-revert-undoing-something",
    "href": "9999_git_intro_en.html#git-revert-undoing-something",
    "title": "Appendix B — Git Intro DE",
    "section": "F.3 git revert: Undoing Something",
    "text": "F.3 git revert: Undoing Something\nOne of the most powerful features of any software tool is the “Undo” button. Make a mistake, press “Undo,” and it’s as if it never happened. However, that’s not quite as simple when an all-powerful, passive observer is watching and recording your project’s history. How do you undo something that you’ve added to the history without rewriting the history?\nThe answer is that you can overwrite the history with the git reset command, but that’s quite risky and not a good practice.\nA better solution is to work with the historical timeline and simply place an older version of your code at the top of the branch. This is done with git revert. To make this work, you need to know the commit ID of the commit you want to go back to.\nThe commit ID is a machine-generated set of random numbers and letters, also known as a hash. To get a list of all the commits in the repository, including the commit ID and commit message, you can run git log.\n# Show the list of all operations in the repository\ngit log\nBy the way, it’s a good idea to leave clear and informative commit messages for this reason. This way, you know what happened in your previous commits. Once you’ve found the commit you want to revert to, call that commit ID with git revert, and then the ID. This will create a new commit at the top of the branch with the code from the reference commit. To transfer the code to the branch, add a commit message and save it. Now, the last commit in your branch matches the commit you’re reverting to, and your project’s history remains intact.\n\n\n\n\n\n\nAn example with git revert\n\n\n\n# Initialize a new repository\ngit init\n\n# Create a new file\necho \"Hello, World\" &gt; file.txt\n\n# Add the file to the repository\ngit add file.txt\n\n# Create a new commit\ngit commit -m \"First commit\"\n\n# Modify the file\necho \"Goodbye, World\" &gt; file.txt\n\n# Add the modified file\ngit add file.txt\n\n# Create a new commit\ngit commit -m \"Second commit\"\n\n# Use git log to find the commit ID of the second commit\ngit log\n\n# Use git revert to undo the changes from the second commit\ngit revert &lt;commit-id&gt;\n\n\nTo download the students branch from the repository git@git-ce.rwth-aachen.de:spotseven-lab/numerische-mathematik-sommersemester2023.git to your local machine, add a file, and upload the changes, you can follow these steps:\n\n\n\n\n\n\nAn example with git clone, git checkout, git add, git commit, git push\n\n\n\n# Clone the repository to your local machine:\ngit clone git@git-ce.rwth-aachen.de:spotseven-lab/numerische-mathematik-sommersemester2023.git\n\n# Change to the cloned repository:\ncd numerische-mathematik-sommersemester2023\n\n# Switch to the students branch:\ngit checkout students\n\n# Create the Test folder if it doesn't exist:\nmkdir Test\n\n# Create the Testdatei.txt file in the Test folder:\ntouch Test/Testdatei.txt\n\n# Add the file with git add:\ngit add Test/Testdatei.txt\n\n# Commit the changes with git commit:\ngit commit -m \"Added Testdatei.txt\"\n\n# Push the changes with git push:\ngit push origin students\nThis will upload the changes to the server and update the students branch in the repository."
  },
  {
    "objectID": "9999_git_intro_en.html#git-rebase-moving-the-base-of-a-branch",
    "href": "9999_git_intro_en.html#git-rebase-moving-the-base-of-a-branch",
    "title": "Appendix B — Git Intro DE",
    "section": "H.1 git rebase: Moving the Base of a Branch",
    "text": "H.1 git rebase: Moving the Base of a Branch\nIn some cases, you may need to “rewrite history.” A common scenario is that you’ve been working on a new feature in a feature branch, and you realize that the work should have actually happened in the main branch.\nTo resolve this issue and make it appear as if the work occurred in the main branch, you can reset the experimental branch. “Rebase” literally means detaching the base of the experimental branch and moving it to the beginning of another branch, giving the branch a new base, thus “rebasing.”\nThis operation is performed from the branch you want to “rebase.” You use git rebase and specify the branch you want to use as the new base. If there are no conflicts between the experimental branch and the branch you want to rebase onto, this process happens automatically.\nIf there are conflicts, Git will guide you through the conflict resolution process for each commit from the rebase branch.\nThis may sound like a lot, but there’s a good reason for it. You are literally rewriting history by transferring commits from one branch to another. To maintain the coherence of the new version history, there should be no conflicts within the commits. So, you need to resolve them one by one until the history is clean. It goes without saying that this can be a fairly labor-intensive process. Therefore, you should not use git rebase frequently.\n\n\n\n\n\n\nAn example with git rebase\n\n\n\ngit rebase is a command used to change the base of a branch. This means that commits from the branch are applied to a new base, which is usually another branch. It can be used to clean up the repository history and avoid merge conflicts.\nHere is an example showing how to use git rebase:\n\nIn this example, we initialize a new Git repository and create a new file. We add the file to the repository and make an initial commit. Then, we create a new branch called “feature” and switch to that branch. We make changes to the file in the feature branch and create a new commit.\nThen, we switch back to the main branch and make changes to the file again. We add the modified file and make another commit.\nTo rebase the feature branch onto the main branch, we first switch to the feature branch and then use the git rebase command with the name of the main branch as an argument. This applies the commits from the feature branch to the main branch and changes the base of the feature branch.\n\n# Initialize a new repository\ngit init\n# Create a new file\necho \"Hello World\" &gt; file.txt\n# Add the file to the repository\ngit add file.txt\n# Create an initial commit\ngit commit -m \"Initial commit\"\n# Create a new branch called \"feature\"\ngit branch feature\n# Switch to the \"feature\" branch\ngit checkout feature\n# Make changes to the file in the \"feature\" branch\necho \"Hello Feature World\" &gt; file.txt\n# Add the modified file\ngit add file.txt\n# Create a new commit in the \"feature\" branch\ngit commit -m \"Feature commit\"\n# Switch back to the \"main\" branch\ngit checkout main\n# Make changes to the file in the \"main\" branch\necho \"Hello Main World\" &gt; file.txt\n# Add the modified file\ngit add file.txt\n# Create a new commit in the \"main\" branch\ngit commit -m \"Main commit\"\n# Use git rebase to rebase the \"feature\" branch\n# onto the \"main\" branch\ngit checkout feature\ngit rebase main"
  },
  {
    "objectID": "9999_git_intro_en.html#learning-objectives",
    "href": "9999_git_intro_en.html#learning-objectives",
    "title": "Appendix B — Git Introduction",
    "section": "B.1 Learning Objectives",
    "text": "B.1 Learning Objectives\nIn this learning unit, you will learn how to set up Git as a version control system for a project. The most important Git commands will be explained. You will learn how to track and manage changes to your projects with Git. Specifically:\n\nInitializing a repository: git init\nIgnoring files: .gitignore\nAdding files to the staging area: git add\nChecking status changes: git status\nReviewing history: git log\nCreating a new branch: git branch\nSwitching to the current branch: git switch and git checkout\nMerging two branches: git merge\nResolving conflicts\nReverting changes: git revert\nUploading changes to GitLab: git push\nDownloading changes from GitLab: git pull\nAdvanced: git rebase"
  },
  {
    "objectID": "9999_git_intro_en.html#basics-of-git",
    "href": "9999_git_intro_en.html#basics-of-git",
    "title": "Appendix B — Git Introduction",
    "section": "B.2 Basics of Git",
    "text": "B.2 Basics of Git\n\nB.2.1 Initializing a Repository: git init\nTo set up Git as a version control system for your project, you need to initialize a new Git repository at the top-level folder, which is the working directory of your project. This is done using the git init command.\nAll files in this folder and its subfolders will automatically become part of the repository. Creating a Git repository is similar to adding an all-powerful passive observer of all things to your project. Git sits there, observes, and takes note of even the smallest changes, such as a single character in a file within a repository with hundreds of files. And it will tell you where these changes occurred if you forget. Once Git is initialized, it monitors all changes made within the working directory, and it tracks the history of events from that point forward. For this purpose, a historical timeline is created for your project, referred to as a “branch,” and the initial branch is named main. So, when someone says they are on the main branch or working on the main branch, it means they are in the historical main timeline of the project. The Git repository, often abbreviated as repo, is a virtual representation of your project, including its history and branches, a book, if you will, where you can look up and retrieve the entire history of the project: you work in your working directory, and the Git repository tracks and stores your work.\n\n\nB.2.2 Ignoring Files: .gitignore\nIt’s useful that Git watches and keeps an eye on everything in your project. However, in most projects, there are files and folders that you don’t need or want to keep an eye on. These may include system files, local project settings, libraries with dependencies, and so on.\nYou can exclude any file or folder from your Git repository by including them in the .gitignore file. In the .gitignore file, you create a list of file names, folder names, and other items that Git should not track, and Git will ignore these items. Hence the name “gitignore.” Do you want to track a file that you previously ignored? Simply remove the mention of the file in the gitignore file, and Git will start tracking it again.\n\n\nB.2.3 Adding Changes to the Staging Area: git add\nThe interesting thing about Git as an all-powerful, passive observer of all things is that it’s very passive. As long as you don’t tell Git what to remember, it will passively observe the changes in the project folder but do nothing.\nWhen you make a change to your project that you want Git to include in the project’s history to take a snapshot of so you can refer back to it later, your personal checkpoint, if you will, you need to first stage the changes in the staging area. What is the staging area? The staging area is where you collect changes to files that you want to include in the project’s history.\nThis is done using the git add command. You can specify which files you want to add by naming them, or you can add all of them using -A. By doing this, you’re telling Git that you’ve made changes and want it to remember these particular changes so you can recall them later if needed. This is important because you can choose which changes you want to stage, and those are the changes that will eventually be transferred to the history.\n\nNote: When you run git add, the changes are not transferred to the project’s history. They are only transferred to the staging area.\n\n\n\n\n\n\n\nExample of git add from the beginning\n\n\n\n# Create a new directory for your\n# repository and navigate to that directory:\n\nmkdir my-repo\ncd my-repo\n\n# Initialize the repository with git init:\n\ngit init\n\n# Create a .gitignore file for Python code.\n# You can use a template from GitHub:\n\ncurl https://raw.githubusercontent.com/github/gitignore/master/Python.gitignore -o .gitignore\n\n# Add your files to the repository using git add:\n\ngit add .\nThis adds all files in the current directory to the repository, except for the files listed in the .gitignore file.\n\n\n\n\nB.2.4 Transferring Changes to Memory: git commit\nThe power of Git becomes evident when you start transferring changes to the project history. This is done using the git commit command. When you run git commit, you inform Git that the changes in the staging area should be added to the history of the project so that they can be referenced or retrieved later.\nAdditionally, you can add a commit message with the -m option to explain what changes were made. So when you look back at the project history, you can see that you added a new feature.\ngit commit creates a snapshot, an image of the current state of your project at that specific time, and adds it to the branch you are currently working on.\nAs you work on your project and transfer more snapshots, the branch grows and forms a timeline of events. This means you can now look back at every transfer in the branch and see what your code looked like at that time.\nYou can compare any phase of your code with any other phase of your code to find errors, restore deleted code, or do things that would otherwise not be possible, such as resetting the project to a previous state or creating a new timeline from any point.\nSo how often should you add these commits? My rule of thumb is not to commit too often. It’s better to have a Git repository with too many commits than one with too few commits.\n\n\n\n\n\n\nContinuing the example from above:\n\n\n\nAfter adding your files with git add, you can create a commit to save your changes. Use the git commit command with the -m option to specify your commit message:\ngit commit -m \"My first commit message\"\nThis creates a new commit with the added files and the specified commit message.\n\n\n\n\nB.2.5 Check the Status of Your Repository: git status\nIf you’re wondering what you’ve changed in your project since the last commit snapshot, you can always check the Git status. Git will list every modified file and the current status of each file.\nThis status can be either:\n\nUnchanged (unmodified), meaning nothing has changed since you last transferred it, or\nIt’s been changed (changed) but not staged (staged) to be transferred into the history, or\nSomething has been added to staging (staged) and is ready to be transferred into the history.\n\nWhen you run git status, you get an overview of the current state of your project.\n\n\n\n\n\n\nContinuing the example from above:\n\n\n\nThe git status command displays the status of your working directory and the staging area. It shows you which files have been modified, which files are staged for commit, and which files are not yet being tracked:\ngit status\ngit status is a useful tool to keep track of your changes and ensure that you have added all the desired files for commit.\n\n\n\n\nB.2.6 Review Your Repository’s History: git log\n\n\n\n\n\n\nContinuing the example from above:\n\n\n\nYou can view the history of your commits with the git log command. This command displays a list of all the commits in the current branch, along with information such as the author, date, and commit message:\ngit log\nThere are many options to customize the output of git log. For example, you can use the --pretty option to change the format of the output:\ngit log --pretty=oneline\nThis displays each commit in a single line."
  },
  {
    "objectID": "9999_git_intro_en.html#branches-timelines",
    "href": "9999_git_intro_en.html#branches-timelines",
    "title": "Appendix B — Git Introduction",
    "section": "B.3 Branches (Timelines)",
    "text": "B.3 Branches (Timelines)\n\nB.3.1 Creating an Alternative Timeline: git branch\nIn the course of developing a project, you often reach a point where you want to add a new feature, but doing so might require changing the existing code in a way that could be challenging to undo later.\nOr maybe you just want to experiment and be able to discard your work if the experiment fails. In such cases, Git allows you to create an alternative timeline called a branch to work in.\nThis new branch has its own name and exists in parallel with the main branch and all other branches in your project.\nDuring development, you can switch between branches and work on different versions of your code concurrently. This way, you can have a stable codebase in the main branch while developing an experimental feature in a separate branch. When you switch from one branch to another, the code you’re working on is automatically reset to the latest commit of the branch you’re currently in.\nIf you’re working in a team, different team members can work on their own branches, creating an entire universe of alternative timelines for your project. When features are completed, they can be seamlessly merged back into the main branch.\n\n\n\n\n\n\nContinuing the example from above:\n\n\n\nTo create a new branch, you can use the git branch command with the name of the new branch as an argument:\ngit branch my-tests\n\n\n\n\nB.3.2 The Pointer to the Current Branch: HEAD\nHow does Git know where you are on the timeline, and how can you keep track of your position?\nYou’re always working at the tip (HEAD) of the currently active branch. The HEAD pointer points there quite literally. In a new project archive with just a single main branch and only new commits being added, HEAD always points to the latest commit in the main branch. That’s where you are.\nHowever, if you’re in a repository with multiple branches, meaning multiple alternative timelines, HEAD will point to the latest commit in the branch you’re currently working on.\n\n\nB.3.3 Switching to an Alternative Timeline: git switch\nAs your project grows, and you have multiple branches, you need to be able to switch between these branches. This is where the switch command comes into play.\nAt any time, you can use the git switch command with the name of the branch you want to switch to, and HEAD moves from your current branch to the one you specified.\nIf you’ve made changes to your code before switching, Git will attempt to carry those changes over to the branch you’re switching to. However, if these changes conflict with the target branch, the switch will be canceled.\nTo resolve this issue without losing your changes, return to the original branch, add and commit your recent changes, and then perform the switch.\n\n\nB.3.4 Switching to an Alternative Timeline and Making Changes: git checkout\nTo switch between branches, you can also use the git checkout command. It works similarly to git switch for this purpose: you pass the name of the branch you want to switch to, and HEAD moves to the beginning of that branch.\nBut checkout can do more than just switch to another timeline. With git checkout, you can also move to any commit point in any timeline. In other words, you can travel back in time and work on code from the past.\nTo do this, use git checkout and provide the commit ID. This is an automatically generated, random combination of letters and numbers that identifies each commit. You can retrieve the commit ID using git log. When you run git log, you get a list of all the commits in your repository, starting with the most recent ones.\nWhen you use git checkout with an older commit ID, you check out a commit in the middle of a branch. This disrupts the timeline, as you’re actively attempting to change history. Git doesn’t want you to do that because, much like in a science fiction movie, altering the past might also alter the future. In our case, it would break the version control branch’s coherence.\nTo prevent you from accidentally disrupting time and altering history, checking out an earlier commit in any branch results in the warning “Detached Head,” which sounds rather ominous. The “Detached Head” warning is appropriate because it accurately describes what’s happening. Git literally detaches the head from the branch and sets it aside.\nNow, you’re working outside of time in a space unbound to any timeline, which again sounds rather threatening but is perfectly fine in reality.\nTo continue working on this past code, all you need to do is reattach it to the timeline. You can use git branch to create a new branch, and the detached head will automatically attach to this new branch.\nInstead of breaking the history, you’ve now created a new alternative timeline that starts in the past, allowing you to work safely. You can continue working on the branch as usual.\n\n\n\n\n\n\nContinuing the example from above:\n\n\n\nTo switch to a new branch, you can use the git checkout command:\ngit checkout meine-tests\nNow you’re using the new branch and can make changes independently from the original branch.\n\n\n\n\nB.3.5 The Difference Between checkout and switch\nWhat is the difference between git switch and git checkout? git switch and git checkout are two different commands that both serve the purpose of switching between branches. You can use both to switch between branches, but they have an important distinction. git switch is a new command introduced with Git 2.23. git checkout is an older command that has existed since Git 1.6.0. So, git switch and git checkout have different origins. git switch was introduced to separate the purposes of git checkout. git checkout has two different purposes: 1. It can be used to switch between branches, and 2. It can be used to reset files to the state of the last commit.\nHere’s an example: In my project, I made a change since the last commit, but I haven’t staged it yet. Then, I realized that I actually don’t want this change. I want to reset the file to the state before the last commit. As long as I haven’t committed my changes, I can do this with git checkout by targeting the specific file. So, if that file is named main.js, I can say: git checkout main.js. And the file will be reset to the state of the last commit, which makes sense. I’m checking out the file from the last commit.\nBut that’s quite different from switching between the beginning of one branch to another. git switch and git restore were introduced to separate these two operations. git switch is for switching between branches, and git restore is for resetting the specified file to the state of the last commit. If you try to restore a file with git switch, it simply won’t work. It’s not intended for that. As I mentioned earlier, it’s about separating concerns.\n:::{.callout-note} #### Difference Between checkout and switch git checkout and git switch are both commands for switching between branches in a Git repository. The main difference between the two commands is that git switch is a newer command specifically designed for branch switching, while git checkout is an older command that can be used for various tasks, including branch switching.\nHere’s an example demonstrating how to initialize a repository and switch between branches:\n# Create a new directory for your repository\n# and navigate to that directory:\nmkdir my-repo\ncd my-repo\n\n# Initialize the repository with git init:\ngit init\n\n# Create a new branch with git branch:\ngit branch my-new-branch\n\n# Switch to the new branch using git switch:\ngit switch my-new-branch\n\n# Alternatively, you can also use git checkout\n# to switch to the new branch:\n\ngit checkout my-new-branch\nBoth commands lead to the same result: You are now on the new branch."
  },
  {
    "objectID": "9999_git_intro_en.html#merging-branches-and-resolving-conflicts",
    "href": "9999_git_intro_en.html#merging-branches-and-resolving-conflicts",
    "title": "Appendix B — Git Introduction",
    "section": "B.4 Merging Branches and Resolving Conflicts",
    "text": "B.4 Merging Branches and Resolving Conflicts\n\nB.4.1 git merge: Merging Two Timelines\nGit allows you to split your development work into as many branches or alternative timelines as you like, enabling you to work on many different versions of your code simultaneously without losing or overwriting any of your work.\nThis is all well and good, but at some point, you need to bring those various versions of your code back together into one branch. That’s where git merge comes in.\nConsider an example where you have two branches, a main branch and an experimental branch called experimental-branch. In the experimental branch, there is a new feature. To merge these two branches, you set HEAD to the branch where you want to incorporate the code and execute git merge followed by the name of the branch you want to merge. HEAD is a special pointer that points to the current branch. When you run git merge, it combines the code from the branch associated with HEAD with the code from the branch specified by the branch name you provide.\n# Initialize the repository\ngit init\n\n# Create a new branch called \"experimental-branch\"\ngit branch experimental-branch\n\n# Switch to the \"experimental-branch\"\ngit checkout experimental-branch\n\n# Add the new feature here and\n# make a commit\n# ...\n\n# Switch back to the \"main\" branch\ngit checkout main\n\n# Perform the merge\ngit merge experimental-branch\nDuring the merge, matching pieces of code in the branches overlap, and any new code from the branch being merged is added to the project. So now, the main branch also contains the code from the experimental branch, and the events of the two separate timelines have been merged into a single one. What’s interesting is that even though the experimental branch was merged with the main branch, the last commit of the experimental branch remains intact, allowing you to continue working on the experimental branch separately if you wish.\n\n\nB.4.2 Resolving Conflicts When Merging\nMerging branches where there are no code changes at the same place in both branches is a straightforward process. It’s also a rare process. In most cases, there will be some form of conflict between the branches – the same code or the same code area has been modified differently in the different branches. Merging two branches with such conflicts will not work, at least not automatically.\nIn this case, Git doesn’t know how to merge this code. So, when such a situation occurs, it’s marked as a conflict, and the merging process is halted. This might sound more dramatic than it is. When you get a conflict warning, Git is saying there are two different versions here, and Git needs to know which one you want to keep. To help you figure out the conflict, Git combines all the code into a single file and automatically marks the conflicting code as the current change, which is the original code from the branch you’re working on, or as the incoming change, which is the code from the file you’re trying to merge.\nTo resolve this conflict, you’ll edit the file to literally resolve the code conflict. This might mean accepting either the current or incoming change and discarding the other. It could mean combining both changes or something else entirely. It’s up to you. So, you edit the code to resolve the conflict. Once you’ve resolved the conflict by editing the code, you add the new conflict-free version to the staging area with git add and then commit the merged code with git commit. That’s how the conflict is resolved.\nA merge conflict occurs when Git struggles to automatically merge changes from two different branches. This usually happens when changes were made to the same line in the same file in both branches. To resolve a merge conflict, you must manually edit the affected files and choose the desired changes. Git marks the conflict areas in the file with special markings like &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, and &gt;&gt;&gt;&gt;&gt;&gt;&gt;. You can search for these markings and manually select the desired changes. After resolving the conflicts, you can add the changes with git add and create a new commit with git commit to complete the merge.\nHere’s an example:\n# Perform the merge (this will cause a conflict)\ngit merge experimenteller-branch\n\n# Open the affected file in an editor and manually resolve the conflicts\n# ...\n\n# Add the modified file\ngit add &lt;filename&gt;\n\n# Create a new commit\ngit commit -m \"Resolved conflicts\"\n\n\nB.4.3 git revert: Undoing Something\nOne of the most powerful features of any software tool is the “Undo” button. Make a mistake, press “Undo,” and it’s as if it never happened. However, that’s not quite as simple when an all-powerful, passive observer is watching and recording your project’s history. How do you undo something that you’ve added to the history without rewriting the history?\nThe answer is that you can overwrite the history with the git reset command, but that’s quite risky and not a good practice.\nA better solution is to work with the historical timeline and simply place an older version of your code at the top of the branch. This is done with git revert. To make this work, you need to know the commit ID of the commit you want to go back to.\nThe commit ID is a machine-generated set of random numbers and letters, also known as a hash. To get a list of all the commits in the repository, including the commit ID and commit message, you can run git log.\n# Show the list of all operations in the repository\ngit log\nBy the way, it’s a good idea to leave clear and informative commit messages for this reason. This way, you know what happened in your previous commits. Once you’ve found the commit you want to revert to, call that commit ID with git revert, and then the ID. This will create a new commit at the top of the branch with the code from the reference commit. To transfer the code to the branch, add a commit message and save it. Now, the last commit in your branch matches the commit you’re reverting to, and your project’s history remains intact.\n\n\n\n\n\n\nAn example with git revert\n\n\n\n# Initialize a new repository\ngit init\n\n# Create a new file\necho \"Hello, World\" &gt; file.txt\n\n# Add the file to the repository\ngit add file.txt\n\n# Create a new commit\ngit commit -m \"First commit\"\n\n# Modify the file\necho \"Goodbye, World\" &gt; file.txt\n\n# Add the modified file\ngit add file.txt\n\n# Create a new commit\ngit commit -m \"Second commit\"\n\n# Use git log to find the commit ID of the second commit\ngit log\n\n# Use git revert to undo the changes from the second commit\ngit revert &lt;commit-id&gt;\n\n\nTo download the students branch from the repository git@git-ce.rwth-aachen.de:spotseven-lab/numerische-mathematik-sommersemester2023.git to your local machine, add a file, and upload the changes, you can follow these steps:\n\n\n\n\n\n\nAn example with git clone, git checkout, git add, git commit, git push\n\n\n\n# Clone the repository to your local machine:\ngit clone git@git-ce.rwth-aachen.de:spotseven-lab/numerische-mathematik-sommersemester2023.git\n\n# Change to the cloned repository:\ncd numerische-mathematik-sommersemester2023\n\n# Switch to the students branch:\ngit checkout students\n\n# Create the Test folder if it doesn't exist:\nmkdir Test\n\n# Create the Testdatei.txt file in the Test folder:\ntouch Test/Testdatei.txt\n\n# Add the file with git add:\ngit add Test/Testdatei.txt\n\n# Commit the changes with git commit:\ngit commit -m \"Added Testdatei.txt\"\n\n# Push the changes with git push:\ngit push origin students\nThis will upload the changes to the server and update the students branch in the repository."
  },
  {
    "objectID": "9999_git_intro_en.html#downloading-from-gitlab",
    "href": "9999_git_intro_en.html#downloading-from-gitlab",
    "title": "Appendix B — Git Introduction",
    "section": "B.5 Downloading from GitLab",
    "text": "B.5 Downloading from GitLab\nTo download changes from a GitLab repository to your local machine, you can use the git pull command. This command downloads the latest changes from the specified remote repository and merges them with your local repository.\nHere is an example:\n\n\n\n\n\n\nAn example with git pull\n\n\n\n\n# Navigate to the local repository\n# linked to the GitHub repository:\ncd my-local-repository\n\n# Make sure you are in the correct branch:\ngit checkout main\n\n# Download the latest changes from GitHub:\ngit pull origin main\nThis downloads the latest changes from the main branch of the remote repository named “origin” and merges them with your local repository.\n\n\n\nIf there are conflicts between the downloaded changes and your local changes, you will need to resolve them manually before proceeding."
  },
  {
    "objectID": "9999_git_intro_en.html#advanced",
    "href": "9999_git_intro_en.html#advanced",
    "title": "Appendix B — Git Introduction",
    "section": "B.6 Advanced",
    "text": "B.6 Advanced\n\nB.6.1 git rebase: Moving the Base of a Branch\nIn some cases, you may need to “rewrite history.” A common scenario is that you’ve been working on a new feature in a feature branch, and you realize that the work should have actually happened in the main branch.\nTo resolve this issue and make it appear as if the work occurred in the main branch, you can reset the experimental branch. “Rebase” literally means detaching the base of the experimental branch and moving it to the beginning of another branch, giving the branch a new base, thus “rebasing.”\nThis operation is performed from the branch you want to “rebase.” You use git rebase and specify the branch you want to use as the new base. If there are no conflicts between the experimental branch and the branch you want to rebase onto, this process happens automatically.\nIf there are conflicts, Git will guide you through the conflict resolution process for each commit from the rebase branch.\nThis may sound like a lot, but there’s a good reason for it. You are literally rewriting history by transferring commits from one branch to another. To maintain the coherence of the new version history, there should be no conflicts within the commits. So, you need to resolve them one by one until the history is clean. It goes without saying that this can be a fairly labor-intensive process. Therefore, you should not use git rebase frequently.\n\n\n\n\n\n\nAn example with git rebase\n\n\n\ngit rebase is a command used to change the base of a branch. This means that commits from the branch are applied to a new base, which is usually another branch. It can be used to clean up the repository history and avoid merge conflicts.\nHere is an example showing how to use git rebase:\n\nIn this example, we initialize a new Git repository and create a new file. We add the file to the repository and make an initial commit. Then, we create a new branch called “feature” and switch to that branch. We make changes to the file in the feature branch and create a new commit.\nThen, we switch back to the main branch and make changes to the file again. We add the modified file and make another commit.\nTo rebase the feature branch onto the main branch, we first switch to the feature branch and then use the git rebase command with the name of the main branch as an argument. This applies the commits from the feature branch to the main branch and changes the base of the feature branch.\n\n# Initialize a new repository\ngit init\n# Create a new file\necho \"Hello World\" &gt; file.txt\n# Add the file to the repository\ngit add file.txt\n# Create an initial commit\ngit commit -m \"Initial commit\"\n# Create a new branch called \"feature\"\ngit branch feature\n# Switch to the \"feature\" branch\ngit checkout feature\n# Make changes to the file in the \"feature\" branch\necho \"Hello Feature World\" &gt; file.txt\n# Add the modified file\ngit add file.txt\n# Create a new commit in the \"feature\" branch\ngit commit -m \"Feature commit\"\n# Switch back to the \"main\" branch\ngit checkout main\n# Make changes to the file in the \"main\" branch\necho \"Hello Main World\" &gt; file.txt\n# Add the modified file\ngit add file.txt\n# Create a new commit in the \"main\" branch\ngit commit -m \"Main commit\"\n# Use git rebase to rebase the \"feature\" branch\n# onto the \"main\" branch\ngit checkout feature\ngit rebase main"
  },
  {
    "objectID": "91_intro_to_notebooks.html#different-notebook-cells",
    "href": "91_intro_to_notebooks.html#different-notebook-cells",
    "title": "Appendix A — Introduction to Jupyter Notebook",
    "section": "A.1 Different Notebook cells",
    "text": "A.1 Different Notebook cells\nThere are different cells that the notebook is currently supporting:\n\ncode cells\nmarkdown cells\nraw cells\n\nAs a default, every cells in jupyter is set to “code”\n\nA.1.1 Code cells\nThe code cells are used to execute the code. They are following the logic of the choosen kernel. Therefore, it is important to keep in mind which programming language is currently used. Otherwise one might yield an error because of the wrong syntax.\nThe code cells are executed my be ▶ Run button (can be found in the header of the notebook).\n\n\nA.1.2 Markdown cells\nThe markdown cells are a usefull tool to comment the written code. Especially with the help of headers can the code be brought in a more readable format. If you are not familiar with the markdown syntax, you can find a usefull cheat sheet here: Markdown Cheat Sheeet\n\n\nA.1.3 Raw cells\nThe “Raw NBConvert” cell type can be used to render different code formats into HTML or LaTeX by Sphinx. This information is stored in the notebook metadata and converted appropriately.\n\nA.1.3.1 Usage\nTo select a desired format from within Jupyter, select the cell containing your special code and choose options from the following dropdown menus:\n\nSelect “Raw NBConvert”\nSwitch the Cell Toolbar to “Raw Cell Format” (The cell toolbar can be found under View)\nChose the appropriate “Raw NBConvert Format” within the cell\n\nData Science is fun"
  },
  {
    "objectID": "91_intro_to_notebooks.html#install-packages",
    "href": "91_intro_to_notebooks.html#install-packages",
    "title": "Appendix A — Introduction to Jupyter Notebook",
    "section": "A.2 Install Packages",
    "text": "A.2 Install Packages\nBecause python is a heavily used programming language, there are many different packags that can make your life easier. Sadly, there are only a few standard packages that are already included in your python enviroment. If you have the need to install a new package in your enviroment, you can simply do that by exectuing the following code snippet in a code cell\n!pip install numpy\n\nThe ! is used to run the cell as a shell command\npip is package manager for python packages.\nnumpy is the the package you want to install\n\nHint: It is often usefull to restart the kernel after installing a package, otherwise loading the package could lead to an error."
  },
  {
    "objectID": "91_intro_to_notebooks.html#load-packages",
    "href": "91_intro_to_notebooks.html#load-packages",
    "title": "Appendix A — Introduction to Jupyter Notebook",
    "section": "A.3 Load Packages",
    "text": "A.3 Load Packages\nAfter successfully installing the package it is necessary to import them before you can work with them. The import of the packages is done in the following way:\nimport numpy as np\nThe imported packages are often abbreviated. This is because you need to specify where the function is coming from.\nThe most common abbreviations for data science packages are:\n\nAbbreviations for data science packages\n\n\nAbbreviation\nPackage\nImport\n\n\n\n\nnp\nnumpy\nimport numpy as np\n\n\npd\npandas\nimport pandas as pd\n\n\nplt\nmatplotlib\nimport matplotlib.pyplot as plt\n\n\npx\nplotly\nimport plotly.exprss as px\n\n\ntf\ntensorflow\nimport tensorflow as tf\n\n\nsns\nseaborn\nimport seaborn as sns\n\n\ndt\ndatetime\nimport datetime as dt\n\n\npkl\npickle\nimport pickle as pkl"
  },
  {
    "objectID": "91_intro_to_notebooks.html#functions-in-python",
    "href": "91_intro_to_notebooks.html#functions-in-python",
    "title": "Appendix A — Introduction to Jupyter Notebook",
    "section": "A.4 Functions in Python",
    "text": "A.4 Functions in Python\nBecause python is not using Semicolon’s it is import to keep track of indentation in your code. The indentation works as a placeholder for the semicolons. This is especially important if your are defining loops, functions, etc. …\nExample: We are defining a function that calculates the squared sum of its input parameters\n\ndef squared_sum(x,y): \n    z = x**2 + y**2\n    return z\n\nIf you are working with something that needs indentation, it will be already done by the notebook.\nHint: Keep in mind that is good practice to use the return parameter. If you are not using return and a function has multiple paramaters that you would like to return, it will only return the last one defined."
  },
  {
    "objectID": "91_intro_to_notebooks.html#list-of-useful-jupyter-notebook-shortcuts",
    "href": "91_intro_to_notebooks.html#list-of-useful-jupyter-notebook-shortcuts",
    "title": "Appendix A — Introduction to Jupyter Notebook",
    "section": "A.5 List of Useful Jupyter Notebook Shortcuts",
    "text": "A.5 List of Useful Jupyter Notebook Shortcuts\n\nList of useful Jupyter Notebook Shortcuts\n\n\n\n\n\n\n\nFunction\nKeyboard Shortcut\nMenu Tools\n\n\n\n\nSave notebook\nEsc + s\nFile → Save and Checkpoint\n\n\nCreate new Cell\nEsc + a (above),  Esc + b (below)\nInsert → Cell above; Insert → Cell below\n\n\nRun Cell\nCtrl + enter\nCell → Run Cell\n\n\nCopy Cell\nc\nCopy Key\n\n\nPaste Cell\nv\nPaste Key\n\n\nInterrupt Kernel\nEsc + i i\nKernel → Interrupt\n\n\nRestart Kernel\nEsc + 0 0\nKernel → Restart\n\n\n\nIf you combine everything you can create beautiful graphics\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Generate 100 random data points along 3 dimensions\nx, y, scale = np.random.randn(3, 100)\nfig, ax = plt.subplots()\n\n# Map each onto a scatterplot we'll create with Matplotlib\nax.scatter(x=x, y=y, c=scale, s=np.abs(scale)*500)\nax.set(title=\"Some random data, created with the Jupyter Notebook!\")\nplt.show()"
  },
  {
    "objectID": "911_python_intro_en.html#recommendations",
    "href": "911_python_intro_en.html#recommendations",
    "title": "Appendix C — Python Introduction",
    "section": "C.1 Recommendations",
    "text": "C.1 Recommendations\nBeginner’s Guide to Python"
  }
]